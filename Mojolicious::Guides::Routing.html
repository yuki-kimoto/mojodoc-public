<!DOCTYPE html>
<html>
  <head>
    <!-- meta -->
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0">
<link rel="icon" type="image/x-icon" href="/images/logo.png">
<link rel="stylesheet" type="text/css" href="/css/common.css">

<script type="text/javascript" src="/js/jquery-1.9.0.min.js"></script>
<script type="text/javascript" src="/js/google-code-prettify/prettify.js"></script>
<link  type="text/css" rel="stylesheet" href="/js/google-code-prettify/prettify.css"/>

<script>
  $(function(){
    // google code prettifyの有効化
    $("pre").addClass("prettyprint");
    function init(event){
      prettyPrint();
    }
    if(window.addEventListener)window.addEventListener("load",init,false);
    else if(window.attachEvent)window.attachEvent("onload",init);
  });
</script>

<title>Mojolicious::Guides::Routing - ルーティングリクエスト - Mojoliciousドキュメント 日本語訳</title>
<meta name="description" content="このドキュメントはMojoliciousのルータ(router)のシンプルで楽しい入門と基本的なコンセプトを含んでいます。">
  </head>
  <body>
    <div class="container">
      <div class="header">
        <div class="header_main">
  <h1>
    <a href="/"><img src="/images/logo.png">Mojoliciousドキュメント日本語訳</a>
  </h1>
  <div class="header_right">
    <a rel="nofollow" href="https://perlclub.net/account/create">会員登録</a>
  </div>
</div>

      </div>
      <div class="main">
        <div class="content">
          <div class="entry">
  <div class="top">
    
  </div>
  <div class="middle">
    <!-- 

<p>このドキュメントはMojoliciousのルータ(router)のシンプルで楽しい入門と基本的なコンセプトを含んでいます。</p>
<div style="width:calc(100% - 30px);margin:10px auto;">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4525414114581084"
       crossorigin="anonymous"></script>
  <!-- 最初の段落下 - ディスプレイ 横長 レスポンシブ -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-4525414114581084"
       data-ad-slot="2828858335"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>

 -->
<html><head><title>名前</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.40,
  using Pod::Simple::PullParser v3.40,
  under Perl v5.032001 at Wed Sep 29 06:52:00 2021 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<h2><a href="/Mojolicious::Guides::Routing.html">Mojolicious::Guides::Routing - ルーティングリクエスト</a></h2>

<h3><a class='u'
name="_"
>説明</a></h3>

<p>このドキュメントはMojoliciousのルータ(router)のシンプルで楽しい入門と基本的なコンセプトを含んでいます。</p>

<h3><a class='u'
name="_"
>概念</a></h3>

<p>すべての<a href="/Mojolicious.html">Mojolicious</a>開発者が知るべき本質</p>

<h4><a class='u'
name="_"
>ディスパッチャ</a></h4>

<p>すべてのWebフレームワークの基盤は、受信したリクエストを適切なレスポンスを生成するコードを結びつける小さなブラックボックスです。</p>

<pre>GET /user/show/1 -&gt; $c-&gt;render(text =&gt; 'Daniel');</pre>

<p>このブラックボックスは普通ディスパッチャと呼ばれます。これらの接続を確立するため、いろいろな戦略を使う多くの実装がありますが、その大部分はリクエストのパスとある種のレスポンスジェネレータとの対応付けが基盤になっています。</p>

<pre>/user/show/2 -&gt; $c-&gt;render(text =&gt; 'Isabell');
/user/show/3 -&gt; $c-&gt;render(text =&gt; 'Sara');
/user/show/4 -&gt; $c-&gt;render(text =&gt; 'Stefan');
/user/show/5 -&gt; $c-&gt;render(text =&gt; 'Fynn');</pre>

<p>これらすべてのコネクションを静的なものにすることは可能ですが、かなり非効率になります。このため、ディスパッチ処理をより動的にするために正規表現がよく利用されるわけです。</p>

<pre>qr!/user/show/(\d+)! -&gt; $c-&gt;render(text =&gt; $users{$1});</pre>

<p>モダンなディスパッチャは、HTTPが持つ機能の大部を自前で用意していて、リクエストパスにくわえて<code>Host</code>, <code>User-Agent</code>, <code>Accept</code>といったその他さまざまな変数を利用できます。</p>

<pre>GET /user/show/23 HTTP/1.1
Host: mojolicious.org
User-Agent: Mojolicious (Perl)
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</pre>

<h4><a class='u'
name="(Routes)"
>ルーティング(Routes)</a></h4>

<p>正規表現はとても強力である一方、あまり読みやすいとは言えません。それに、一般的に通常のパスのマッチングにはオーバースペックなところがあります。</p>

<pre>qr!/user/show/(\d+)! -&gt; $c-&gt;render(text =&gt; $users{$1});</pre>

<p>ここでルーティングが役立ちます。これは、プレースホルダーを使ってパスを表すために一からデザインされています。</p>

<pre>/user/show/:id -&gt; $c-&gt;render(text =&gt; $users{$id});</pre>

<p>上記の例において、静的なパスとルーティングの違いは「:id」プレースホルダーだけです。一つ以上のプレースホルダーをルーティングの中のどこにでも置くことができます。</p>

<pre>/user/:action/:id</pre>

<p>Mojoliciousのルータの基本的コンセプトとして、抽出されたプレースホルダーの値はハッシュに変換されます。</p>

<pre>/user/show/23 -&gt; /user/:action/:id -&gt; {action =&gt; 'show', id =&gt; 23}</pre>

<p>このハッシュは、ほとんどの場合ですべてのMojoliciousアプリケーションの中心になります。これについては後で学びます。内部では、ルーティングは正規表現にコンパイルされます。少し経験すれば両方のやり方の良いところがわかるでしょう。</p>

<pre>/user/show/:id -&gt; qr/(?-xism:^\/user\/show\/([^\/.]+))/</pre>

<p>パスの末尾のスラッシュは任意です。</p>

<pre>/user/show/23/ -&gt; /user/:action/:id -&gt; {action =&gt; 'show', id =&gt; 23}</pre>

<h4><a class='u'
name="_"
>可逆性</a></h4>

<p>ルーティングが正規表現に対して優れている点のひとつは、ルーティングは簡単に元に戻すことができることです。抽出されたプレースホルダーはいつでもパスに戻すことができます。</p>

<pre>/sebastian -&gt; /:name -&gt; {name =&gt; 'sebastian'}
{name =&gt; 'sebastian'} -&gt; /:name -&gt; /sebastian</pre>

<p>たとえ空文字列であっても、すべてのプレースホルダーは名前を持ちます。</p>

<h4><a class='u'
name="_"
>標準プレースホルダー</a></h4>

<p>標準プレースホルダーは、もっとも簡単なプレースホルダーです。コロンをプレフィックスに取り、<code>/</code>と<code>.</code>を除くすべての文字にマッチします。正規表現の<code>([^/.]+)</code>に似ています。</p>

<pre>/hello              -&gt; /:name/hello -&gt; undef
/sebastian/23/hello -&gt; /:name/hello -&gt; undef
/sebastian.23/hello -&gt; /:name/hello -&gt; undef
/sebastian/hello    -&gt; /:name/hello -&gt; {name =&gt; 'sebastian'}
/sebastian23/hello  -&gt; /:name/hello -&gt; {name =&gt; 'sebastian23'}
/sebastian 23/hello -&gt; /:name/hello -&gt; {name =&gt; 'sebastian 23'}</pre>

<p>プレースホルダーは、<code><</code> と <code>></code> で囲むことによって周囲の文字列と区別できます。</p>

<pre>/hello             -&gt; /&lt;:name&gt;hello -&gt; undef
/sebastian/23hello -&gt; /&lt;:name&gt;hello -&gt; undef
/sebastian.23hello -&gt; /&lt;:name&gt;hello -&gt; undef
/sebastianhello    -&gt; /&lt;:name&gt;hello -&gt; {name =&gt; 'sebastian'}
/sebastian23hello  -&gt; /&lt;:name&gt;hello -&gt; {name =&gt; 'sebastian23'}
/sebastian 23hello -&gt; /&lt;:name&gt;hello -&gt; {name =&gt; 'sebastian 23'}</pre>

<p>コロンのプレフィックスは、<code><</code>と<code>></code>で囲まれた標準プレースホルダには付けても付けなくても構いません。</p>

<pre>/i♥mojolicious -&gt; /&lt;one&gt;♥&lt;two&gt; -&gt; {one =&gt; 'i', two =&gt; 'mojolicious'}</pre>

<h4><a class='u'
name="_"
>リラックスプレースホルダー</a></h4>

<p>リラックスプレースホルダーは、上記のふたつのプレースホルダーに似ていますが、<code>/</code>を除いたすべての文字にマッチする点が異なります。正規表現の<code>([^/]+)</code>に似ています。</p>

<pre>/hello              -&gt; /#name/hello -&gt; undef
/sebastian/23/hello -&gt; /#name/hello -&gt; undef
/sebastian.23/hello -&gt; /#name/hello -&gt; {name =&gt; 'sebastian.23'}
/sebastian/hello    -&gt; /#name/hello -&gt; {name =&gt; 'sebastian'}
/sebastian23/hello  -&gt; /#name/hello -&gt; {name =&gt; 'sebastian23'}
/sebastian 23/hello -&gt; /#name/hello -&gt; {name =&gt; 'sebastian 23'}</pre>

<p>とくに拡張子付きのファイル名を手動でマッチングさせるときに、フォーマット検知を使うよりも便利です。</p>

<pre>/music/song.mp3 -&gt; /music/#filename -&gt; {filename =&gt; 'song.mp3'}</pre>

<h4><a class='u'
name="_"
>ワイルドカードプレースホルダー</a></h4>

<p>ワイルドカードプレースホルダーは、先に紹介したふたつのプレースホルダーに似ていますが、 アスタリスクをプレフィックスに取り<code>/</code>と<code>.</code>を含むすべてにマッチします。正規表現の<code>(.+)</code>に似ています。</p>

<pre>/hello              -&gt; /*name/hello -&gt; undef
/sebastian/23/hello -&gt; /*name/hello -&gt; {name =&gt; 'sebastian/23'}
/sebastian.23/hello -&gt; /*name/hello -&gt; {name =&gt; 'sebastian.23'}
/sebastian/hello    -&gt; /*name/hello -&gt; {name =&gt; 'sebastian'}
/sebastian23/hello  -&gt; /*name/hello -&gt; {name =&gt; 'sebastian23'}
/sebastian 23/hello -&gt; /*name/hello -&gt; {name =&gt; 'sebastian 23'}</pre>

<p>ファイルパスの全体に手動でマッチさせたいときに便利です。</p>

<pre>/music/rock/song.mp3 -&gt; /music/*filepath -&gt; {filepath =&gt; 'rock/song.mp3'}</pre>

<h3><a class='u'
name="_"
>基礎</a></h3>

<p>すべてのMojolicious開発者が知っておくべきもっとも一般的に利用される機能</p>

<h4><a class='u'
name="_"
>最小限のルーティング</a></h4>

<p><a href="/Mojolicious.html">Mojolicious</a>の<code>routes</code>属性はルーティング構造を生成するために使用できるルーターを含みます。</p>

<pre># アプリケーション
package MyApp;
use Mojo::Base 'Mojolicious';

sub startup {
  my $self = shift;

  # ルーター
  my $r = $self-&gt;routes;

  # ルーティング
  $r-&gt;get('/welcome')-&gt;to(controller =&gt; 'foo', action =&gt; 'welcome');
}

1;</pre>

<p>上記の最小のルーティングでは、<code>MyApp::Controller::Foo</code>というクラスをロードし、そのインスタンスを生成して<code>welcome</code>メソッドを呼び出しています。ルーティングは普通はアプリケーションクラスの<code>startup</code>メソッドの中で設定されますが、すべての場所(たとえ実行中であっても)からアクセスできます。</p>

<pre># コントローラー
package MyApp::Controller::Foo;
use Mojo::Base 'Mojolicious::Controller';

# アクション
sub welcome {
  my $self = shift;

  # レスポンスの描画
  $self-&gt;render(text =&gt; 'Hello there.');
}

1;</pre>

<p>すべてのルーティングは、定義されたのと同じ順序でマッチし、適切なルーティングが見つかるとすぐにマッチングが停止します。そのため、最も頻繁にアクセスされるルーティングを最初に宣言することで、ルーティングのパフォーマンスを向上させることができます。突然のトラフィックの急増をより適切に処理するために、ルーティングキャッシュも自動的に使用されます。</p>

<h4><a class='u'
name="_"
>ルーティングの行き先</a></h4>

<p><a href="/Mojolicious::Routes::Route.html">Mojolicious::Routes::Route</a>の<code>get</code>メソッドで新しいルーティングを開始した後、 <a href="/Mojolicious::Routes::Route.html">Mojolicious::Routes::Route</a>の<code>to</code>メソッドをチェーンして、行き先をハッシュ形式で与えることができます。</p>

<pre># /welcome -&gt; {controller =&gt; 'foo', action =&gt; 'welcome'}
$r-&gt;get('/welcome')-&gt;to(controller =&gt; 'foo', action =&gt; 'welcome');</pre>

<p><a href="/Mojolicious::Routes::Route.html">Mojolicious::Routes::Route</a>の<code>route</code>メソッドで、受信したリクエストにルーティングがマッチすれば、 <a href="/Mojolicious::Routes::Route.html">Mojolicious::Routes::Route</a>の<code>to</code>メソッドを使ったハッシュの内容を使って レスポンスを生成するために適切なコードを見つけようとします。</p>

<h4><a class='u'
name="HTTP"
>HTTPメソッド</a></h4>

<p>よく使われるほとんどのHTTPリクエストメソッドにはショートカットがあらかじめ用意されていて、そのひとつに<a href="/Mojolicious::Routes::Route.html">Mojolicious::Routes::Route</a>の<code>post</code>があります。もっとコントロールしたい場合は、 <a href="/Mojolicious::Routes::Route.html">Mojolicious::Routes::Route</a>の<code>any</code>を使えば、第一引数に配列レファレンスを渡すことによって、任意のリクエストメソッドを指定できます。</p>

<pre># PUT /hello  -&gt; undef
# GET /hello  -&gt; {controller =&gt; 'foo', action =&gt; 'hello'}
$r-&gt;get('/hello')-&gt;to(controller =&gt; 'foo', action =&gt; 'hello');

# PUT /hello -&gt; {controller =&gt; 'foo', action =&gt; 'hello'}
$r-&gt;put('/hello')-&gt;to(controller =&gt; 'foo', action =&gt; 'hello');

# POST /hello -&gt; {controller =&gt; 'foo', action =&gt; 'hello'}
$r-&gt;post('/hello')-&gt;to(controller =&gt; 'foo', action =&gt; 'hello');

# GET|POST /bye  -&gt; {controller =&gt; 'foo', action =&gt; 'bye'}
$r-&gt;any(['GET', 'POST'] =&gt; '/bye')-&gt;to(controller =&gt; 'foo', action =&gt; 'bye');

# * /whatever -&gt; {controller =&gt; 'foo', action =&gt; 'whatever'}
$r-&gt;any('/whatever')-&gt;to(controller =&gt; 'foo', action =&gt; 'whatever');</pre>

<p>ひとつの小さな例外として、HEADリクエストはGETリクエストと同じものとみなされますが、 コンテンツはたとえ存在したとしてもレスポンスで送信されません。</p>

<pre># GET /test  -&gt; {controller =&gt; 'bar', action =&gt; 'test'}
# HEAD /test -&gt; {controller =&gt; 'bar', action =&gt; 'test'}
$r-&gt;get('/test')-&gt;to(controller =&gt; 'bar', action =&gt; 'test');</pre>

<p><code>_method</code>クエリパラメータを使用してリクエストメソッドをオーバーライドすることもできます。 <code>GET</code>と<code>POST</code>のみをサポートするブラウザでフォームを送信するとき、これは非常に役に立ちます。</p>

<pre># PUT  /stuff             -&gt; {controller =&gt; 'baz', action =&gt; 'stuff'}
# POST /stuff?_method=PUT -&gt; {controller =&gt; 'baz', action =&gt; 'stuff'}
$r-&gt;put('/stuff')-&gt;to(controller =&gt; 'baz', action =&gt; 'stuff');</pre>

<h4><a class='u'
name="IRIs"
>IRIs</a></h4>

<p>IRIsは透過的に扱うことができます。これは、パスがアンエスケープされ、Perlの文字にデコードされることが保証されるということです。</p>

<pre># /&#9731; (unicode snowman) -&gt; {controller =&gt; 'foo', action =&gt; 'snowman'}
$r-&gt;route('/&#9731;')-&gt;to(controller =&gt; 'foo', action =&gt; 'snowman');</pre>

<h4><a class='u'
name="_"
>スタッシュ</a></h4>

<p>生成されるマッチしたルーティングのハッシュは、実は<a href="/Mojolicious.html">Mojolicious</a>のリクエストサイクル全体の中心です。私たちはそれをスタッシュと呼び、これはレスポンスが生成されるまで存続します。</p>

<pre># /bye -&gt; {controller =&gt; 'foo', action =&gt; 'bye', mymessage =&gt; 'Bye'}
$r-&gt;get('/bye')
  -&gt;to(controller =&gt; 'foo', action =&gt; 'bye', mymessage =&gt; 'Bye');</pre>

<p><code>controller</code>や<code>action</code>などのスタッシュの値のいくつかは特別な意味を持ちますが、一般的にはレスポンスを生成するために必要なデータをなんでも入れることができます。いったんディスパッチされれば、スタッシュのすべての内容はいつでも変更できます。</p>

<pre>sub bye {
  my $self = shift;

  # スタッシュからメッセージを得る
  my $message = $self-&gt;stash('mymessage');

  # スタッシュのメッセージを変更
  $self-&gt;stash(mymessage =&gt; 'Welcome');
}</pre>

<p>すべての予約された値を見るには<a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>stash</code>を参考にしてください。</p>

<h4><a class='u'
name="_"
>ネストされたルーティング</a></h4>

<p>重複するコードを取り除くために、ルーティングから木構造を構築することも可能です。子を持つルーティングは自身にはマッチしません。それらのネストしたルーティング の実際のエンドポイントだけがマッチします。</p>

<pre># /foo     -&gt; undef
# /foo/bar -&gt; {controller =&gt; 'foo', action =&gt; 'bar'}
my $foo = $r-&gt;any('/foo')-&gt;to(controller =&gt; 'foo');
$foo-&gt;get('/bar')-&gt;to(action =&gt; 'bar');</pre>

<p>スタッシュは単にルーティングからルーティングに受け継がれ、古い値は新しい値でオーバーライドされます。</p>

<pre># /cats      -&gt; {controller =&gt; 'cats', action =&gt; 'index'}
# /cats/nyan -&gt; {controller =&gt; 'cats', action =&gt; 'nyan'}
# /cats/lol  -&gt; {controller =&gt; 'cats', action =&gt; 'default'}
my $cats = $r-&gt;any('/cats')-&gt;to(controller =&gt; 'cats', action =&gt; 'default');
$cats-&gt;get('/')-&gt;to(action =&gt; 'index');
$cats-&gt;get('/nyan')-&gt;to(action =&gt; 'nyan');
$cats-&gt;get('/lol');</pre>

<p>よく使うプレフィックスを設定することで、多くのルートを持つアプリケーションのルーティングパフォーマンスを大幅に向上させることができます。これは、プレフィックスが最初にマッチした場合にのみ子が試行されるためです。</p>

<h4><a class='u'
name="_"
>特別なスタッシュの値</a></h4>

<p>ディスパチャはスタッシュの中の<code>controller</code>と<code>action</code>の値を見るとき、いつでもそれらをディスパッチ先のクラスとメソッドに変換しようとします。<code>controller</code>の値は<a href="/Mojo::Util.html">Mojo::Util</a>の<code>camelize</code>によって<code>snake_case</code>から<code>CamelCase</code>に変換され、ひとつかそれ以上のネームスペースの後ろに追加されます。デフォルトで追加先となるのは、アプリケーションクラス（<code>MyApp::Controller</code>）に基づくコントローラーネームスペースと素のアプリケーションクラス（<code>MyApp</code>）です。これらのネームスペースが順番に検索されます。このため両方の値は大文字と小文字が区別されます。</p>

<pre># アプリケーション
package MyApp;
use Mojo::Base 'Mojolicious';

sub startup {
  my $self = shift;

  # /bye -&gt; MyApp::Controller::Foo-&gt;bye
  $self-&gt;routes-&gt;get('/bye')-&gt;to(controller =&gt; 'foo', action =&gt; 'bye');
}

1;

# コントローラー
package MyApp::Controller::Foo;
use Mojo::Base 'Mojolicious::Controller';

# アクション
sub bye {
  my $self = shift;

  # レスポンスの描画
  $self-&gt;render(text =&gt; 'Good bye.');
}

1;</pre>

<p>コントローラクラスは大きなプロジェクトでコードを体系化するのにぴったりです。たくさんのディスパッチ戦略がありますが、コントローラはもっとも一般的に使用されるものなので、<code>controller#action</code>という形式の専用ショートカットが用意されています。</p>

<pre># /bye -&gt; {controller =&gt; 'foo', action =&gt; 'bye', mymessage =&gt; 'Bye'}
$r-&gt;get('/bye')-&gt;to('foo#bye', mymessage =&gt; 'Bye');</pre>

<p><code>-</code>はキャメルケース化の際に<code>::</code>へ置き換えられます。これによって複数の階層を<code>controller</code>に持たせることができます。</p>

<pre># / -&gt; MyApp::Controller::Foo::Bar-&gt;hi
$r-&gt;get('/')-&gt;to('Foo::Bar#hi');</pre>

<p>スネークケースの代わりに、<code>controller</code>をキャメルケースで指定することもできます。</p>

<pre># / -&gt; MyApp::Controller::Foo::Bar-&gt;hi
$r-&gt;get('/')-&gt;to('Foo::Bar#hi');</pre>

<p>セキュリティ上の理由から、ディスパッチャは常に<code>controller</code>が本当に<a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>のサブクラスまたは<a href="/Mojo.html">Mojo</a>であるかどうかをディスパッチ前に調べます。</p>

<h4><a class='u'
name="_"
>名前空間</a></h4>

<p><code>namespace</code>スタッシュ値を使って、子ルーティングを含んだルーティング全体のネームスペースを変えることができます。</p>

<pre># /bye -&gt; MyApp::MyController::Foo::Bar-&gt;bye
$r-&gt;get('/bye')
  -&gt;to(namespace =&gt; 'MyApp::MyController::Foo::Bar', action =&gt; 'bye');</pre>

<p><code>controller</code>は、常に<code>snake_case</code>から<code>CamelCase</code>に<a href="/Mojo::Util.html">Mojo::Util</a>の<code>camelize</code>によって変換され、この<code>namespace</code>の後ろに追加されます。</p>

<pre># /bye -&gt; MyApp::MyController::Foo::Bar-&gt;bye
$r-&gt;get('/bye')-&gt;to('foo-bar#bye', namespace =&gt; 'MyApp::MyController');

# /hey -&gt; MyApp::MyController::Foo::Bar-&gt;hey
$r-&gt;get('/hey')-&gt;to('Foo::Bar#hey', namespace =&gt; 'MyApp::MyController');</pre>

<p>ルーター属性<a href="/Mojolicious::Routes.html">Mojolicious::Routes</a>の<code>namespaces</code>を使用して、アプリケーション内のすべてのルーティングは、デフォルトの名前空間を変更することもできます。通常、デフォルトはアプリケーションクラス（<code>MyApp::Controller</code>）および素のアプリケーションクラス（<code>MyApp</code>）に基づく名前空間になります。</p>

<pre>$r-&gt;namespaces(['MyApp::MyController']);</pre>

<h4><a class='u'
name="(cb)"
>コールバックへのルーティング(<code>cb</code>)</a></h4>

<p>コントローラをバイパスして、代わりにコールバックを実行するためにスタッシュの<code>cb</code>を使うことができます。</p>

<pre>$r-&gt;get('/bye')-&gt;to(cb =&gt; sub {
  my $c = shift;
  $c-&gt;render(text =&gt; 'Good bye.');
});</pre>

<p><a href="/Mojolicious::Lite.html">Mojolicious::Lite</a>と同じようにコールバックを直接渡すこともできます。通常、こちらの方が見た目が良くなります。</p>

<pre>$r-&gt;get('/bye' =&gt; sub {
  my $c = shift;
  $c-&gt;render(text =&gt; 'Good bye.');
});</pre>

<h4><a class='u'
name="_"
>名前つきルーティング</a></h4>

<p>ルーティングに名前をつければフレームワーク全体をとおして、多くのメソッドとヘルパー関数から逆引きできるようになります。ほとんどの場合、この機能は内部的に<a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>url_for</code>を頼りにしています。</p>

<pre># /foo/marcus -&gt; {controller =&gt; 'foo', action =&gt; 'bar', user =&gt; 'marcus'}
$r-&gt;get('/foo/:user')-&gt;to('foo#bar')-&gt;name('baz');

# URL "/foo/marcus" for route "baz" を生成
my $url = $c-&gt;url_for('baz');

# URL "/foo/jan" for route "baz" を生成
my $url = $c-&gt;url_for('baz', user =&gt; 'jan');

# URL "http://127.0.0.1:3000/foo/jan" for route "baz" を生成
my $url = $c-&gt;url_for('baz', user =&gt; 'jan')-&gt;to_abs;</pre>

<p><a href="/Mojolicious::Routes::Route.html">Mojolicious::Routes::Route</a>の<code>name</code>で名前をつけることができます。または、ルーターが自動的に名前を生成するようにします。これはノンワード文字を含まないルート自体と同じになりますが、カスタム名の方が優先されます。</p>

<pre># /foo/bar ("foobar")
$r-&gt;get('/foo/bar')-&gt;to('test#stuff');

# URL "/foo/bar"を生成
my $url = $c-&gt;url_for('foobar');</pre>

<p>現在のルーティングを参照するためには、予約語の<code>current</code>を使うか、名前の指定を省きます。</p>

<pre># Generate URL for current route
$self-&gt;url_for('current');
$self-&gt;url_for;</pre>

<p><a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>current_route</code>で 現在のルーティング名をチェックあるいは取得できます。</p>

<pre># 現在のルーティング名
my $name = $c-&gt;current_route;

# 複数のルーティングで共有されるコードにおいてルーティング名をチェック
$c-&gt;stash(button =&gt; 'green') if $c-&gt;current_route('login');</pre>

<h4><a class='u'
name="_"
>プレースホルダーのオプション</a></h4>

<p>抽出されたプレースホルダーの値は、古いスタッシュの値が存在していればそれを上書きします。</p>

<pre># /bye -&gt; {controller =&gt; 'foo', action =&gt; 'bar', mymessage =&gt; 'bye'}
# /hey -&gt; {controller =&gt; 'foo', action =&gt; 'bar', mymessage =&gt; 'hey'}
$r-&gt;get('/:mymessage')-&gt;to('foo#bar', mymessage =&gt; 'hi');</pre>

<p>さらにもうひとつの興味深い効果として、プレースホルダーは、同じ名前のスタッシュの値がすでに存在していれば、自動的にオプショナルになります。これは正規表現<code>([^/.]+)?</code>に似ています。</p>

<pre># / -&gt; {controller =&gt; 'foo', action =&gt; 'bar', mymessage =&gt; 'hi'}
$r-&gt;get('/:mymessage')-&gt;to('foo#bar', mymessage =&gt; 'hi');

# /test/123     -&gt; {controller =&gt; 'foo', action =&gt; 'bar', mymessage =&gt; 'hi'}
# /test/bye/123 -&gt; {controller =&gt; 'foo', action =&gt; 'bar', mymessage =&gt; 'bye'}
$r-&gt;get('/test/:mymessage/123')-&gt;to('foo#bar', mymessage =&gt; 'hi');</pre>

<p>ふたつのオプショナルなプレースホルダーが、スラッシュによって分割されている場合だけ、 スラッシュはオプショナルなものになります。</p>

<pre># /           -&gt; {controller =&gt; 'foo',   action =&gt; 'bar'}
# /users      -&gt; {controller =&gt; 'users', action =&gt; 'bar'}
# /users/list -&gt; {controller =&gt; 'users', action =&gt; 'list'}
$r-&gt;get('/:controller/:action')-&gt;to('foo#bar');</pre>

<p><code>controller</code>や<code>action</code>などの特別なスタッシュの値もまたプレースホルダーとなりえます。これによってきわめて柔軟なルーティングの構築が可能になります。これは開発の間は特にとても便利ですが、すべてのコントローラーメソッドがルーティングになる可能性があるので、注意深く利用すべきです。アンダースコアで始まるこれらのメソッドと同じように、すべての大文字のメソッドは自動的にルーターから隠されます。隠す対象を追加するためには<a href="/Mojolicious::Routes.html">Mojolicious::Routes</a>の<code>hide</code>を使うこともできます。</p>

<pre># すべてのコントローラーでC&lt;create&gt;メソッドを隠す
$r-&gt;hide('create');</pre>

<p><a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>のすべての属性とメソッドでは、これがすでに行われています。</p>

<h4><a class='u'
name="_"
>制約的なプレースホルダー</a></h4>

<p>プレースホルダーにより多くの制約を加えるには、選択リストを使うのが簡単です。候補となる値のリストを作るだけでOKです。これは正規表現<code>(bender|leela)</code>に似ています。</p>

<pre># /fry    -&gt; undef
# /bender -&gt; {controller =&gt; 'foo', action =&gt; 'bar', name =&gt; 'bender'}
# /leela  -&gt; {controller =&gt; 'foo', action =&gt; 'bar', name =&gt; 'leela'}
$r-&gt;get('/:name' =&gt; [name =&gt; ['bender', 'leela']])-&gt;to('foo#bar');</pre>

<p>必要であればプレースホルダーの正規表現を調節できます。ただし、<code>^</code>と<code>$</code>を使うことや、グループ<code>(...)</code>のキャプチャは避けてください。これは、プレースホルダーが内部の大きな正規表現の一部だからです。けれどもキャプチャしない<code>(?:...)</code>は使っても大丈夫です。</p>

<pre># /23   -&gt; {controller =&gt; 'foo', action =&gt; 'bar', number =&gt; 23}
# /test -&gt; undef
$r-&gt;get('/:number' =&gt; [number =&gt; qr/\d+/])-&gt;to('foo#bar');

# /23   -&gt; undef
# /test -&gt; {controller =&gt; 'foo', action =&gt; 'bar', name =&gt; 'test'}
$r-&gt;get('/:name' =&gt; [name =&gt; qr/[a-zA-Z]+/])-&gt;to('foo#bar');</pre>

<p>このようにして読みやすいルーティングと正規表現の素の力を簡単に得ることができます。</p>

<h4><a class='u'
name="_"
>プレースホルダーの種類</a></h4>

<p>また、制限的なプレースホルダを使用するルーティングが複数ある場合は、それらを<a href="/Mojolicious::Routes.html">Mojolicious::Routes</a>の<code>add_type</code>でプレースホルダ型に変えることもできます。</p>

<pre># リストを使った型
$r-&gt;add_type(futurama_name =&gt; ['bender', 'leela']);

# /fry    -&gt; undef
# /bender -&gt; {controller =&gt; 'foo', action =&gt; 'bar', name =&gt; 'bender'}
# /leela  -&gt; {controller =&gt; 'foo', action =&gt; 'bar', name =&gt; 'leela'}
$r-&gt;get('/&lt;name:futurama_name&gt;')-&gt;to('foo#bar');</pre>

<p>プレースホルダ型は制限的なプレースホルダと同じように機能します。それらは<code><プレースホルダー:type></code>表記で再利用できます。</p>

<pre>＃ 正規表現を適応させる型
$r-&gt;add_type(upper =&gt; qr/[A-Z]+/);

# /user/ROOT -&gt; {controller =&gt; 'users', action =&gt; 'show', name =&gt; 'ROOT'}
# /user/root -&gt; undef
# /user/23   -&gt; undef
$r-&gt;get('/user/&lt;name:upper&gt;')-&gt;to('users#show');</pre>

<p><code>num</code>のようないくつかの型は非常に一般的に使われているので、デフォルトで利用可能です。</p>

<pre># /article/12   -&gt; {controller =&gt; 'article', action =&gt; 'show', id =&gt; 12}
# /article/test -&gt; undef
$r-&gt;get('/article/&lt;id:num&gt;')-&gt;to('articles#show');</pre>

<p>利用可能なプレースホルダタイプの全リストについては<a href="/Mojolicious::Routes.html">Mojolicious::Routes</a>の<code>TYPES</code>も見てください 。</p>

<h4><a class='u'
name="_"
>内観</a></h4>

<p>利用可能なすべてルーティングを名前と背後の正規表現と一緒に列挙するには、コマンドラインから<a href="/Mojolicious::Command::routes.html">Mojolicious::Command::routes</a>のコマンドが利用できます。</p>

<pre>$ ./myapp.pl routes -v
/foo/:name  ....  POST  fooname  ^/foo/([^/.]+)/?(?:\.([^/]+))?$
/bar        ..U.  *     bar      ^/bar
  +/baz     ...W  GET   baz      ^/baz(?:\.([^/]+)$)?
/yada       ....  *     yada     ^/yada(?:\.([^/]+)$)?</pre>

<h4><a class='u'
name="_(Under)"
>アンダー (Under)</a></h4>

<p>複数階層にネストしたルーティングのコードを共有するには、<a href="/Mojolicious::Routes::Route.html">Mojolicious::Routes::Route</a>の<code>under</code>メソッドが利用できます。通常のネストしたルーティングとは異なり、この方法で生成されたルーティングはそれぞれが中間目的地を持ち、マッチしたときに追加のディスパッチサイクルが開始します。</p>

<pre># /foo     -&gt; undef
# /foo/bar -&gt; {controller =&gt; 'foo', action =&gt; 'baz'}
#             {controller =&gt; 'foo', action =&gt; 'bar'}
my $foo = $r-&gt;under('/foo')-&gt;to('foo#baz');
$foo-&gt;get('/bar')-&gt;to('#bar');実際のブリッジのコードは真の値を返す必要があります。</pre>

<p>ブリッジのコードは真の値を返す必要があります。そうでなければ、ディスパッチのチェーンは壊れます。このためにブリッジは認証のためのとても強力なツールになっています。</p>

<pre># /blackjack -&gt; {cb =&gt; sub {...}}
#               {controller =&gt; 'hideout', action =&gt; 'blackjack'}
my $auth = $r-&gt;under('/' =&gt; sub {
  my $c = shift;

  # 認証済み
  return 1 if $c-&gt;req-&gt;headers-&gt;header('X-Bender');

  # 未認証
  $c-&gt;render(text =&gt; "You're not Bender.", status =&gt; 401);
  return undef;
});
$auth-&gt;get('/blackjack')-&gt;to('hideout#blackjack');</pre>

<p>壊れたディスパッチチェーンは <a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>continue</code>メソッドを呼び出すことによって続けることができます。これによって、たとえば、ノンブロッキング処理を次のディスパッチサイクルに到達する前に終了させることができます。</p>

<pre>my $maybe = $r-&gt;under('/maybe' =&gt; sub {
  my $c = shift;

  # 3秒まって、50%の確率で継続する
  Mojo::IOLoop-&gt;timer(3 =&gt; sub {

    # 負け
    return $c-&gt;render(text =&gt; 'No luck.') unless int rand 2;

    # 勝ち
    $c-&gt;continue;
  });

  return undef;
});
$maybe-&gt;get('/')-&gt;to('maybe#winner');</pre>

<p>フォーマットルーティングの末尾にある<code>.html</code>や<code>.txt</code>などのファイルの拡張子は自動的に検知されスタッシュの<code>format</code>に保存されます。もう少し強力にするには、<a href="https://metacpan.org/pod/Mojolicious%3A%3AController" class="podlinkpod"
>Mojolicious::Controller</a>の<code>match</code> で前後の目的地を詳しく調べてください。</p>

<pre># 4回目のディスパッチサイクルのアクション
my $action = $c-&gt;match-&gt;stack-&gt;[3]{action};</pre>

<h4><a class='u'
name="_"
>フォーマット</a></h4>

<p>ルートの終わりにある<code>.html</code>や<code>.txt</code>のようなファイル拡張子は自動的に検出され、<code>format</code>スタッシュ値に格納されます。</p>

<pre># /foo      -&gt; {controller =&gt; 'foo', action =&gt; 'bar'}
# /foo.html -&gt; {controller =&gt; 'foo', action =&gt; 'bar', format =&gt; 'html'}
# /foo.txt  -&gt; {controller =&gt; 'foo', action =&gt; 'bar', format =&gt; 'txt'}
$r-&gt;get('/foo')-&gt;to('foo#bar');</pre>

<p>これにより、たとえば、異なるフォーマットの複数のテンプレートが同じアクションコードを共有できます。制限付きプレースホルダを使用して、許可されるフォーマットを制限することもできます。</p>

<pre># /foo.txt -&gt; undef
# /foo.rss -&gt; {controller =&gt; 'foo', action =&gt; 'bar', format =&gt; 'rss'}
# /foo.xml -&gt; {controller =&gt; 'foo', action =&gt; 'bar', format =&gt; 'xml'}
$r-&gt;get('/foo' =&gt; [format =&gt; ['rss', 'xml']])-&gt;to('foo#bar');</pre>

<p><code>format</code>値は<a href="https://metacpan.org/pod/Mojolicious%3A%3AController" class="podlinkpod"
>Mojolicious::Controller</a>の<code>url_for</code> にも渡すことができます。</p>

<pre># /foo/bar.txt -&gt; {controller =&gt; 'foo', action =&gt; 'bar', format =&gt; 'txt'}
$r-&gt;get('/foo/:action')-&gt;to('foo#')-&gt;name('baz');

# Generate URL "/foo/bar.txt" for route "baz"
my $url = $c-&gt;url_for('baz', action =&gt; 'bar', format =&gt; 'txt');</pre>

<p>あるいは、ネストしたルートによって継承される特別な種類の制限的なプレースホルダを使用してフォーマット検出を無効にしてから、必要に応じて再度有効にすることもできます。</p>

<pre># /foo      -&gt; {controller =&gt; 'foo', action =&gt; 'bar'}
# /foo.html -&gt; undef
$r-&gt;get('/foo' =&gt; [format =&gt; 0])-&gt;to('foo#bar');

# /foo      -&gt; {controller =&gt; 'foo', action =&gt; 'bar'}
# /foo.html -&gt; undef
# /foo.html -&gt; undef
# /baz      -&gt; undef
# /baz.html -&gt; {controller =&gt; 'baz', action =&gt; 'yada', format =&gt; 'html'}
# /baz.xml  -&gt; undef
my $inactive = $r-&gt;under([format =&gt; 0]);
$inactive-&gt;get('/foo')-&gt;to('foo#bar');
$inactive-&gt;get('/baz' =&gt; [format =&gt; ['txt', 'html']])-&gt;to('baz#yada');</pre>

<h4><a class='u'
name="WebSocket"
>WebSocket</a></h4>

<p><a href="/Mojolicious::Routes::Route.html">Mojolicious::Routes::Route</a>の<code>websocket</code>メソッドを使ってWebSocketハンドシェイクへのアクセスを制限できます。WebSocketハンドシェイクとは、普通のGETリクエストに追加の情報がついたものです。</p>

<pre># /echo (WebSocket handshake)
$r-&gt;websocket('/echo')-&gt;to('foo#echo');

# コントローラー
package MyApp::Controller::Foo;
use Mojo::Base 'Mojolicious::Controller';

# アクション
sub echo {
  my $self = shift;
  $self-&gt;on(message =&gt; sub {
    my ($self, $message) = @_;
    $self-&gt;send("echo: $message");
  });
}

1;</pre>

<p>WebSocketハンドシェイクリクエストに、<code>101</code>レスポンスで応答したときに、コネクションは確立されます。このレスポンスは、<a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>on</code>でイベントを定期受信したとき、また<a href="/Mojolicious::Controller.html">Mojolicious::Controller</a> の<code>send</code>でメッセージを送ったときに、自動的に発生します。</p>

<pre>GET /echo HTTP/1.1
Host: mojolicious.org
User-Agent: Mojolicious (Perl)
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Key: IDM3ODE4NDk2MjA1OTcxOQ==
Sec-WebSocket-Version: 13

HTTP/1.1 101 Switching Protocols
Server: Mojolicious (Perl)
Date: Tue, 03 Feb 2015 17:08:24 GMT
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: SWsp5N2iNxPbHlcOTIw8ERvyVPY=</pre>

<h4><a class='u'
name="_"
>キャッチオールルート</a></h4>

<p>定義された順番でルートはマッチするので、 オプショナルなワイルドカードプレースホルダーによって、 最後のルートにおいてマッチしなかった すべてのリクエストをキャッチできます。</p>

<pre># * /*
$r-&gt;any('/*whatever' =&gt; {whatever =&gt; ''} =&gt; sub {
  my $c        = shift;
  my $whatever = $c-&gt;param('whatever');
  $c-&gt;render(text =&gt; "/$whatever did not match.", status =&gt; 404);
});</pre>

<h4><a class='u'
name="_"
>条件</a></h4>

<p><a href="https://metacpan.org/pod/Mojolicious%3A%3APlugin%3A%3AHeaderCondition" class="podlinkpod"
>Mojolicious::Plugin::HeaderCondition</a>の<code>headers</code>、<code>agent</code>、<code>host</code>メソッドなどは、<a href="https://metacpan.org/pod/Mojolicious%3A%3ARoutes%3A%3ARoute" class="podlinkpod"
>Mojolicious::Routes::Route</a>の<code>over</code>メソッドを使って任意のルーティングに適用できます。これによって、さらに強力なルートを構成できるようになります。</p>

<pre># / (Origin: http://perl.org)
$r-&gt;get('/')-&gt;over(headers =&gt; {Origin =&gt; qr/perl\.org/})-&gt;to('foo#bar');

# / (Firefox)
$r-&gt;get('/')-&gt;over(agent =&gt; qr/Firefox/)-&gt;to('browser-test#firefox');

# / (Internet Explorer)
$r-&gt;get('/')-&gt;over(agent =&gt; qr/Internet Explorer/)-&gt;to('browser-test#ie');

# http://mojolicious.org/perldoc
$r-&gt;get('/perldoc')-&gt;over(host =&gt; 'mojolicious.org')-&gt;to('perldoc#index');</pre>

<p>ルーティングキャッシュは通常、繰り返しのリクエストを高速化しますが、条件は複雑すぎるため、パフォーマンスが低下する可能性があります。</p>

<h4><a class='u'
name="_"
>フック</a></h4>

<p>フックはルーティングシステムの外側で実行され、 <a href="/Mojolicious.html">Mojolicious</a>の<code>hook</code>を使って、 すべてのリクエストでコードを共有することによって フレームワーク自体を拡張することを可能にします。これはプラグインのためのとても強力なツールです。</p>

<pre># アプリケーション
package MyApp;
use Mojo::Base 'Mojolicious';

sub startup {
  my $self = shift;

  # "/test"プレフィックスを含んでいるすべてのリクエストをチェック
  $self-&gt;hook(before_dispatch =&gt; sub {
    my $c = shift;
    $c-&gt;render(text =&gt; 'This request did not reach the router.')
      if $c-&gt;req-&gt;url-&gt;path-&gt;contains('/test');
  });

  # 上のフックがレスポンスを描画すれば、ここには到達しない。
  my $r = $self-&gt;routes;
  $r-&gt;get('/welcome')-&gt;to('foo#welcome');
  $r-&gt;post('/bye')-&gt;to('foo#bye');
}

1;</pre>

<p>追加のレスポンスヘッダを設定するような後処理の仕事などは一般的な使用方法でしょう。</p>

<pre># 静的ファイルがキャッシュされるようにする
$app-&gt;hook(after_static =&gt; sub {
  my $c = shift;
  $c-&gt;res-&gt;headers-&gt;cache_control('max-age=3600, must-revalidate');
});

# デフォルトヘッダを削除
$self-&gt;hook(after_dispatch =&gt; sub {
  my $c = shift;
  $c-&gt;res-&gt;headers-&gt;remove('Server');
});</pre>

<p>リクエストの前処理において同じことをする。</p>

<pre># リクエストヘッダーに基づいてテンプレートバリアントを選択
$app-&gt;hook(before_dispatch =&gt; sub {
  my $c = shift;
  return unless my $agent = $c-&gt;req-&gt;headers-&gt;user_agent;
  $c-&gt;stash(variant =&gt; 'ie') if $agent =~ /Internet Explorer/;
});</pre>

<p>モニタリングをアプリケーションに加える発展的な拡張</p>

<pre># Webサービスに例外を通知する
$self-&gt;hook(after_dispatch =&gt; sub {
  my $c = shift;
  return unless my $e = $c-&gt;stash('exception');
  $c-&gt;ua-&gt;post('https://example.com/bugs' =&gt; form =&gt; {exception =&gt; $e});
});</pre>

<p>コアの機能の多くを拡張することも可能です。</p>

<pre># コントローラーオブジェクトをアクションの中で$_で利用できるようにする
$app-&gt;hook(around_action =&gt; sub {
  my ($next, $c, $action, $last) = @_;
  local $_ = $c;
  return $next-&gt;();
});

# ルーティング名をアクションへの引数として渡す
$app-&gt;hook(around_action =&gt; sub {
  my ($next, $c, $action, $last) = @_;
  return $c-&gt;$action($c-&gt;current_route);
});</pre>

<p>すべてのフックの一覧は <a href="/Mojolicious.html">Mojolicious</a>の<code>HOOKS</code>を見てください。</p>

<h3><a class='u'
name="_"
>発展</a></h3>

<p>一般的ではないが、より強力な機能</p>

<h4><a class='u'
name="_"
>ショートカット</a></h4>

<p>ルート生成の表現力を高めるためには<a href="/Mojolicious::Routes.html">Mojolicious::Routes</a>の<code>add_shortcut</code>を使って独自のショートカットを加えることができます。</p>

<pre># 簡単な"resource"ショートカット
$r-&gt;add_shortcut(resource =&gt; sub {
  my ($r, $name) = @_;

  # リソースのプレフィックス
  my $resource = $r-&gt;any("/$name")-&gt;to("$name#");

  # リソースのリストの描画
  $resource-&gt;get-&gt;to('#index')-&gt;name($name);

  # 新しいリソースを作成するために、フォームを描画する("store"へのサブミット)
  $resource-&gt;get('/create')-&gt;to('#create')-&gt;name("create_$name");

  # 新しく作成したリソースを保存する ("create"によってサブミット)
  $resource-&gt;post-&gt;to('#store')-&gt;name("store_$name");

  # 特別なリソースを描画する
  $resource-&gt;get('/:id')-&gt;to('#show')-&gt;name("show_$name");

  # リソースを編集するためにフォームを描画する ("update"へのサブミット)
  $resource-&gt;get('/:id/edit')-&gt;to('#edit')-&gt;name("edit_$name");

  # リソースをアップデートする("edit"によってサブミット)
  $resource-&gt;put('/:id')-&gt;to('#update')-&gt;name("update_$name");

  # リソースを削除する
  $resource-&gt;delete('/:id')-&gt;to('#remove')-&gt;name("remove_$name");

  return $resource;
});

# GET /users         -&gt; {controller =&gt; 'users', action =&gt; 'index'}
# GET /users/create  -&gt; {controller =&gt; 'users', action =&gt; 'create'}
# POST /users        -&gt; {controller =&gt; 'users', action =&gt; 'store'}
# GET /users/23      -&gt; {controller =&gt; 'users', action =&gt; 'show', id =&gt; 23}
# GET /users/23/edit -&gt; {controller =&gt; 'users', action =&gt; 'edit', id =&gt; 23}
# PUT /users/23      -&gt; {controller =&gt; 'users', action =&gt; 'update', id =&gt; 23}
# DELETE /users/23   -&gt; {controller =&gt; 'users', action =&gt; 'remove', id =&gt; 23}
$r-&gt;resource('users');</pre>

<h4><a class='u'
name="_"
>ルーティングのリアレンジ</a></h4>

<p>アプリケーションが立ち上げってから最初のリクエストが処理されるまでは、すべてのルーティングは、 <a href="/Mojolicious::Routes::Route.html">Mojolicious::Routes::Route</a>の<code>add_child</code>や <a href="/Mojolicious::Routes::Route.html">Mojolicious::Routes::Route</a>の<code>remove</code>などによって 移動させたり、削除できます。</p>

<pre># GET /example/show -&gt; {controller =&gt; 'example', action =&gt; 'show'}
my $show = $r-&gt;get('/show')-&gt;to('example#show');
$r-&gt;any('/example')-&gt;add_child($show);

# なし
$r-&gt;get('/secrets/show')-&gt;to('secrets#show')-&gt;name('show_secrets');
$r-&gt;find('show_secrets')-&gt;remove;</pre>

<p>特にプラグインによって生成されたルーティングを再構成するためにとても便利でしょう。 <a href="/Mojolicious::Routes::Route.html">Mojolicious::Routes::Route</a>の<code>find</code>を使って名前によってルーティングを探すことができます。</p>

<pre># GET /example/test -&gt; {controller =&gt; 'example', action =&gt; 'test'}
$r-&gt;get('/something/else')-&gt;to('something#else')-&gt;name('test');
my $test = $r-&gt;find('test');
$test-&gt;pattern-&gt;parse('/example/test');
$test-&gt;pattern-&gt;defaults({controller =&gt; 'example', action =&gt; 'test'});</pre>

<p>さらにルーティングパターンと目的地は、<a href="/Mojolicious::Routes::Pattern.html">Mojolicious::Routes::Pattern</a>の<code>parse</code>や <a href="/Mojolicious::Routes::Pattern.html">Mojolicious::Routes::Pattern</a>の<code>defaults</code>を使ってまだ変更できます。</p>

<h4><a class='u'
name="_"
>条件の追加</a></h4>

<p>独自の条件を<a href="/Mojolicious::Routes.html">Mojolicious::Routes</a>の<code>add_condition</code>を使って追加できます。すべての条件は基本的には、新しいリクエストが到着するたびに実行されるルータープラグインです。条件は、 ルーティングとマッチしたときに真を返す必要があります。</p>

<pre># ランダムでルーティングにマッチする条件
$r-&gt;add_condition(random =&gt; sub {
  my ($route, $c, $captures, $num) = @_;

  # 負け
  return undef if int rand $num;

  # 勝ち
  return 1;
});

# /maybe（25% の確率）
$r-&gt;get('/maybe')-&gt;over(random =&gt; 4)-&gt;to('foo#bar');</pre>

<p>必要なリクエスト情報を使う</p>

<pre># クエリパラメーターをチェックする条件（モックウェブサービスに便利）
$r-&gt;add_condition(query =&gt; sub {
  my ($route, $c, $captures, $hash) = @_;

  for my $key (keys %$hash) {
    my $param = $c-&gt;req-&gt;url-&gt;query-&gt;param($key);
    return undef unless defined $param && $param eq $hash-&gt;{$key};
  }

  return 1;
});

# /hello?to=world&test=1
$r-&gt;get('/hello')-&gt;over(query =&gt; {test =&gt; 1, to =&gt; 'world'})-&gt;to('foo#bar');</pre>

<h4><a class='u'
name="_"
>条件プラグイン</a></h4>

<p>再利用可能なプラグインとして条件をパッケージ化できます。</p>

<pre># プラグイン
package Mojolicious::Plugin::WerewolfCondition;
use Mojo::Base 'Mojolicious::Plugin';

use Astro::MoonPhase;

sub register {
  my ($self, $app) = @_;

  # “おおかみ男（werewolf）”条件を追加
  $app-&gt;routes-&gt;add_condition(werewolf =&gt; sub {
    my ($r, $c, $captures, $days) = @_;

    # おおかみ男を入れるな！
    return if abs(14 - (phase(time))[2]) &gt; ($days / 2);

    # 大丈夫だ、おおかみ男ではない
    return 1;
  });
}

1;</pre>

<p>プラグインをロードして、すべてのアプリケーションで条件を使うことができます。</p>

<pre># アプリケーション
package MyApp;
use Mojo::Base 'Mojolicious';

sub startup {
  my $self = shift;

  # プラグイン
  $self-&gt;plugin('WerewolfCondition');

  # /hideout（満月から4日間は中に入れない）
  $self-&gt;routes-&gt;get('/hideout')-&gt;over(werewolf =&gt; 4)
    -&gt;to(controller =&gt; 'foo', action =&gt; 'bar');
}

1;</pre>

<h4><a class='u'
name="_"
>アプリケーションのマウント</a></h4>

<p>完全な自分を含んだアプリケーションをあるドメインあるいはプレフィックス(もしくは両方)の下にマウントするのに、<a href="/Mojolicious::Plugin::Mount.html">Mojolicious::Plugin::Mount</a>を利用できます。</p>

<pre>use Mojolicious::Lite;

# C&lt;/prefix&gt;の下に完全なアプリケーションをマウント
plugin Mount =&gt; {'/prefix' =&gt; '/home/sri/myapp.pl'};

# サブドメインでアプリケーションをマウント
plugin Mount =&gt; {'test.example.com' =&gt; '/home/sri/myapp2.pl'};

# 普通のルート
get '/' =&gt; sub { shift-&gt;render_text('Hello World!') };

app-&gt;start;</pre>

<h4><a class='u'
name="_"
>埋め込みアプリケーション</a></h4>

<p>コントローラの代わりに、アプリケーション全体を簡単に埋め込むことができます。これによって、たとえば、<a href="/Mojolicious.html">Mojolicious</a>のコントローラの中で、<a href="/Mojolicious::Lite.html">Mojolicious::Lite</a>のドメイン固有言語を使用できるようになります。</p>

<pre># コントローラー
package MyApp::Controller::Bar;
use Mojolicious::Lite;

# /hello
# "hello.html.ep"というテンプレートを描画
  my $c    = shift;
  my $name = $c-&gt;param('name') || '';
  $c-&gt;render(text =&gt; "Hello $name.");
};

1;</pre>

<p><a href="/Mojolicious::Routes::Route.html">Mojolicious::Routes::Route</a>の<code>to</code>にとてもよく似ている<a href="/Mojolicious::Routes::Route.html">Mojolicious::Routes::Route</a>の<code>detour</code>を使えば、 埋め込みのアプリケーションの中で、ルーティングを部分的にマッチさせ、残ったパスだけを使用できます。ベースパスは<code>path</code>スタッシュ値として引き渡されます。</p>

<pre># /foo/*
$r-&gt;any('/foo')-&gt;detour('bar#', name =&gt; 'Mojo');</pre>

<p>最小の埋め込みアプリケーションは、<a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>オブジェクトを受け入れるための<code>handler</code>メソッドを持つ、ただの<a href="/Mojo.html">Mojo</a>のサブクラスです。</p>

<pre>package MyApp::Controller::Bar;
use Mojo::Base 'Mojolicious';

sub handler {
  my ($self, $c) = @_;
  $c-&gt;res-&gt;code(200);
  my $name = $c-&gt;param('name') || '';
  $c-&gt;res-&gt;body("Hello $name.");
}

1;</pre>

<p>ホストアプリケーションはスタッシュを通して組み込みアプリケーションとほとんど情報を共有しません。そのため、<a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>url_for</code>で問題が発生する可能性があるため、現在組み込みアプリケーションに至るルーティングにおいてルーティングプレースホルダーを使用することはできません。</p>

<h4><a class='u'
name="_"
>アプリケーションプラグイン</a></h4>

<p>再利用可能なプラグインとしてアプリケーションをパッケージ化することだってできます。</p>

<pre># プラグイン
package Mojolicious::Plugin::MyEmbeddedApp;
use Mojo::Base 'Mojolicious::Plugin';

sub register {
  my ($self, $app) = @_;

  # ルートを自動的に追加
  $app-&gt;routes-&gt;any('/foo')-&gt;detour(app =&gt; EmbeddedApp::app());
}

package EmbeddedApp;
use Mojolicious::Lite;

get '/bar' =&gt; 'bar';

1;
__DATA__;
@@ bar.html.ep
Hello World!</pre>

<p>スタッシュの<code>app</code>の値は、すでにインスタンス化されたアプリケーションで利用できます。単にプラグインをロードするだけです。</p>

<pre># アプリケーション
package MyApp;
use Mojo::Base 'Mojolicious';

sub startup {
  my $self = shift;

  # プラグイン
  $self-&gt;plugin('MyEmbeddedApp');
}

1;</pre>

<h3><a class='u'
name="_"
>より学ぶには</a></h3>

<p>さあ、<a href="/Mojolicious::Guides.html">Mojolicious::Guides</a> を続けるか、<a href="http://github.com/mojolicious/mojo/wiki">Mojolicious wiki</a>を見てみましょう。多くの著者がドキュメントやサンプルをたくさん書いています。</p>

<h3><a class='u'
name="_"
>サポート</a></h3>

<p>このドキュメントでわからない部分があれば、 <a href="http://groups.google.com/group/mojolicious">mailing list</a> か<code>irc.freenode.net</code> (<a href="https://kiwiirc.com/nextclient/#irc://irc.freenode.net/mojo?nick=guest-?" class="podlinkurl"
>chat now!</a>)の公式IRCチャンネル <code>#mojo</code> まで気軽に質問してください。</p>

<p>（2019/04/06 Mojoliciuos 8.12を反映）</p>

<!-- end doc -->

</body></html>

  </div>
  <div class="bottom">
    <div class="perlclub_register">
  <a rel="nofollow" href="https://perlclub.net/account/create">Perlクラブへの<br>無料の会員登録で<br>書籍サンプルプレゼント</a>
</div>

  </div>
</div>

        </div>
        <div class="side">
          <div class="side_list">
  <div class="side_list_title">
    Perlテキスト処理のエッセンス
  </div>
  <div class="side_list_body">
    <ul>
      <li>
        <div class="side_list_image">
          <a rel="nofollow" href="https://www.amazon.co.jp/gp/product/B097T6CBR6/ref=as_li_tl?ie=UTF8&tag=perlgenki-22&camp=247&creative=1211&linkCode=as2&creativeASIN=B097T6CBR6&linkId=e9078757396f4ceb239e325242bb830a"><img src="https://perlclub.net/images/book/perl_text_essence/perl_text_essence.jpg"></a>
        </div>
        <div class="side_list_description">
          <div >初級者向け・テキスト処理と正規表現の基本をマスター</div>
        </div>
      </li>
    </ul>
  </div>
</div>

<div class="side_list">
  <div class="side_list_title">
    業務に役立つPerl
  </div>
  <div class="side_list_body">
    <ul>
      <li>
        <div class="side_list_image">
          <a  rel="nofollow" href="https://www.amazon.co.jp/gp/product/4774150258/ref=as_li_tl?ie=UTF8&tag=perlgenki-22&camp=247&creative=1211&linkCode=as2&creativeASIN=4774150258&linkId=45a02b2a4b32fce3dcee590267c7cd9a"><img src="https://perlclub.net/images/book/perl_gyoumu/perl_gyoumu.jpg"></a>
        </div>
        <div class="side_list_description">
          実務者向け・ログ解析など日本語を含むテキスト処理の実践!
        </div>
      </li>
    </ul>
  </div>
</div>

<div class="side_list">
  <div class="side_list_title">
    Perlクラブ
  </div>
  <div class="side_list_body">
    <ul>
      <li>
        <div class="side_list_image">
          <a rel="nofollow" href="https://perlclub.net/"><img style="width:130px" src="https://perlclub.net/images/perl_club_logo.png"></a>
        </div>
        <div class="side_list_description">
          仲間と出会い<br>ゆとりあるエンジニアライフを送る
        </div>
      </li>
    </ul>
  </div>
</div>

        </div>
      </div>
      <div class="footer">
        <div class="perlri_link">
  <a rel="nofollow" href="https://perlclub.net">Perlクラブ</a>
</div>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4525414114581084"
     crossorigin="anonymous"></script>
     
      </div>
    </div>
  </body>
</html>
