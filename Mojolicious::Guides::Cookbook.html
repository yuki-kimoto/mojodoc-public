<!DOCTYPE html>
<html>
  <head>
    <!-- meta -->
<!-- Google Automatic Advertising -->
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4525414114581084"
     crossorigin="anonymous"></script>

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0">
<link rel="icon" type="image/x-icon" href="/images/logo.png">
<link rel="stylesheet" type="text/css" href="/css/common.css">

<script type="text/javascript" src="/js/jquery-1.9.0.min.js"></script>
<script type="text/javascript" src="/js/google-code-prettify/prettify.js"></script>
<link  type="text/css" rel="stylesheet" href="/js/google-code-prettify/prettify.css"/>

<script>
  $(function(){
    // google code prettifyの有効化
    $("pre").addClass("prettyprint");
    function init(event){
      prettyPrint();
    }
    if(window.addEventListener)window.addEventListener("load",init,false);
    else if(window.attachEvent)window.attachEvent("onload",init);
  });
</script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-CP8HZ9DC1K"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-CP8HZ9DC1K');
</script>
<title>Mojolicious::Guides::Cookbook - Mojoliciousのクックブック - Mojoliciousドキュメント 日本語訳</title>
<meta name="description" content="Mojoliciousで料理できる楽しいレシピが満載。">
  </head>
  <body>
    <div class="container">
      <div class="header">
        <div class="header_main">
  <h1>
    <a href="/"><img src="/images/logo.png">Mojoliciousドキュメント日本語訳</a>
  </h1>
  <div class="header_right">
    <a rel="nofollow" href="https://perlclub.net"><img src="/images/perl_club_logo.png"></a>
  </div>
</div>

      </div>
      <div class="main">
        <div class="content">
          <div class="entry">
  <div class="top">
    
  </div>
  <div class="middle">
    <!-- 

<p>Mojoliciousで料理できる楽しいレシピが満載。</p> -->
<html><head><title>名前</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.40,
  using Pod::Simple::PullParser v3.40,
  under Perl v5.032001 at Sat Jun 11 23:10:46 2022 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<h2><a href="/Mojolicious::Guides::Cookbook.html">Mojolicious::Guides::Cookbook - Mojoliciousのクックブック</a></h2>
<div style="width:calc(100% - 30px);margin:10px auto;">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4525414114581084"
       crossorigin="anonymous"></script>
  <!-- 最初の段落下 - ディスプレイ 横長 レスポンシブ -->
  <ins class="adsbygoogle"
       style="display:block"
       data-ad-client="ca-pub-4525414114581084"
       data-ad-slot="2828858335"
       data-ad-format="auto"
       data-full-width-responsive="true"></ins>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({});
  </script>
</div>



<h3><a class='u'
name="_"
>説明</a></h3>

<p>Mojoliciousで料理できる楽しいレシピが満載。</p>

<h3><a class='u'
name="_"
>概念</a></h3>

<p>すべての<a href="/Mojolicious.html">Mojolicious</a>開発者が知るべき本質</p>

<h4><a class='u'
name="_/_"
>ブロッキング / ノンブロッキング処理</a></h4>

<p><code>blocking</code>処理は、サブルーチンが終了するまで呼び出し元サブルーチンの実行をブロックするサブルーチンです。</p>

<pre>sub foo {
  my $result = blocking_subroutine();
  ...
}</pre>

<p>一方、<code>non-blocking</code>処理は、サブルーチンがまだ終了していない場合でも呼び出しサブルーチンの実行が継続できるようにします。待機する代わりに、呼び出し元のサブルーチンは、サブルーチンが終了すると実行されるコールバックを渡します。これは、継続渡しスタイルと呼ばれます。</p>

<pre>sub foo {
  non_blocking_subroutine(sub {
    my $result = shift;
    ...
  });
  ...
}</pre>

<p><code>Mojolicious</code>はノンブロッキングI/Oおよびイベントループのためにゼロから設計されていますが、魔法のごとくPerlコードをノンブロッキングにはできません。 そのためには、<Mojo::IOLoop>や<Mojo::UserAgent>、またはサードパーティのイベントループのようなモジュールを介して利用可能な特殊なノンブロッキングコードを使用する必要があります。ただし、<a href="/Mojo::IOLoop.html">subprocesses</a>の<code>subprocess</code>でブロッキングコードをラップして、ノンブロッキングコードを妨害することを防げます。</p>

<h4><a class='u'
name="_"
>イベントループ</a></h4>

<p>イベントループは基本的に、外部イベントを継続的にテストし、適切なコールバックを実行してそれらを処理するループです。多くの場合、これがプログラムのメインループとなります。ファイル記述子とタイマーの読み取り/書き込みのノンブロッキングテストは、単一のプロセスで同時に数千のクライアント接続を処理できるため、非常にスケーラブルなネットワークサーバーでよく使用されるイベントです。</p>

<pre>while (1) {
  my @readable = test_fds_for_readability();
  handle_readable_fds(@readable);

  my @writable = test_fds_for_writability();
  handle_writable_fds(@writable);

  my @expired = test_timers();
  handle_timers(@expired);
}</pre>

<p><a href="/Mojolicious.html">Mojolicious</a>では、このイベントループは<a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>が行います。</p>

<h4><a class='u'
name="_"
>リバースプロキシ</a></h4>

<p>リバースプロキシアーキテクチャは、多くの運用環境で使用されるデプロイ手法です。<code>reverse proxy</code>サーバーはアプリケーションの前に配置され、外部クライアントからアクセス可能なエンドポイントとして機能します。これには次のような多くの利点があります。外部からのSSL接続の終了、Mojoliciousアプリケーションへの同時オープンソケット数の制限（またはUnixソケットの使用についても）、複数インスタンス間での負荷分散、または複数アプリケーション間での同一IP/ポートの共有。</p>

<pre>                 ..........................................
                 :                                        :
 +--------+      :  +-----------+      +---------------+  :
 |        |--------&gt;|           |      |               |  :
 | client |      :  |  reverse  |-----&gt;|  Mojolicious  |  :
 |        |&lt;--------|   proxy   |      |  application  |  :
 +--------+      :  |           |&lt;-----|               |  :
                 :  +-----------+      +---------------+  :
                 :                                        :
                 .. システム境界（例. 同一ホスト） ......</pre>

<p>ただし、このセットアップではいくつかの問題が発生します。アプリケーションは、オリジナルのクライアントではなくリバースプロキシからリクエストを受け取ります。アプリケーション内部のアドレス/ホスト名は、外部から見えるものとは異なります。また、SSLを終了すると、リバースプロキシはHTTPS経由でサービスを公開し、Mojoliciousアプリケーションに対してはHTTPを使用します。</p>

<p>例として、クライアントからのサンプルリクエストとMojoliciousアプリケーションが受け取るリクエストを比べてみましょう。</p>

<pre> クライアント                       リバースプロクシ                Mojoliciousアプリ
  __|__              _______________|______________             ____|____
 /     \            /                              \           /         \
 1.2.3.4 --HTTPS--&gt; api.example.com      10.20.30.39 --HTTP--&gt; 10.20.30.40

 GET /foo/1 HTTP/1.1                |    GET /foo/1 HTTP/1.1
 Host: api.example.com              |    Host: 10.20.30.40
 User-Agent: Firefox                |    User-Agent: ShinyProxy/1.2
 ...                                |    ...</pre>

<p>ただし、クライアントアドレスは使用できなくなり（分析やGeo-IPに役立つ可能性があります）、<a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>url_for</code>によって生成されたURLは次のようになります。</p>

<pre> http://10.20.30.40/bar/2</pre>

<p>以下のようであればクライアントにとってわかりやすいのですが。</p>

<pre> https://api.example.com/bar/2</pre>

<p>これらの問題を解決するには、不足しているデータを送信するようにリバースプロキシを構成します（<code>/Nginx</code>および<code>/"Apache/mod_proxy"</code>）。そして、環境変数<code>MOJO_REVERSE_PROXY</code> を設定して、アプリケーションに通知します。 きめ細かく制御するために、<code>/Rewriting</code>には変更を手動で実装する方法のサンプルが含まれています。</p>

<h3><a class='u'
name="_"
>デプロイメント</a></h3>

<p><a href="/Mojolicious.html">Mojolicious</a> と <a href="/Mojolicious::Lite.html">Mojolicious::Lite</a> アプリケーションをさまざまなプラットフォームで実行させます。多くのリアルタイムWeb機能が<a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>のイベントループに基づいているので、 イベントループの機能を完全に引き出すためには、組み込みウェブサーバーのひとつ以上がリアルタイム機能を使用できる必要があります。</p>

<h4><a class='u'
name="_"
>組み込みサーバ</a></h4>

<p><a href="/Mojolicious.html">Mojolicious</a> には、とてもポータブルな HTTP 1.1 準拠のウェブサーバが含まれます。通常これらは開発用に利用されますが、小中規模のアプリケーションであれば、十分に堅牢かつ高速に動きます。</p>

<pre>$ ./script/my_app daemon
Server available at http://127.0.0.1:3000.</pre>

<p>コマンド<a href="/Mojolicious::Command::daemon.html">Mojolicious::Command::daemon</a>を介してすべてのアプリケーションで使用できます。多くの設定オプションがあり、Perlが動作するすべてのプラットフォームにおいて単一プロセスアーキテクチャで動きます。</p>

<pre>$ ./script/my_app daemon -h
...利用可能オプションのリスト...</pre>

<p>もうひとつの大きな利点は、そのままで TLS と WebSoket をサポートして いることです。テスト目的のための開発証明書が適切に組み込まれているので、うまく動きます。ただし、すべての位置からリッスン先を <a href="/Mojo::Server::Daemon.html">Mojo::Server::Daemon</a>の<code>listen</code>のサポートによって指定できます。</p>

<pre>$ ./script/my_app daemon -l https://[::]:3000
Server available at https://[::]:3000.</pre>

<p>systemdを使用してWebサーバーを管理するには、次のようなユニット構成ファイルを使用できます。</p>

<pre>[Unit]
Description=My Mojolicious application
After=network.target

[Service]
Type=simple
ExecStart=/home/sri/myapp/script/my_app daemon -m production -l http://*:8080

[Install]
WantedBy=multi-user.target</pre>

<h4><a class='u'
name="_"
>プリフォーク</a></h4>

<p>UNIXプラットフォームでは、<a href="/Mojolicious::Command::prefork.html">Mojolicious::Command::prefork</a>によって組み込みWebサーバにプリフォークが追加でき、複数プロセスアークテクチャに切り替えることができます。複数CPUコアとコピーオンライトメモリ管理を利用できるという利点があります。</p>

<pre>$ ./script/my_app prefork
Server available at http://127.0.0.1:3000.</pre>

<p>組み込みのWebサーバーは<a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>のイベントループに基づいているため、ノンブロッキング処理を利用するときに一番スケールします。しかし、何らかの理由によって多数のブロッキング処理をアプリケーションで実行する必要がある場合は、ワーカープロセスの数を増やしつつ、ワーカーあたりの同時接続数を減らすことでパフォーマンスを向上できます(多くの場合<code>1</code>とする)。</p>

<pre>$ ./script/my_app prefork -m production -w 10 -c 1
Server available at http://127.0.0.1:3000.</pre>

<p>スタートアップの間にマネージャプロセスにおいてアプリケーションが事前ロードされます。このときイベントループは開始しないので、新しいワーカープロセスがフォークされ、イベントループが開始されるときはいつでも、<a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>の<code>next_tick</code>を使ってコードを実行できます。</p>

<pre>use Mojolicious::Lite;

Mojo::IOLoop-&gt;next_tick(sub {
  app-&gt;log-&gt;info("Worker $$ star...ALL GLORY TO THE HYPNOTOAD!");
});

get '/' =&gt; {text =&gt; 'Hello Wor...ALL GLORY TO THE HYPNOTOAD!'};

app-&gt;start;</pre>

<p>また、systemdを使用してプリフォーク前のWebサーバーを管理するには、次のようなユニット構成ファイルを使用できます。</p>

<pre>[Unit]
Description=My Mojolicious application
After=network.target

[Service]
Type=simple
ExecStart=/home/sri/myapp/script/my_app prefork -m production -l http://*:8080

[Install]
WantedBy=multi-user.target</pre>

<h4><a class='u'
name="Morbo"
>Morbo</a></h4>

<p><a href="/Mojolicious::Guides::Tutorial.html">Mojolicious::Guides::Tutorial</a>を読んだ後なら、<a href="/Mojo::Server::Morbo.html">Mojo::Server::Morbo</a>をすでに知っていることでしょう。</p>

<pre>Mojo::Server::Morbo
+- Mojo::Server::Daemon</pre>

<p>基本的には、プロジェクト内の変更されたファイルを検知して、 新しい<a href="/Mojo::Server::Daemon.html">Mojo::Server::Daemon</a>Webサーバーをフォークするリスターターです。よって、これは開発用途でのみ使用してください。Morboでアプリケーションを起動するには、<code>morbo</code>スクリプトを使用します。</p>

<pre>$ morbo ./script/my_app
Server available at http://127.0.0.1:3000.</pre>

<h4><a class='u'
name="Hypnotoad"
>Hypnotoad</a></h4>

<p>もっと大きいアプリケーションのために、<a href="/Mojolicious.html">Mojolicious</a> には UNIX に最適化されたプレフォーキングウェブサーバ <a href="/Mojo::Server::Hypnotoad.html">Mojo::Server::Hypnotoad</a> が含まれています。複数のCPUコアと書き込み時コピー (copy-on-write)が活用でき、スケールアップして数千の並列クライアントに対応できます。</p>

<pre>Mojo::Server::Hypnotoad
|- Mojo::Server::Daemon [1]
|- Mojo::Server::Daemon [2]
|- Mojo::Server::Daemon [3]
+- Mojo::Server::Daemon [4]</pre>

<p>サーバーは<a href="/Mojo::Server::Prefork.html">Mojo::Server::Prefork</a> Webサーバーをベースにしています。これは<a href="/Mojo::Server::Daemon.html">Mojo::Server::Daemon</a>にプリフォーク機能を追加するものですが、運用環境ですぐに使えるよう最適化されています。アプリケーションを開始するには、<a href="/hypnotoad.html">hypnotoad</a>スクリプトを使用します。ポート<code>8080</code>でリッスンし、サーバープロセスを自動的にデーモン化し、<a href="/Mojolicious.html">Mojolicious</a>と<a href="/Mojolicious::Lite.html">Mojolicious::Lite</a>アプリケーションのモードを既定で<code>production</code>にします。</p>

<pre>$ hypnotoad script/my_app</pre>

<p>多くの構成設定はアプリケーションから<a href="/Mojo.html">Mojo</a>の<code>config</code>を使って調整できます。すべての設定のリストは<a href="/Mojo::Server::Hypnotoad.html">Mojo::Server::Hypnotoad</a>の<code>SETTINGS</code>の項目を見てください.</p>

<pre>use Mojolicious::Lite;

app-&gt;config(hypnotoad =&gt; {listen =&gt; ['http://*:80']});

get '/' =&gt; {text =&gt; 'Hello Wor...ALL GLORY TO THE HYPNOTOAD!'};

app-&gt;start;</pre>

<p><a href="/Mojolicious::Plugin::Config.html">Mojolicious::Plugin::Config</a>か<a href="/Mojolicious::Plugin::JSONConfig.html">Mojolicious::Plugin::JSONConfig</a>の設定ファイルに<code>hypnotoad</code>セクションを追加することもできます。</p>

<pre># myapp.conf
{
  hypnotoad =&gt; {
    listen  =&gt; ['https://*:443?cert=/etc/server.crt&key=/etc/server.key'],
    workers =&gt; 10
  }
};</pre>

<p>しかし、最大の利点の一つは、ダウンタイムなしのソフトウェア更新(ホットデプロイメント)をサポートしていることです。つまり、サーバーを止めたり、受信接続をひとつも失うことなく、上記のコマンドを実行するだけで <a href="/Mojolicious.html">Mojolicious</a> や Perl、そして実行中のシステムライブラリでさえ更新できます。</p>

<pre>$ hypnotoad script/my_app
Starting hot deployment for Hypnotoad server 31841.（Hypnotoadサーバー31841のホットデプロイメントを開始しています。）</pre>

<p>リバースプロキシの後ろで<a href="/Mojo::Server::Hypnotoad.html">Hypnotoad</a>を使用している場合は、プロキシサポートを有効にすることもできます。<a href="/Mojolicious.html">Mojolicious</a>が<code>X-Forwarded-For</code>や<code>X-Forwarded-Proto</code>ヘッダーを自動的に検知できるようになります。</p>

<pre># myapp.conf
{hypnotoad =&gt; {proxy =&gt; 1}};</pre>

<p><a href="/Mojo::Server::Hypnotoad.html">Hypnotoad</a>をsystemdで管理するには、次のようなユニット構成ファイルを使用できます。</p>

<pre>[Unit]
Description=My Mojolicious application
After=network.target

[Service]
Type=forking
PIDFile=/home/sri/myapp/script/hypnotoad.pid
ExecStart=/path/to/hypnotoad /home/sri/myapp/script/my_app
ExecReload=/path/to/hypnotoad /home/sri/myapp/script/my_app
KillMode=process

[Install]
WantedBy=multi-user.target</pre>

<h4><a class='u'
name="_"
>ゼロダウンタイム・ソフトウェア更新</a></h4>

<p><a href="/Mojo::Server::Hypnotoad.html">Hypnotoad</a>は、上記のように、ダウンタイムのないソフトウェアアップグレード（ホットデプロイメント）を非常に簡単にします。しかし、<code>SO_REUSEPORT</code>をサポートするモダンなオペレーティングシステムでは、すべての組み込みWebサーバーで使える別の方法もあります。</p>

<pre>$ ./script/my_app prefork -P /tmp/first.pid -l http://*:8080?reuse=1
Server available at http://127.0.0.1:8080.</pre>

<p>すべきことは、同じポートで二つ目のWebサーバーを起動し、 その後に一つ目のWebサーバーをGraceful Shutdownさせることです。</p>

<pre>$ ./script/my_app prefork -P /tmp/second.pid -l http://*:8080?reuse=1
Server available at http://127.0.0.1:8080.
$ kill -s TERM `cat /tmp/first.pid`</pre>

<p>両方のWebサーバーは<code>reuse</code>パラメーターを付けて起動する必要があります。</p>

<h4><a class='u'
name="Nginx"
>Nginx</a></h4>

<p>この頃、最も人気のある構成のひとつは、<a href="/Mojo::Server::Hypnotoad.html">Hypnotoad</a>を<a href="http://nginx.org">Nginx</a>のリバースプロキシの後ろに置くものです。Nginxの新しいバージョンはWebSocketもサポートしています。</p>

<pre>upstream myapp {
  server 127.0.0.1:8080;
}
server {
  listen 80;
  server_name localhost;
  location / {
    proxy_pass http://myapp;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
  }
}</pre>

<h4><a class='u'
name="Apache/mod_proxy"
>Apache/mod_proxy</a></h4>

<p>その他ですぐれたリバースプロキシといえばApacheの<code>mod_proxy</code>でしょう。設定は先ほどのNginxにとてもよく似ています。また、WebSocketサポートが必要な場合、新しいバージョンには<code>mod_proxy_wstunnel</code>が付属します。</p>

<pre>&lt;VirtualHost *:80&gt;
  ServerName localhost
  &lt;Proxy *&gt;
    Require all granted
  &lt;/Proxy&gt;
  ProxyRequests Off
  ProxyPreserveHost On
  ProxyPass /echo ws://localhost:8080/echo
  ProxyPass / http://localhost:8080/ keepalive=On
  ProxyPassReverse / http://localhost:8080/
  RequestHeader set X-Forwarded-Proto "http"
&lt;/VirtualHost&gt;</pre>

<h4><a class='u'
name="Apache/CGI"
>Apache/CGI</a></h4>

<p><code>CGI</code>はそのままですぐにサポートされ、<a href="/Mojolicious.html">Mojolicious</a>アプリケーションは、<code>CGI</code>スクリプトとして実行されていることを自動的に検出します。ただし、本番環境での使用は推奨されません。<code>CGI</code>の動作の仕組みがゆえに、非常に遅く、Webサーバーの種類が多いことから適切な設定が非常に難しくなっています。また、WebSocketなどの多くのリアルタイムWeb機能が使用できません。</p>

<pre>ScriptAlias / /home/sri/myapp/script/my_app</pre>

<h4><a class='u'
name="PSGI/Plack"
>PSGI/Plack</a></h4>

<p><a href="https://metacpan.org/pod/PSGI" class="podlinkpod"
>PSGI</a>は、Perl WebフレームワークとWebサーバー間のインターフェースです。<code>Plack</code>は、Perlモジュールおよびツールキットであり、<code>PSGI</code>のミドルウェア、ヘルパー、およびWebサーバーへのアダプターを含みます。<a href="https://metacpan.org/pod/PSGI" class="podlinkpod"
>PSGI</a> と <code>Plack</code> は Python の WSGI と Ruby の Rack に触発されています。<code>Plack</code>を使用した<a href="/Mojolicious.html">Mojolicious</a>アプリケーションのデプロイはあっけないほど簡単です。ただし、WebSocketなどの多くのリアルタイムWeb機能は使用できないことに注意してください。</p>

<pre>$ plackup ./script/my_app</pre>

<p><code>Plack</code> は、<code>FCGI</code>、<code>uWSGI</code>、<code>mod_perl</code> など、多くのサーバーやプロトコルのためのアダプタを提供します。</p>

<pre>$ plackup ./script/my_app -s FCGI -l /tmp/myapp.sock</pre>

<p><code>MOJO_REVERSE_PROXY</code>環境変数は、プロキシのサポートのために利用できます。<a href="/Mojolicious.html">Mojolicious</a>が自動的に<code>X-Forwarded-For</code>と<code>X-Forwarded-Proto</code>ヘッダーを取得できるようになります。</p>

<pre>$ MOJO_REVERSE_PROXY=1 plackup ./script/my_app</pre>

<p>古いサーバーのアダプタがアプリケーションのホームディレクトリを正しく検知できなかった場合は、単純に<code>MOJO_HOME</code>環境変数を使用できます。</p>

<pre>$ MOJO_HOME=/home/sri/my_app plackup ./script/my_app</pre>

<p><code>.psgi</code> ファイルは必要ありません。サーバーアダプターをアプリケーションスクリプトにて指定しておけば、<code>PLACK_ENV</code> 環境変数を検知したときに、自動的に<code>.psgi</code>ファイルであるかのように振舞います。</p>

<h4><a class='u'
name="Plack"
>Plackミドルウェア</a></h4>

<p><code>myapp.fcgi</code>などのラッパースクリプトを使うのは、デプロイメントとアプリケーションロジックを分離するとてもよい方法です。</p>

<pre>#!/usr/bin/env plackup -s FCGI
use Plack::Builder;

builder {
  enable 'Deflater';
  require './script/my_app';
};</pre>

<p><a href="/Mojo::Server::PSGI.html">Mojo::Server::PSGI</a>を直接使うと、ラッパースクリプトのなかでアプリケーションを読み込んだりカスタマイズしたりできます。</p>

<pre>#!/usr/bin/env plackup -s FCGI
use Mojo::Server::PSGI;
use Plack::Builder;

builder {
  enable 'Deflater';
  my $server = Mojo::Server::PSGI-&gt;new;
  $server-&gt;load_app('./script/my_app');
  $server-&gt;app-&gt;config(foo =&gt; 'bar');
  $server-&gt;to_psgi_app;
};</pre>

<p>アプリケーションの中でミドルウェアを使うことさえできます。</p>

<pre>use Mojolicious::Lite;
use Plack::Builder;

get '/welcome' =&gt; sub {
  my $c = shift;
  $c-&gt;render(text =&gt; 'Hello Mojo!');
};

builder {
  enable 'Deflater';
  app-&gt;start;
};</pre>

<h4><a class='u'
name="_"
>書き換え</a></h4>

<p>ときとして、アプリケーションを、自分でサーバの設定を変えることができないブラックボックス環境、または、 <code>X-*</code> ヘッダーで補助情報を伝えるリバースプロキシの背後でデプロイする必要があるかもしれません。そのような場合、<a href="/Mojolicious.html">Mojolicious</a>の<code>before_dispatch</code> フックを使用して受信リクエストを書き換えられます。</p>

<pre># "X-Forwarded-HTTPS"ヘッダーが"https"に設定されていた場合にスキーマを変更
$app-&gt;hook(before_dispatch =&gt; sub {
  my $c = shift;
  $c-&gt;req-&gt;url-&gt;base-&gt;scheme('https')
    if $c-&gt;req-&gt;headers-&gt;header('X-Forwarded-HTTPS');
});</pre>

<p>一般的にリバースプロキシはアプリケーションがデプロイされたパスの前部分を渡さないので、受信するリクエストのベースパスの書き換えがよく行われます。これにより、たとえば<a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>/"url_for"</code>を使って現在の環境に合わせたURLを生成できます。</p>

<pre># productionモードではパスの最初の部分とスラッシュをベースパスに移動
$app-&gt;hook(before_dispatch =&gt; sub {
  my $c = shift;
  push @{$c-&gt;req-&gt;url-&gt;base-&gt;path-&gt;trailing_slash(1)},
    shift @{$c-&gt;req-&gt;url-&gt;path-&gt;leading_slash(0)};
}) if $app-&gt;mode eq 'production';</pre>

<p><a href="/Mojo::URL.html">Mojo::URL</a>オブジェクトの操作はとても簡単です。常に、ルーティングの行き先を表すURL (foo/bar?baz=yada)を、アプリケーションのデプロイメント場所を示すベースURL(http://example.com/myapp/)からの相対パスとなるようにします。</p>

<h4><a class='u'
name="_"
>アプリケーションの埋め込み</a></h4>

<p>時によって、設定ファイル、データベース接続、その他スクリプトのためのヘルパーなど、<a href="/Mojolicious.html">Mojolicious</a>アプリケーションのパーツを再利用したい場合があるかもしれません。次のような<a href="/Mojo::Server.html">Mojo::Server</a>をベースにしたモックサーバーでそれらを埋め込むことができます。</p>

<pre>use Mojo::Server;

# モックサーバーでアプリケーションをロード
my $server = Mojo::Server-&gt;new;
my $app = $server-&gt;load_app('./myapp.pl');

# 完全に初期化されたアプリケーションにアクセス
say for @{$app-&gt;static-&gt;paths};
say $app-&gt;config-&gt;{secret_identity};
say $app-&gt;dumper(just =&gt; 'a helper test');
say $app-&gt;build_controller-&gt;render_to_string(template =&gt; 'foo');</pre>

<p><a href="/Mojolicious::Plugin::Mount.html">Mojolicious::Plugin::Mount</a>は、この機能を使って複数のアプリケーションをひとつに結合し、まとめてデプロイできるようにします。</p>

<pre>use Mojolicious::Lite;

app-&gt;config(hypnotoad =&gt; {listen =&gt; ['http://*:80']});

plugin Mount =&gt; {'test1.example.com' =&gt; '/home/sri/myapp1.pl'};
plugin Mount =&gt; {'test2.example.com' =&gt; '/home/sri/myapp2.pl'};

app-&gt;start;</pre>

<h4><a class='u'
name="Web"
>Webサーバーの埋め込み</a></h4>

<p><a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>の<code>one_tick</code>を使用して、組み込みWebサーバー<a href="/Mojo::Server::Daemon.html">Mojo::Server::Daemon</a>を、なんらかの理由で新しいリアクターのバックエンドに統合できない外部イベントループのような異なった環境に埋め込むことができます。</p>

<pre>use Mojolicious::Lite;
use Mojo::IOLoop;
use Mojo::Server::Daemon;

# 通常のアクション
get '/' =&gt; {text =&gt; 'Hello World!'};

# アプリケーションをWebサーバーと接続して、接続の受付を開始する
my $daemon =
  Mojo::Server::Daemon-&gt;new(app =&gt; app, listen =&gt; ['http://*:8080']);
$daemon-&gt;start;

# 外部の環境から"one_tick"を繰り返し呼び出す
Mojo::IOLoop-&gt;one_tick while 1;</pre>

<h3><a class='u'
name="Web"
>リアルタイムWeb</a></h3>

<p>リアルタイムWebとは、Comet（ロングポーリング）、EventSource、WebSockeといったテクノロジーの集まりのことです。伝統的なプルモデルに頼る代わりに長時間接続を用いることで、コンテンツが生成されるとすぐにクライアントにプッシュすることができます。すべての組み込みサーバーはノンブロッキングI/Oを使っていて、<a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>のリアクターをベースにしています。多くの強力な機能によって、リアルタイムWebアプリケーションをスケールアップすることができ、数千の並列のクライアントを処理できます。</p>

<h4><a class='u'
name="Web"
>Webサービスのバックエンド</a></h4>

<p><a href="/Mojo::UserAgent.html">Mojo::UserAgent</a>は<a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>のリアクターをベースに作られているため、ノンブロッキングで利用されるとき、高レイテンシのバックエンドWebサービスであっても、組み込みWebサーバーをブロックしません。</p>

<pre>use Mojolicious::Lite;

# MetaCPANで"mojolicious"を検索
get '/' =&gt; sub {
  my $c = shift;
  $c-&gt;ua-&gt;get('fastapi.metacpan.org/v1/module/_search?q=mojolicious' =&gt; sub {
    my ($ua, $tx) = @_;
    $c-&gt;render('metacpan', hits =&gt; $tx-&gt;result-&gt;json-&gt;{hits}{hits});
  });
};

app-&gt;start;
__DATA__;

@@ metacpan.html.ep
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;title&gt;MetaCPAN results for "mojolicious"&lt;/title&gt;&lt;/head&gt;
  &lt;body&gt;
    % for my $hit (@$hits) {
      &lt;p&gt;&lt;%= $hit-&gt;{_source}{release} %&gt;&lt;/p&gt;
    % }
  &lt;body&gt;
&lt;/html&gt;</pre>

<p><a href="/Mojo::UserAgent.html">Mojo::UserAgent</a>の<code>/"get"</code>に渡されるコールバックは、バックエンドWebサービスへのリクエストが完了すると実行されます。これは継続渡しスタイルと呼ばれます。</p>

<p>=head2ノンブロッキング処理の同期</p>

<p>同時リクエストなどの複数のノンブロッキング処理は、promiseおよび<a href="/Mojo::Promise.html">Mojo::Promise</a>の<code>/"all"</code>を使って簡単に同期できます。<a href="/Mojo :: Promise.html">Mojo :: Promise</a>オブジェクトを手動で作成するか、<a href="/Mojo :: UserAgent.html">Mojo :: UserAgent</a>の<code>/"get_p"</code>などのメソッドを使用してそれらが作成されるようにします。</p>

<pre>use Mojolicious::Lite;
use Mojo::Promise;
use Mojo::URL;

# MetaCPANで"mojo"と"minion"を検索
get '/' =&gt; sub {
  my $c = shift;

  # promiseをふたつ作成
  my $url   = Mojo::URL-&gt;new('fastapi.metacpan.org/v1/module/_search');
  my $mojo   = $c-&gt;ua-&gt;get_p($url-&gt;clone-&gt;query({q =&gt; 'mojo'}));
  my $minion = $c-&gt;ua-&gt;get_p($url-&gt;clone-&gt;query({q =&gt; 'minion'}));

  # promiseがふたつとも完了したらレスポンスを描画
  Mojo::Promise-&gt;all($mojo, $minion)-&gt;then(sub {
    my ($mojo, $minion) = @_;
    $c-&gt;render(json =&gt; {
      mojo   =&gt; $mojo-&gt;[0]-&gt;result-&gt;json('/hits/hits/0/_source/release'),
      minion =&gt; $minion-&gt;[0]-&gt;result-&gt;json('/hits/hits/0/_source/release')
    });
  })-&gt;catch(sub {
    my $err = shift;
    $c-&gt;reply-&gt;exception($err);
  })-&gt;wait;
};

app-&gt;start;</pre>

<p>promiseを手動で作成するには、継続渡しスタイルのAPIをpromiseを返す関数でラップするだけです。ここで、<a href="/Mojo::UserAgent.html">Mojo::UserAgent</a>の<code>"get_p"</code>が内部でどのように動作するかを例にして説明します。</p>

<pre>use Mojo::UserAgent;
use Mojo::Promise;

# ユーザーエージェントメソッドをpromiseでラップする
my $ua = Mojo::UserAgent-&gt;new;
sub get_p {
  my $promise = Mojo::Promise-&gt;new;
  $ua-&gt;get(@_ =&gt; sub {
    my ($ua, $tx) = @_;
    my $err = $tx-&gt;error;
    $promise-&gt;resolve($tx) if !$err || $err-&gt;{code};
    $promise-&gt;reject($err-&gt;{message});
  });
  return $promise;
}

# 作成したpromiseを生成する関数を使う
get_p('https://mojolicious.org')-&gt;then(sub {
  my $tx = shift;
  say $tx-&gt;result-&gt;dom-&gt;at('title')-&gt;text;
})-&gt;wait;</pre>

<p>promiseは3つの状態を持ちます。はじめは<code>pending</code>となり、<a href="/Mojo::Promise.html">Mojo::Promise</a>の<code>"resolve"</code>をコールすると<code>fulfilled</code>に遷移し、あるいは、<a href="/Mojo::Promise.html">Mojo::Promise</a>の<code>"reject"</code>をコールすると<code>rejected</code>に遷移します。</p>

<h4><a class='u'
name="_"
>タイマー</a></h4>

<p>イベントループのもう1つの主要な機能であるタイマーは、<a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>の<code>/"timer"</code>で作成します。タイマーは、たとえばレスポンスの描画を遅らせるために使用できます。<code>sleep</code>とは異なり、並列に処理される他のリクエストをブロックしません。</p>

<pre>use Mojolicious::Lite;
use Mojo::IOLoop;

# 3秒待ってレスポンスを描画する
get '/' =&gt; sub {
  my $c = shift;
  Mojo::IOLoop-&gt;timer(3 =&gt; sub {
    $c-&gt;render(text =&gt; '3秒遅れています！');
  });
};

app-&gt;start;</pre>

<p><a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>の<code>/"recurring"</code>で作成した繰り返しタイマーは、もう少し強力ですが、手動で停止する必要があります。そうしないと、ひたすら動作し続けます。</p>

<pre>use Mojolicious::Lite;
use Mojo::IOLoop;

# 1秒刻みで5まで数える
get '/' =&gt; sub {
  my $c = shift;

  # 繰り返しタイマーを開始
  my $i = 1;
  my $id = Mojo::IOLoop-&gt;recurring(1 =&gt; sub {
    $c-&gt;write_chunk($i);
    $c-&gt;finish if $i++ == 5;
  });

  # 繰り返しタイマーを停止
  $c-&gt;on(finish =&gt; sub { Mojo::IOLoop-&gt;remove($id) });
};

app-&gt;start;</pre>

<p>タイマーは特定のリクエストや接続に関連付けられてはいないため、スタートアップ時に生成することもできます。</p>

<pre>use Mojolicious::Lite;
use Mojo::IOLoop;

# 10秒ごとにバックグラウンドでタイトルをチェック
my $title = 'Got no title yet.';
Mojo::IOLoop-&gt;recurring(10 =&gt; sub {
  app-&gt;ua-&gt;get('https://mojolicious.org' =&gt; sub {
    my ($ua, $tx) = @_;
    $title = $tx-&gt;result-&gt;dom-&gt;at('title')-&gt;text;
  });
});

# 現在のタイトルを表示
get '/' =&gt; sub {
  my $c = shift;
  $c-&gt;render(json =&gt; {title =&gt; $title});
};

app-&gt;start;</pre>

<p>これらのノンブロッキング処理はすべて協調して処理されるため、コールバック関数が長時間ブロックされることはありません。</p>

<h4><a class='u'
name="_"
>サブプロセス</a></h4>

<p>サブプロセスを<a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>の<code>/"subprocess"</code>で作成して使用することで、イベントループをブロックせずに計算負荷の高い操作を実行できます。</p>

<pre>use Mojolicious::Lite;
use Mojo::IOLoop;

# イベントループを5秒間ブロックする処理
get '/' =&gt; sub {
  my $c = shift;
  Mojo::IOLoop-&gt;subprocess(
    sub {
      my $subprocess = shift;
      sleep 5;
      return '♥', 'Mojolicious';
    },
    sub {
      my ($subprocess, $err, @results) = @_;
      $c-&gt;reply-&gt;exception($err) and return if $err;
      $c-&gt;render(text =&gt; "I $results[0] $results[1]!");
    }
  );
};

app-&gt;start;</pre>

<p>最初のコールバックは、親プロセスのイベントループをブロックせずに、子プロセスとして実行されます。最初のコールバックの結果は両方のプロセス間で共有され、2番目のコールバックが親プロセスで実行されます。</p>

<h4><a class='u'
name="_"
>ノンブロッキング処理における例外</a></h4>

<p>タイマーと他のノンブロッキング処理は、アプリケーション外部において単一のイベントループの中のみで実行されているため、コールバックの中で発生した例外は自動的にはキャッチできません。しかし、<a href="/Mojo::Reactor.html">Mojo::Reactor</a>の<code>error</code>イベントを購読することによって手動で処理することができます。また、コールバックの中でキャッチすることもできます。</p>

<pre>use Mojolicious::Lite;
use Mojo::IOLoop;

# エラーメッセージをアプリケーションのログに転送する
Mojo::IOLoop-&gt;singleton-&gt;reactor-&gt;on(error =&gt; sub {
  my ($reactor, $err) = @_;
  app-&gt;log-&gt;error($err);
});

# 例外（と接続タイムアウト）だけをロギング
get '/connection_times_out' =&gt; sub {
  my $c = shift;
  Mojo::IOLoop-&gt;timer(2 =&gt; sub {
    die 'このリクエストにはレスポンスが返ってこない。';
  });
};

# 例外をキャッチして処理する
get '/catch_exception' =&gt; sub {
  my $c = shift;
  Mojo::IOLoop-&gt;timer(2 =&gt; sub {
    eval { die 'このリクエストにはレスポンスが返る' };
    $c-&gt;reply-&gt;exception($@) if $@;
  });
};

app-&gt;start;</pre>

<p>通常、デフォルトですべてのエラーを警告に変換するサブスクライバーが、<a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>によってフォールバックとして追加されます。</p>

<pre>Mojo::IOLoop-&gt;singleton-&gt;reactor-&gt;unsubscribe('error');</pre>

<p>開発時またはクラッシュするのが望ましいアプリケーションのためには、サブスクライバーをすべて取り除くことによって、コールバックで発生するすべての例外が致命的なものになります。</p>

<h4><a class='u'
name="WebSocketWeb"
>WebSocketによるWebサービス</a></h4>

<p>WebSocketプロトコルは、サーバーとクライアントの間を双方向で、低レイテンシでつなぐ通信チャンネルです。メッセージは<a href="/Mojo::Transaction::WebSocket.html">Mojo::Transaction::WebSocket</a>の<code>"message"</code>などのイベントを<a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>"on"</code>でサブスクライブするだけで受信できます。そして、<a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>"send"</code>でメッセージを返します 。</p>

<pre>use Mojolicious::Lite;

# ブラウザ側コードを含むテンプレート
get '/' =&gt; 'index';

# WebSocketのエコーサービス
websocket '/echo' =&gt; sub {
  my $c = shift;

  # 接続を開く
  $c-&gt;app-&gt;log-&gt;debug('WebSocket opened');

  # 接続のタイムアウト時間を少し増やす
  $c-&gt;inactivity_timeout(300);

  # 受信メッセージ
  $c-&gt;on(message =&gt; sub {
    my ($c, $msg) = @_;
    $c-&gt;send("echo: $msg");
  });

  # 接続を閉じる
  $c-&gt;on(finish =&gt; sub {
    my ($c, $code, $reason) = @_;
    $c-&gt;app-&gt;log-&gt;debug("WebSocket closed with status $code");
  });
};

app-&gt;start;
__DATA__;

@@ index.html.ep
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;title&gt;Echo&lt;/title&gt;&lt;/head&gt;
  &lt;body&gt;
    &lt;script&gt;
      var ws = new WebSocket('&lt;%= url_for('echo')-&gt;to_abs %&gt;');

      // 受信メッセージ
      ws.onmessage = function (event) {
        document.body.innerHTML += event.data + '&lt;br/&gt;';
      };

      // 送信メッセージ
      ws.onopen = function (event) {
        window.setInterval(function () { ws.send('Hello Mojo!') }, 1000);
      };
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

<p><a href="/Mojo::Transaction::WebSocket.html">Mojo::Transaction::WebSocket</a>の<code>"finish"</code>イベントは、WebSocket接続が閉じるとすぐに発行されます。</p>

<pre>$c-&gt;tx-&gt;with_compression;</pre>

<p><a href="/Mojo::Transaction::WebSocket.html">Mojo::Transaction::WebSocket</a>の<code>with_compression</code>を使って、<code>permessage-deflate</code> 圧縮を有効にすることができます。これはパフォーマンスを大きく改善しますが、接続あたりのメモリ使用量が最大で300KB増えます。</p>

<pre>my $proto = $c-&gt;tx-&gt;with_protocols('v2.proto', 'v1.proto');</pre>

<p><a href="/Mojo::Transaction::WebSocket.html">Mojo::Transaction::WebSocket</a>の<code>"with_protocols"</code>を使ってサブプロトコルをネゴシエートすることもできます。</p>

<h4><a class='u'
name="EventSourceWeb"
>EventSourceによるWebサービス</a></h4>

<p>HTML5のEventSourceは、特別な形式のロングポーリング（<a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>write</code>を使うなど）です。サーバーからクライアントへDOMイベントを直接送信できます。送信は一方行なので、クライアントからサーバーへのデータの送信にはAjaxリクエストを使う必要があります。しかしながら、データ送信にHTTPプロトコルを再利用しており、インフラ要件が少ないという利点があります。</p>

<pre>use Mojolicious::Lite;

# ブラウザ側コードを含むテンプレート
get '/' =&gt; 'index';

# ログメッセージのためのEventSource
get '/events' =&gt; sub {
  my $c = shift;

  # 接続のタイムアウト時間を少し増やす
  $c-&gt;inactivity_timeout(300);

  # コンテンツタイプを変更して、レスポンスヘッダをファイナライズ
  $c-&gt;res-&gt;headers-&gt;content_type('text/event-stream');
  $c-&gt;write;

  # "message"イベントをサブスクライブし、"log"イベントをブラウザに送る
  my $cb = $c-&gt;app-&gt;log-&gt;on(message =&gt; sub {
    my ($log, $level, $message) = @_;
    $c-&gt;write("event:log\ndata: [$level] @lines\n\n");
  });

  # 終わったら、"message"イベントのサブスクライブを解除する
  $c-&gt;on(finish =&gt; sub {
    my $c = shift;
    $c-&gt;app-&gt;log-&gt;unsubscribe(message =&gt; $cb);
  });
};

app-&gt;start;
__DATA__;

@@ index.html.ep
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;title&gt;LiveLog&lt;/title&gt;&lt;/head&gt;
  &lt;body&gt;
    &lt;script&gt;
      var events = new EventSource('&lt;%= url_for 'events' %&gt;');

      // "log"イベントをサブスクライブする
      events.addEventListener('log', function (event) {
        document.body.innerHTML += event.data + '&lt;br/&gt;';
      }, false);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

<p><a href="/Mojo::Log.html">Mojo::Log</a>の<code>message</code>イベントは、ログメッセージが発生するごと放出され、<a href="/Mojo::Transaction.html">Mojo::Transaction</a>の<code>finish</code>イベントはトランザクションが完了した直後に放出されます。</p>

<h4><a class='u'
name="_"
>マルチパートアップロードのストリーミング</a></h4>

<p><a href="/Mojolicious.html">Mojolicious</a>は、<a href="/Mojo::EventEmitter.html">Mojo::EventEmitter</a>を基盤とするとても洗練されたイベントシステムをもち、ほとんどすべての層でイベントがすぐに使えます。そして、このイベントシステムを組み合わせることで、WEB開発のなかで難易度が高い問題を解決することができるでしょう。</p>

<pre>use Mojolicious::Lite;
use Scalar::Util 'weaken';

# マルチパートアップロードの間に割り入って、チャンクを受け取るごとにログを出力する
hook after_build_tx =&gt; sub {
  my $tx = shift;

  # "upgrade"イベントをサブスクライブして、マルチパートアップロードを識別する
  weaken $tx;
  $tx-&gt;req-&gt;content-&gt;on(upgrade =&gt; sub {
    my ($single, $multi) = @_;
    return unless $tx-&gt;req-&gt;url-&gt;path-&gt;contains('/upload');

    # "part"イベントをサブスクライブして、目当てのモノを探す
    $multi-&gt;on(part =&gt; sub {
      my ($multi, $single) = @_;

      # "body"イベントをサブスクライブして、ヘッダがすべてあることを確認する
      $single-&gt;on(body =&gt; sub {
        my $single = shift;

        # 正しいパーツを持っていることを確認し、"read"イベントを置き換える
        return unless $single-&gt;headers-&gt;content_disposition =~ /example/;
        $single-&gt;unsubscribe('read')-&gt;on(read =&gt; sub {
          my ($single, $bytes) = @_;

          # 受け取ったチャンクごとにサイズをログに出力する
          app-&gt;log-&gt;debug(length($bytes) . ' bytes uploaded');
        });
      });
    });
  });
};

# DATAセクションにあるアップロードフォーム
get '/' =&gt; 'index';

# マルチパートアップロードをストリーミング
post '/upload' =&gt; {text =&gt; 'アップロードが成功しました。'};

app-&gt;start;
__DATA__;

@@ index.html.ep
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;title&gt;Streaming multipart upload&lt;/title&gt;&lt;/head&gt;
  &lt;body&gt;
    %= form_for upload =&gt; (enctype =&gt; 'multipart/form-data') =&gt; begin
      %= file_field 'example'
      %= submit_button 'Upload'
    % end
  &lt;body&gt;
&lt;/html&gt;</pre>

<h4><a class='u'
name="_"
>その他のイベントループ</a></h4>

<p>内部的に<a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>リアクターは複数のイベントループのバックエンドを利用できます。たとえば<a href="https://metacpan.org/pod/EV" class="podlinkpod"
>EV</a>は、インストールされていれば自動的に使用されます。したがって、<a href="https://metacpan.org/pod/AnyEvent" class="podlinkpod"
>AnyEvent</a>のようなイベントループも正しく動かすことができます。</p>

<pre>use Mojolicious::Lite;
use EV;
use AnyEvent;

# 3秒待ってレスポンスを描画する
get '/' =&gt; sub {
  my $c = shift;
  my $w;
  $w = AE::timer 3, 0, sub {
    $c-&gt;render(text =&gt; '3秒遅れています！');
    undef $w;
  };
};

app-&gt;start;</pre>

<p>バックエンドで実際に誰がイベントループを制御するかは重要ではありません。</p>

<pre>use Mojo::UserAgent;
use EV;
use AnyEvent;

# MetaCPANで"mojolicious"を検索
my $cv = AE::cv;
my $ua = Mojo::UserAgent-&gt;new;
$ua-&gt;get('fastapi.metacpan.org/v1/module/_search?q=mojolicious' =&gt; sub {
  my ($ua, $tx) = @_;
  $cv-&gt;send($tx-&gt;result-&gt;json('/hits/hits/0/_source/release'));
});
say $cv-&gt;recv;</pre>

<p>たとえば、組み込みのWebサーバーを<a href="/AnyEvent.html">AnyEvent</a>アプリケーションに組み込むこともできます。</p>

<pre>use Mojolicious::Lite;
use Mojo::Server::Daemon;
use EV;
use AnyEvent;

# 通常のアクション
get '/' =&gt; {text =&gt; 'Hello World!'};

# アプリケーションをWebサーバーと接続して、接続の受付を開始する
my $daemon =
  Mojo::Server::Daemon-&gt;new(app =&gt; app, listen =&gt; ['http://*:8080']);
$daemon-&gt;start;

# AnyEventにコントロールさせる
AE::cv-&gt;recv;</pre>

<h3><a class='u'
name="_"
>ユーザーエージェント</a></h3>

<p>わたしたちが <a href="/Mojolicious.html">Mojolicious</a> はウェブフレームワークだと言うとき、それは本気です。<a href="/Mojo::UserAgent.html">Mojo::UserAgent</a>には、フル機能を備えたHTTPとWebSocketのユーザーエージェントが組み込まれています。</p>

<h4><a class='u'
name="REST"
>RESTウェブサービス</a></h4>

<p>リクエストは、<a href="/Mojo::UserAgent.html">Mojo::UserAgent</a>の<code>"get"</code>などのメソッドによって快適に実行できます。返り値は常に<a href="/Mojo::Transaction::HTTP.html">Mojo::Transaction::HTTP</a>オブジェクトになります。このオブジェクトには多くの便利な属性とメソッドがあります。<a href="/Mojo::Transaction.html">Mojo::Transaction</a>の<code>"result"</code>で接続エラーが確認できます。または、<Mojo::Transaction/"req">や<Mojo::Transaction/"res">からHTTPリクエストおよびレスポンス情報に直接アクセスできます。</p>

<pre>use Mojo::UserAgent;

＃リソースをリクエストし、接続エラーがないことを確認する
my $ua = Mojo::UserAgent-&gt;new;
my $tx = $ua-&gt;get('mojolicious.org/perldoc/Mojo' =&gt; {Accept =&gt; 'text/plain'});
my $res = $tx-&gt;result;

# 応答に合わせて何をするかを決める
if    ($res-&gt;is_success)  { say $res-&gt;body }
elsif ($res-&gt;is_error)    { say $res-&gt;message }
elsif ($res-&gt;code == 301) { say $res-&gt;headers-&gt;location }
else                      { say 'Whatever...' }</pre>

<p><a href="/Mojo::Message::Response.html">Mojo::Message::Response</a>の<code>"is_success"</code>と<a href="/Mojo::Message::Response.html">Mojo::Message::Response</a>の<code>"is_error"</code>のようなメソッドが、RESTクライアントをより洗練されたものにしています。</p>

<h4><a class='u'
name="_"
>ウェブスクレイピング</a></h4>

<p>過去、ウェブサイトから情報をスクレイピングするのがこれほど面白かったことはありません。組み込みの XML/HTML5 パーサ <a href="/Mojo::DOM.html">Mojo::DOM</a> は、[[Mojo::Message]の<code>dom</code>を通して利用でき、スタンドアロンパーサが理解できる全ての CSS3 セレクタをサポートします。とくにWebアプリケーションをテストするためのツールとしてとても強力です。</p>

<pre>use Mojo::UserAgent;

# ウェブサイトを取得
my $ua = Mojo::UserAgent-&gt;new;
my $res = $ua-&gt;get('mojolicious.org/perldoc')-&gt;result;

# タイトルを抽出
say 'Title: ', $res-&gt;dom-&gt;at('head &gt; title')-&gt;text;

# 見出しを抽出
$res-&gt;dom('h1, h2, h3')-&gt;each(sub { say 'Heading: ', shift-&gt;all_text });

# すべてのノードを再帰的にたどって、テキストとその他のものを抽出する
for my $n ($res-&gt;dom-&gt;descendant_nodes-&gt;each) {

  # テキストまたはCDATAノード
  print $n-&gt;content if $n-&gt;type eq 'text' || $n-&gt;type eq 'cdata';

  # 画像のAltテキストを含める
  print $n-&gt;{alt} if $n-&gt;type eq 'tag' && $n-&gt;tag eq 'img';
}</pre>

<p>利用可能なCSSセレクタの完全なリストについては、<a href="/Mojo::DOM::CSS.html">Mojo::DOM::CSS</a>の<code>"SELECTORS"</code> を見てください。</p>

<h4><a class='u'
name="JSON_"
>JSON ウェブサービス</a></h4>

<p>最近ではウェブサービスのほとんどが、データ交換フォーマットとしてJSONを使っています。 なので<a href="/Mojolicious.html">Mojolicious</a>には、ピュアPerl実装としてはおそらく最速である<a href="/Mojo::JSON.html">Mojo::JSON</a>が組み込まれています。ここには<a href="/Mojo::Message.html">Mojo::Message</a>の<code>"json"</code>からアクセスできます。</p>

<pre>use Mojo::UserAgent;
use Mojo::URL;

# 新しいユーザーエージェント
my $ua = Mojo::UserAgent-&gt;new;

# MetaCPANで"mojolicious"を検索して、最新のリリースを表示する
my $url = Mojo::URL-&gt;new('http://fastapi.metacpan.org/v1/release/_search');
$url-&gt;query({q =&gt; 'mojolicious', sort =&gt; 'date:desc'});
for my $hit (@{$ua-&gt;get($url)-&gt;result-&gt;json-&gt;{hits}{hits}}) {
  say "$hit-&gt;{_source}{name} ($hit-&gt;{_source}{author})";
}</pre>

<h4><a class='u'
name="_"
>ベーシック認証</a></h4>

<p>ユーザ名とパスワードを URL に追加するだけで、<code>Authorization</code>ヘッダーが自動的に生成されます。</p>

<pre>use Mojo::UserAgent;

my $ua = Mojo::UserAgent-&gt;new;
say $ua-&gt;get('https://sri:secret@example.com/hideout')-&gt;result-&gt;body;</pre>

<h4><a class='u'
name="_"
>追加リクエストの装飾</a></h4>

<p><a href="/Mojo::UserAgent.html">Mojo::UserAgent</a>は自動的にリダイレクトを辿り、<code>"start"</code>イベントが、トランザクションが初期化された後かつそれが接続と関連付けられる前に、それぞれのトランザクションへの直接アクセスを可能にします。</p>

<pre>use Mojo::UserAgent;

# 最大10回までリダイレクトを追跡するユーザーエージェント
my $ua = Mojo::UserAgent-&gt;new(max_redirects =&gt; 10);

# 各リクエストに気の利いたヘッダを追加
$ua-&gt;on(start =&gt; sub {
  my ($ua, $tx) = @_;
  $tx-&gt;req-&gt;headers-&gt;header('X-Bender' =&gt; 'Bite my shiny metal ass!');
  say 'Request: ', $tx-&gt;req-&gt;url-&gt;clone-&gt;to_abs;
});

# リダイレクトされるであろうリクエスト
say 'Title: ', $ua-&gt;get('google.com')-&gt;result-&gt;dom-&gt;at('head &gt; title')-&gt;text;</pre>

<p>これはプロキシへの <code>CONNECT</code> リクエストに対しても使えます。</p>

<h4><a class='u'
name="_"
>コンテンツジェネレーター</a></h4>

<p>コンテンツジェネレーターは、<a href="/Mojo::UserAgent::Transactor.html">Mojo::UserAgent::Transactor</a>の<code>"add_generator"</code>で登録できます。こうすると、複数のリクエストに対して同じタイプのコンテンツを繰り返し生成することができます。</p>

<pre>use Mojo::UserAgent;
use Mojo::Asset::File;

# "stream"ジェネレーターを追加
my $ua = Mojo::UserAgent-&gt;new;
$ua-&gt;transactor-&gt;add_generator(stream =&gt; sub {
  my ($transactor, $tx, $path) = @_;
  $tx-&gt;req-&gt;content-&gt;asset(Mojo::Asset::File-&gt;new(path =&gt; $path));
});

# PUTとPOSTを通して複数のファイルのストリーミングを送信
$ua-&gt;put('http://example.com/upload'  =&gt; stream =&gt; '/home/sri/mojo.png');
$ua-&gt;post('http://example.com/upload' =&gt; stream =&gt; '/home/sri/minion.png');</pre>

<p><code>json</code> 、<code>form</code>および<code>multipart</code>コンテンツジェネレーターが常に利用可能です。</p>

<pre>use Mojo::UserAgent;

# PATCHを使って"application/json"コンテンツを送信
my $ua = Mojo::UserAgent-&gt;new;
my $tx = $ua-&gt;patch('http://api.example.com' =&gt; json =&gt; {foo =&gt; 'bar'});

# GETを使ってクエリパラメーターを送信
my $tx2 = $ua-&gt;get('search.example.com' =&gt; form =&gt; {q =&gt; 'test'});

# POSTを使って"application/x-www-form-urlencoded"コンテンツを送信
my $tx3 = $ua-&gt;post('http://search.example.com' =&gt; form =&gt; {q =&gt; 'test'});

# PUTを使って"multipart/form-data"コンテンツを送信
my $tx4 = $ua-&gt;put(
  'upload.example.com' =&gt; form =&gt; {test =&gt; {content =&gt; 'Hello World!'}});

# PUTを使ってカスタムマルチパートを送信
my $tx5 = $ua-&gt;put('api.example.com' =&gt; multipart =&gt; ['Hello', 'World!']);</pre>

<p>コンテンツジェネレーターについて、より詳しい情報は<a href="/Mojo::UserAgent::Transactor.html">Mojo::UserAgent::Transactor</a>の<code>tx</code>を見てください。</p>

<h4><a class='u'
name="_"
>大きなファイルのダウンロード</a></h4>

<p><a href="/Mojo::UserAgent.html">Mojo::UserAgent</a>で大きなファイルをダウンロードする場合、メモリ使用量を心配する必要はまったくありません。250KB以上のものはすべてが自動的に一時ファイルにストリーミングされ、<a href="/Mojo::Message.html">Mojo::Message</a>の<code>"save_to"</code>で永続ファイルに移動できるからです。</p>

<pre>use Mojo::UserAgent;

# 最新のMojolicious tarballを取得する
my $ua = Mojo::UserAgent-&gt;new(max_redirects =&gt; 5);
my $tx = $ua-&gt;get('https://www.github.com/mojolicious/mojo/tarball/master');
$tx-&gt;result-&gt;save_to('mojo.tar.gz');</pre>

<p>極端に大きいファイルから保護するために、デフォルトで2GBの制限もあります。上限サイズは<a href="/Mojo::UserAgent.html">Mojo::UserAgent</a>の<code>"max_response_size"</code>属性で調整できます。</p>

<pre># 上限を10GBに増やす
$ua-&gt;max_response_size(10737418240);</pre>

<h4><a class='u'
name="_"
>大きなファイルのアップロード</a></h4>

<p>大きなファイルのアップロードはさらに簡単です。</p>

<pre>use Mojo::UserAgent;

# POST と "multipart/form-data" 経由でファイルをアップロード
my $ua = Mojo::UserAgent-&gt;new;
$ua-&gt;post('example.com/upload' =&gt;
  form =&gt; {image =&gt; {file =&gt; '/home/sri/hello.png'}});</pre>

<p>ここでもメモリ使用量を心配する必要はなく、すべてのデータがファイルから直接ストリーミングされます。</p>

<h4><a class='u'
name="_"
>ストリーミングレスポンス</a></h4>

<p>ストリーミングレスポンスの受信は、多くのHTTPクライアントで非常に難しくなりがちですが、<a href="/Mojo::UserAgent.html">Mojo::UserAgent</a>では実に簡単です。</p>

<pre>use Mojo::UserAgent;

# 不定サイズのレスポンスを受け入れる
my $ua = Mojo::UserAgent-&gt;new(max_response_size =&gt; 0);

# 通常のトランザクションを立てる
my $tx = $ua-&gt;build_tx(GET =&gt; 'http://example.com');

# "read"イベントを置き換えて、デフォルトのコンテントパーサーを無効にする
$tx-&gt;res-&gt;content-&gt;unsubscribe('read')-&gt;on(read =&gt; sub {
  my ($content, $chunk) = @_;
  say "Streaming: $chunk";
});

# トランザクションの処理
$tx = $ua-&gt;start($tx);</pre>

<p><a href="/Mojo::Content.html">Mojo::Content</a>の<code>"read"</code>イベントが受信されるすべてのデータチャンクに対して発行されます。チャンク転送エンコードやgzipコンテンツエンコードも、必要に応じて透過的に処理されます。</p>

<h4><a class='u'
name="_"
>ストリーミングリクエスト</a></h4>

<p>ストリーミングリクエストを送るのもほとんど同じくらい簡単です。</p>

<pre>use Mojo::UserAgent;

# 通常のトランザクションを立てる
my $ua = Mojo::UserAgent-&gt;new;
my $tx = $ua-&gt;build_tx(GET =&gt; 'http://example.com');

# ボディを準備する
my $body = 'Hello World!';
$tx-&gt;req-&gt;headers-&gt;content_length(length $body);

# 排出コールバックに直接書き込みを開始する
my $drain;
$drain = sub {
  my $content = shift;
  my $chunk = substr $body, 0, 1, '';
  $drain = undef unless length $body;
  $content-&gt;write($chunk, $drain);
};
$tx-&gt;req-&gt;content-&gt;$drain;

# トランザクションの処理
$tx = $ua-&gt;start($tx);</pre>

<p><a href="/Mojo::Content.html">Mojo::Content</a>の<code>"write"</code>に渡されるドレインコールバックは、前のデータチャンク全体が実際に書き込まれるたびに実行されます。</p>

<h4><a class='u'
name="_"
>ノンブロッキング</a></h4>

<p><a href="/Mojo::UserAgent.html">Mojo::UserAgent</a>はノンブロッキングとしてゼロから設計されており、ブロッキングAPI全体は単に便宜的なラッパーです。特に、ウェブクローリングのような待ち時間が大きな処理では、同時に多くの並列接続をアクティブに保つことができて非常に便利です。</p>

<pre>use Mojo::UserAgent;
use Mojo::IOLoop;

# 並列のノンブロッキングリクエスト
my $ua = Mojo::UserAgent-&gt;new;
$ua-&gt;get('https://metacpan.org/search?q=mojo' =&gt; sub {
  my ($ua, $mojo) = @_;
  say $mojo-&gt;result-&gt;dom-&gt;at('title')-&gt;text;
});
$ua-&gt;get('https://metacpan.org/search?q=minion' =&gt; sub {
  my ($ua, $minion) = @_;
  say $minion-&gt;result-&gt;dom-&gt;at('title')-&gt;text;
});

# 必要であればイベントループを開始
Mojo::IOLoop-&gt;start unless Mojo::IOLoop-&gt;is_running;</pre>

<p>ただし、1つのサーバーに対して同時に多くの接続を開かないでください。接続過多になる可能性があります。キューを使用して、リクエストを小さなバッチで処理する方が適切です。</p>

<pre>use Mojo::UserAgent;
use Mojo::IOLoop;

my @urls = (
  'mojolicious.org/perldoc/Mojo/DOM',  'mojolicious.org/perldoc/Mojo',
  'mojolicious.org/perldoc/Mojo/File', 'mojolicious.org/perldoc/Mojo/URL'
);

# 最大5つのリダイレクトに追跡するカスタム名を持つユーザーエージェント
my $ua = Mojo::UserAgent-&gt;new(max_redirects =&gt; 5);
$ua-&gt;transactor-&gt;name('MyParallelCrawler 1.0');

# 遅延を使用して、完了するまでイベントループを回し続ける
my $delay = Mojo::IOLoop-&gt;delay;
my $fetch;
$fetch = sub {

  # URLがなくなったら停止
  return unless my $url = shift @urls;

  # 次のタイトルを取得
  my $end = $delay-&gt;begin;
  $ua-&gt;get($url =&gt; sub {
    my ($ua, $tx) = @_;
    say "$url: ", $tx-&gt;result-&gt;dom-&gt;at('title')-&gt;text;

    # 次のリクエスト
    $fetch-&gt;();
    $end-&gt;();
  });
};

# 一度に2つのリクエストを処理する
$fetch-&gt;() for 1 .. 2;
$delay-&gt;wait;</pre>

<p>また、どんなときもサイトの<code>robots.txt</code>ファイルと利用規約を尊重し、同じホストへの接続を再度開く前には少し待つようにしましょう。そうでないと、管理者はアクセスをブロックせざるを得なくなるかもしれません。</p>

<h4><a class='u'
name="_"
>並列のブロッキングリクエスト</a></h4>

<p>これまでのサンプルですでに<a href="/Mojo::Promise.html">Mojo::Promise</a>の<code>"wait"</code>を見たことがあるかもしれません。これはノンブロッキング処理を移植可能にするために使用され、これらの処理を既に実行中のイベントループ内で動かしたり、必要に応じて開始したりできます。</p>

<pre>use Mojo::UserAgent;
use Mojo::Promise;

# ノンブロッキングリクエストをプロミスと同期する
my $ua = Mojo::UserAgent-&gt;new;
my $mojo   = $ua-&gt;get_p('https://metacpan.org/search?q=mojo');
my $minion = $ua-&gt;get_p('https://metacpan.org/search?q=minion');
Mojo::Promise-&gt;all($mojo, $minion)-&gt;then(sub {
  my ($mojo, $minion) = @_;
  say $mojo-&gt;result-&gt;dom-&gt;at('title')-&gt;text;
  say $minion-&gt;[0]-&gt;result-&gt;dom-&gt;at('title')-&gt;text;
})-&gt;wait;</pre>

<h4><a class='u'
name="WebSocket"
>WebSocket</a></h4>

<p>WebSocketはサーバー側だけのものではなく、<a href="/Mojo::UserAgent.html">Mojo::UserAgent</a>の<code>"websocket_p"</code>を使って、常にノンブロッキングで動く新しい接続を開くことができます。WebSocketハンドシェイクはHTTPを使用しています。また、通常の<code>GET</code>メソッドにいくつかヘッダーが追加されたリクエストです。ここにクッキーを含むこともできます。ハンドシェイクに続いて、サーバーからの<code>101</code>レスポンスによって、接続が確立したことがユーザーエージェントに通知されます。するとWebSocketプロトコルを使った双方向通信が開始します。</p>

<pre>use Mojo::UserAgent;
use Mojo::Promise;

# エコーサービスのためにWebSocketを開く
my $ua = Mojo::UserAgent-&gt;new;
$ua-&gt;websocket_p('ws://echo.websocket.org')-&gt;then(sub {
  my $tx = shift;

  # メッセージを待つことができるようにフォローアップ用のプロミスを準備する
  my $promise = Mojo::Promise-&gt;new;

  # WebSocketが閉じるのを待つ
  $tx-&gt;on(finish =&gt; sub {
    my ($tx, $code, $reason) = @_;
    say "WebSocket closed with status $code.";
    $promise-&gt;resolve;
  });

  # ひとつのメッセージを受け取った後にWebSocketを閉じる
  $tx-&gt;on(message =&gt; sub {
    my ($tx, $msg) = @_;
    say "WebSocket message: $msg";
    $tx-&gt;finish;
  });

  # サーバーにメッセージを送信
  $tx-&gt;send('Hi!');

  # 新しいプロミスをプロミスチェーンに挿入する
  return $promise;
})-&gt;catch(sub {
  my $err = shift;

  # 失敗したWebSocketハンドシェイクおよびその他の例外を処理する
  warn "WebSocket error: $err";
})-&gt;wait;</pre>

<h4><a class='u'
name="UNIX"
>UNIXドメインソケット</a></h4>

<p>TCP / IPソケットだけでなく、UNIXドメインソケットもサポートされています。これはプロセス間通信に使用すると、セキュリティとパフォーマンスの面で大きなメリットがあります。<code>http://</code>および<code>ws://</code>の代わりに<code>http+unix://</code>スキーマを使用できます。パーセントエンコードパス（<code>/</code>は<code>％2F</code>になる）をホストネームの代わりに渡します。</p>

<pre>use Mojo::UserAgent;
use Mojo::Promise;

# UNIXドメインソケット"/tmp/foo.sock"を介したGETリクエスト
my $ua = Mojo::UserAgent-&gt;new;
say $ua-&gt;get('http+unix://%2Ftmp%2Ffoo.sock/index.html')-&gt;result-&gt;body;

# UNIXドメインソケット "/tmp/bar.sock"を介したHOSTヘッダー付きのGETリクエスト
my $tx = $ua-&gt;get('http+unix://%2Ftmp%2Fbar.sock' =&gt; {Host =&gt; 'example.com'});
say $tx-&gt;result-&gt;body;

# UNIXドメインソケット "/tmp/baz.sock" を介したWebSocket接続
$ua-&gt;websocket_p('ws+unix://%2Ftmp%2Fbaz.sock/echo')-&gt;then(sub {
  my $tx = shift;

  my $promise = Mojo::Promise-&gt;new;
  $tx-&gt;on(finish =&gt; sub { $promise-&gt;resolve });

  $tx-&gt;on(message =&gt; sub {
    my ($tx, $msg) = @_;
    say "WebSocket message: $msg";
    $tx-&gt;finish;
  });
  $tx-&gt;send('Hi!');

  return $promise;
})-&gt;catch(sub {
  my $err = shift;
  warn "WebSocket error: $err";
})-&gt;wait;</pre>

<p><code>Host</code>ヘッダーを手動で設定してホスト名を渡すことができます。</p>

<h4><a class='u'
name="_"
>コマンドライン</a></h4>

<p>コマンドラインから巨大な HTML ファイルをチェックするのは嫌ですよね？コマンド<a href="/Mojolicious::Command::get.html">Mojolicious::Command::get</a>のおかげでそれは変わろうとしています。実際に重要な部分だけを<a href="/Mojo::DOM.html">Mojo::DOM</a>のCSSセレクターや<a href="/Mojo::JSON::Pointer.html">Mojo::JSON::Pointer</a>のJSONポインターで取り出せます。</p>

<pre>$ mojo get https://mojolicious.org 'head &gt; title'</pre>

<p>すべての id 属性のリストを見るには？</p>

<pre>$ mojo get https://mojolicious.org '*' attr id</pre>

<p>または、すべての見出しタグのテキスト内容は?</p>

<pre>$ mojo get https://mojolicious.org 'h1, h2, h3' text</pre>

<p>三番目の見出しのテキストは?</p>

<pre>$ mojo get https://mojolicious.org 'h1, h2, h3' 3 text</pre>

<p>ネストした子要素からもテキストをすべて抽出できます。</p>

<pre>$ mojo get https://mojolicious.org '#mojobar' all</pre>

<p>リクエストはカスタマイズすることもできます。</p>

<pre>$ mojo get -M POST -H 'X-Bender: Bite my shiny metal ass!' http://google.com</pre>

<p>レスポンスデータを<code>STDOUT</code> にリダイレクトして保存します。</p>

<pre>$ mojo get mojolicious.org &gt; example.html</pre>

<p>リクエストデータを<code>STDIN</code>にリダイレクトして渡します。</p>

<pre>$ mojo get -M PUT mojolicious.org &lt; example.html</pre>

<p>または、別のプログラムの出力を使用します。</p>

<pre>$ echo 'Hello World' | mojo get -M PUT https://mojolicious.org</pre>

<p><code>application/x-www-form-urlencoded</code>コンテンツとしてフォームを送信します。</p>

<pre>$ mojo get -M POST -f 'q=Mojo' -f 'size=5' https://metacpan.org/search</pre>

<p>さらに、<code>multipart/form-data</code>コンテンツとしてファイルをアップロードします。</p>

<pre>$ mojo get -M POST -f 'upload=@example.html' mojolicious.org</pre>

<p>リダイレクトを辿ってすべての (HTTP) ヘッダメッセージを見ることができます。</p>

<pre>$ mojo get -r -v http://google.com 'head &gt; title'</pre>

<p>JSONデータ構造から本当に必要な情報を抽出できます。</p>

<pre>$ mojo get https://fastapi.metacpan.org/v1/author/SRI /name</pre>

<p>アプリケーションのテストに真価を発揮するツールとなることでしょう。</p>

<pre>$ ./myapp.pl get /welcome 'head &gt; title'</pre>

<h4><a class='u'
name="_"
>ワンライナー</a></h4>

<p>手早くハックしたいとき、とくにテストのためには、<code>ojo</code>ワンライナーはすぐれた選択です。</p>

<pre>$ perl -Mojo -E 'say g("mojolicious.org")-&gt;dom-&gt;at("title")-&gt;text'</pre>

<h3><a class='u'
name="_"
>アプリケーション</a></h3>

<p>楽しい <a href="/Mojolicious.html">Mojolicious</a> アプリケーションはどんな場面でもハックが満載です。</p>

<h4><a class='u'
name="_"
>ベーシック認証</a></h4>

<p>ベーシック認証のデータは、<code>Authorization</code>ヘッダから自動的に抽出されます。</p>

<pre>use Mojolicious::Lite;
use Mojo::Util 'secure_compare';

get '/' =&gt; sub {
  my $c = shift;

  # ユーザー名"Bender"とパスワード"rocks"をチェック
  return $c-&gt;render(text =&gt; 'Hello Bender!')
    if secure_compare $c-&gt;req-&gt;url-&gt;to_abs-&gt;userinfo, 'Bender:rocks';

  # 認証を要求
  $c-&gt;res-&gt;headers-&gt;www_authenticate('Basic');
  $c-&gt;render(text =&gt; 'Authentication required!', status =&gt; 401);
};

app-&gt;start;</pre>

<p>TLSを一緒に使って安全に認証することもできます。</p>

<pre>$ ./myapp.pl daemon -l 'https://*:3000?cert=./server.crt&key=./server.key'</pre>

<h4><a class='u'
name="_"
>設定ファイルの追加</a></h4>

<p>構成ファイルをアプリケーションに追加するのは、ファイルをホームディレクトリに追加して<a href="/Mojolicious::Plugin::Config.html">Mojolicious::Plugin::Config</a>プラグインをロードするのと同じくらい簡単です。デフォルト名は<a href="/Mojolicious.html">Mojolicious</a>の<code>"moniker"</code>（C <myapp> ）に<code>.conf</code>拡張子を付け足したものになります（C <myapp.conf> ）。</p>

<pre>$ mkdir myapp
$ cd myapp
$ touch myapp.pl
$ chmod 744 myapp.pl
$ echo '{name =&gt; "my Mojolicious application"};' &gt; myapp.conf</pre>

<p>構成ファイル自体は、選択した構成設定を含むハッシュ参照を返す単なるPerlスクリプトです。これらの設定はすべて、メソッド<a href="/Mojolicious.html">Mojolicious</a>の<code>"config"</code>と<a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>"config"</code> で利用できます。</p>

<pre>use Mojolicious::Lite;

plugin 'Config';

my $name = app-&gt;config('name');
app-&gt;log-&gt;debug("Welcome to $name");

get '/' =&gt; 'with_config';

app-&gt;start;
__DATA__;
@@ with_config.html.ep
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;title&gt;&lt;%= config 'name' %&gt;&lt;/title&gt;&lt;/head&gt;
  &lt;body&gt;Welcome to &lt;%= config 'name' %&gt;&lt;/body&gt;
&lt;/html&gt;</pre>

<p>または、<a href="/Mojolicious::Plugin::JSONConfig.html">Mojolicious::Plugin::JSONConfig</a>でJSON形式の設定ファイルを使用することもできます。</p>

<h4><a class='u'
name="_"
>アプリケーションにプラグインを追加</a></h4>

<p>コードをよく整理し、アプリケーションがヘルパーでごちゃごちゃになるのを防ぐために、アプリケーションを指定してプラグインを作成できます。</p>

<pre>$ mkdir -p lib/MyApp/Plugin
$ touch lib/MyApp/Plugin/MyHelpers.pm</pre>

<p>通常のプラグインと同じように動き、<a href="/Mojolicious::Plugin.html">Mojolicious::Plugin</a>のサブクラスにもなっています。プラグインの名前にプレフィックスを付け、ヘルパーをネストさせると、簡単に衝突を避けることができます。</p>

<pre>package MyApp::Plugin::MyHelpers;
use Mojo::Base 'Mojolicious::Plugin';

sub register {
  my ($self, $app) = @_;
  $app-&gt;helper('my_helpers.render_with_header' =&gt; sub {
    my ($c, @args) = @_;
    $c-&gt;res-&gt;headers-&gt;header('X-Mojo' =&gt; 'I &lt;3 Mojolicious!');
    $c-&gt;render(@args);
  });
}

1;</pre>

<p>アプリケーション固有のプラグインはいくつでも使用できますが、通常のプラグインとの唯一の違いは、ロードするために完全なクラス名を使用するところです。</p>

<pre>use Mojolicious::Lite;

use lib 'lib';

plugin 'MyApp::Plugin::MyHelpers';

get '/' =&gt; sub {
  my $c = shift;
  $c-&gt;my_helpers-&gt;render_with_header(text =&gt; 'I ♥ Mojolicious!');
};

app-&gt;start;</pre>

<p>もちろん、これらのプラグインにはヘルパー以外のものを含めることができます。<a href="/Mojolicious::Plugins.html">Mojolicious::Plugins</a>の<code>"PLUGINS"</code>にいくつかサンプルがあります。</p>

<h4><a class='u'
name="Mojolicious"
>Mojoliciousにコマンドを追加</a></h4>

<p>おそらくこれまでに、<a href="/Mojolicious::Commands.html">Mojolicious::Commands</a>にある組み込みコマンドを多く使ったことでしょう。でも、新しいコマンドを追加するだけで、自動的にコマンドラインインターフェイスから使えるようになることは知っていましたか？ そのためにはコマンドを<code>@INC</code>が参照するディレクトリに追加します。</p>

<pre>package Mojolicious::Command::spy;
use Mojo::Base 'Mojo::Command';

has description =&gt; 'Spy on application';
has usage       =&gt; "Usage: APPLICATION spy [TARGET]\n";

sub run {
  my ($self, @args) = @_; 

  # シークレットパスフレーズを漏らす
  if ($args[0] eq 'secrets') { say for @{$self-&gt;app-&gt;secrets} }

  # モードを漏らす
  elsif ($args[0] eq 'mode') { say $self-&gt;app-&gt;mode }
}

1;</pre>

<p>コマンドライン引数はそのまま渡され、<a href="/Mojolicious::Command.html">Mojolicious::Command</a>には、使用したりオーバーロードでる多くの便利な属性とメソッドがあります。</p>

<pre>$ mojo spy secrets
HelloWorld

$ ./script/myapp spy secrets
secr3t</pre>

<p>また、指定のアプリケーションでコマンドを使うようには、<a href="/Mojolicious::Commands.html">Mojolicious::Commands</a>の<code>"namespaces"</code>にカスタム名前空間を追加するだけです。このとき、<a href="/MyApp::Command::spy.html">MyApp::Command::spy</a>の代わりに<a href="/Mojolicious::Command::spy.html">Mojolicious::Command::spy</a>のように名前を付けてください。</p>

<pre># アプリケーション
package MyApp;
use Mojo::Base 'Mojolicious';

sub startup {
  my $self = shift;

  # コマンドを読み込む名前空間を追加
  push @{$self-&gt;commands-&gt;namespaces}, 'MyApp::Command';
}

1;</pre>

<p>オプション<code>-h</code> / <code>-help</code>、<code>-home</code>および<code>-m</code> / <code>-mode</code>は、<a href="/Mojolicious::Commands.html">Mojolicious::Commands</a>によって自動的に処理され、すべてのコマンドで共有されます。</p>

<pre>$ ./script/myapp spy -m production mode
production</pre>

<p>共有オプションの全一覧は、<a href="/Mojolicious::Commands.html">Mojolicious::Commands</a>の<code>"SYNOPSIS"</code>を見てください。</p>

<h4><a class='u'
name="_"
>アプリケーションに対してコードを実行する</a></h4>

<p>あなたの<a href="/Mojolicious.html">Mojolicious</a>アプリケーションをテストするために、ささっとワンライナーを走らせたいと思ったことはありますか？コマンド<a href="/Mojolicious::Command::eval.html">Mojolicious::Command::eval</a>を使うと、まさにこれが実現できます。アプリケーションオブジェクト自体には<code>app</code>を通じてアクセスできます。</p>

<pre>$ mojo generate lite_app myapp.pl
$ ./myapp.pl eval 'say for @{app-&gt;static-&gt;paths}'
$ ./myapp.pl eval 'say for sort keys %{app-&gt;renderer-&gt;helpers}'</pre>

<p><code>verbose</code>オプションで、返り値またはPerlのデータ構造を<code>STDOUT</code>に自動的に出力できます。</p>

<pre>$ ./myapp.pl eval -v 'app-&gt;static-&gt;paths-&gt;[0]'
$ ./myapp.pl eval -v 'app-&gt;static-&gt;paths-&gt;[0]'</pre>

<h4><a class='u'
name="_"
>アプリケーションをインストール可能できるようにする</a></h4>

<p><a href="/Mojolicious.html">Mojolicious</a>アプリケーションをCPANにリリースしたいと思ったことはありますか？これは思ったよりも簡単にできます。</p>

<pre>$ mojo generate app MyApp
$ cd my_app
$ mv public lib/MyApp/
$ mv templates lib/MyApp/</pre>

<p>コツは<code>public</code>と<code>templates</code>ディレクトリを移動させ、モジュールとともに自動的にインストールされるようにすることです。<a href="/Mojolicious::Command::Author.html">Mojolicious::Command::Author</a>名前空間から追加される作成者コマンドは、通常、インストールされたアプリケーションには不要なので、除外できます。</p>

<pre># アプリケーション
package MyApp;
use Mojo::Base 'Mojolicious';

use Mojo::File 'path';
use Mojo::Home;

# CPANモジュールには常にバージョンが必要です
our $VERSION = '1.0';

sub startup {
  my $self = shift;

  # インストール可能なホームディレクトリへ切替
  $self-&gt;home(Mojo::Home-&gt;new(path(__FILE__)-&gt;sibling('MyApp')));

  # インストール可能な "public" ディレクトリへ切替
  $self-&gt;static-&gt;paths-&gt;[0] = $self-&gt;home-&gt;child('public');

  # インストール可能な "templates" ディレクトリへ切替
  $self-&gt;renderer-&gt;paths-&gt;[0] = $self-&gt;home-&gt;child('templates');

  # 作成者コマンドを除外
  $self-&gt;commands-&gt;namespaces(['Mojolicious::Commands']);

  my $r = $self-&gt;routes;
  $r-&gt;route('/welcome')-&gt;to('example#welcome');
}

1;</pre>

<p>最後に、アプリケーションスクリプトに小さな変更を1つ加えるだけです。シェバン行は、推奨される<code>#!perl</code>になり、これはインストール中にツールチェーンによって適切なshebangに書き換えることができます。</p>

<pre>#!perl

use strict;
use warnings;

use FindBin;
BEGIN { unshift @INC, "$FindBin::Bin/../lib" }
use Mojolicious::Commands;

# アプリケーションのためにコマンドラインインターフェイスを開始
Mojolicious::Commands-&gt;start_app('MyApp');</pre>

<p>これが本当に全部です。これで他のCPAN モジュールのようにアプリケーションをパッケージすることができます。</p>

<pre>$ ./script/my_app generate makefile
$ perl Makefile.PL
$ make test
$ make manifest
$ make dist</pre>

<p>また、PAUSEアカウントを持っている場合（<a href="/http://pause.perl.org.html">http://pause.perl.org</a>でリクエストできます）アップロードすることもできます。</p>

<pre>$ mojo cpanify -u USER -p PASS MyApp-0.01.tar.gz</pre>

<h4><a class='u'
name="Hello_World"
>Hello World</a></h4>

<p>1バイトも無駄にしたくないのであれば、これが<a href="/Mojolicious::Lite.html">Mojolicious::Lite</a>で作ることのできる最小の<code>Hello World</code>アプリケーションです。</p>

<pre>use Mojolicious::Lite;
any {text =&gt; 'Hello World!'};
app-&gt;start;</pre>

<p>パターンがない場合、ルートはすべてデフォルトで <code>/</code> となり、ルータによって コードが実際には実行されなくとも自動レンダリングが開始します。レンダラは、スタッシュから <code>text</code> の値を拾い、レスポンスを生成します。</p>

<h4><a class='u'
name="Hello_World_"
>Hello World ワンライナー</a></h4>

<p>上記の<code>Hello World</code>の例は、<a href="/ojo.html">ojo</a>ワンライナーを使うともう少し短くできます。</p>

<pre>$ perl -Mojo -E 'a({text =&gt; "Hello World!"})-&gt;start' daemon</pre>

<p>そしてすべてのコマンドが <a href="/Mojolicious::Commands.html">Mojolicious::Commands</a>から使用できます。</p>

<pre>$ perl -Mojo -E 'a({text =&gt; "Hello World!"})-&gt;start' get -v /</pre>

<h3><a class='u'
name="_"
>もっと学ぶには</a></h3>

<p>さあ、<a href="/Mojolicious::Guides.html">Mojolicious::Guides</a> を続けるか、<a href="http://github.com/mojolicious/mojo/wiki">Mojolicious wiki</a>を見てみましょう。多くの著者がドキュメントやサンプルをたくさん書いています。</p>

<h3><a class='u'
name="_"
>サポート</a></h3>

<p>このドキュメントでわからない部分があれば、 <a href="http://groups.google.com/group/mojolicious">mailing list</a> か<code>irc.freenode.net</code> (<a href="https://kiwiirc.com/nextclient/#irc://irc.freenode.net/mojo?nick=guest-?" class="podlinkurl"
>chat now!</a>)の公式IRCチャンネル <code>#mojo</code> まで気軽に質問してください。(2019/11/28 Mojolicious 8.12を反映)</p>

<!-- end doc -->

</body></html>

  </div>
  <div class="bottom">
    <h3>関連情報</h3>

<div style="margin:10px 0">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4525414114581084"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block"
     data-ad-format="autorelaxed"
     data-ad-client="ca-pub-4525414114581084"
     data-ad-slot="9163995495"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>

  </div>
</div>

        </div>
        <div class="side">
          
        </div>
      </div>
      <div class="footer">
        <div class="footer-services">
  <ul>
    <li><a href="https://perlzemi.com/">Perlゼミ</a></li>
    <li><a href="https://en.perlzemi.com/">Perl ABC</a></li>
    <li><a rel="nofollow" href="/list.html">新着情報</a></li>
    <li><a rel="nofollow" href="https://perlclub.net/sites">無料Web講座</a></li>
    <li><a rel="nofollow" href="https://perlclub.net/book">書籍・電子書籍</a></li>
    <li><a rel="nofollow" href="https://twitter.com/perlzemi">Twitter</a>
    <li><a rel="nofollow" href="https://www.youtube.com/channel/UCbeAS6ZXpSKqkzb-Nykb0ZQ">Youtube</a>
  </ul>
</div>

<div class="perlri_link">
  <a rel="nofollow" href="https://perlclub.net">Perlクラブ</a>
</div>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4525414114581084"
     crossorigin="anonymous"></script>
     
      </div>
    </div>
  </body>
</html>
