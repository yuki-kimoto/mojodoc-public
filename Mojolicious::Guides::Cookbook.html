<!DOCTYPE html>
<html>
  <head>
    <!-- meta -->
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0">
<link rel="icon" type="image/x-icon" href="/images/giblog-logo.png">
<link rel="stylesheet" type="text/css" href="/css/common.css">

<title> - Mojoliciousドキュメント 日本語訳</title>
<meta name="description" content="Mojoliciosuガイド">
  </head>
  <body>
    <div class="container">
      <div class="header">
        <!-- header -->
<div class="main">
  <h1>
    <a href="/">Mojoliciousドキュメント 日本語訳</a>
  </h1>
</div>

      </div>
      <div class="main">
        <div class="content">
          <div class="entry">
  <div class="top">
    <!-- top -->

  </div>
  <div class="middle">
    <html><head><title>名前</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.40,
  using Pod::Simple::PullParser v3.40,
  under Perl v5.028000 at Tue Apr  7 04:08:47 2020 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<p><a href="/Home.html">Mojoliciosuガイド</a></p>

<h1><a href="/Mojolicious::Guides::Cookbook.html"></a><a class='u'
name="_"
>名前</a></h1>

<p>Mojolicious::Guides::Cookbook - クックブック</p>

<h1><a class='u'
name="_"
>概観</a></h1>

<p><a href="/Mojolicious.html">Mojolicious</a>で料理するための、あらゆる風味のレシピ。</p>

<h1><a class='u'
name="_"
>デプロイメント</a></h1>

<p><a href="/Mojolicious.html">Mojolicious</a> と <a href="/Mojolicious::Lite.html">Mojolicious::Lite</a> アプリケーションをさまざまな プラットフォームで実行させます。 多くのリアルタイムWebフレームワークは、 <a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>のイベントループに基づいているので、 組み込みWebサーバーのうちのひとつを使わなければ、 イベントループの機能を完全には引き出せないことに注意してください。</p>

<h2><a class='u'
name="_"
>組み込みサーバ</a></h2>

<p><a href="/Mojolicious.html">Mojolicious</a> は、とてもポータブルな HTTP 1.1 準拠のウェブサーバを 含んでいます。これは通常、開発時に利用されますが、小から中規模の アプリケーションであれば、十分に堅固で速いです。</p>

<pre>$ ./script/my_app daemon
Server available at http://127.0.0.1:3000</pre>

<p>多くの設定オプションがあり、Perl が実行できるすべてのプラットフォームで 実行できることが知られています。</p>

<p><a href="/Mojolicious::Command::daemon.html">Mojolicious::Command::daemon</a>コマンドを通して、 すべてのアプリケーションが利用可能です。 アプリケーションは多くの設定オプションをもち Perlが動くシングルプロセスのアーキテクチャを持つ すべてのプラットフォームで動くことが知られています。</p>

<pre>$ ./script/my_app daemon -h
...List of available options...</pre>

<p>もうひとつの大きな利点は、そのままで TLS と WebSoket をサポートして いることです。テスト目的のための開発証明書が適切に組み込まれているので、うまく動きます。 しかし、<a href="/Mojo::Server::Daemon.html">Mojo::Server::Daemon</a>の<code>listen</code>によってサポートされている すべてのリッスンの位置を指定することができます。</p>

<pre>$ ./script/my_app daemon -l https://[::]:3000
Server available at https://[::]:3000.</pre>

<p>UNIXプラットフォームでは、加えて<a href="/Mojo::Server::Prefork.html">Mojo::Server::Prefork</a>によるプリフォークサーバーを追加で利用でき、 <a href="/Mojolicious::Command::prefork.html">Mojolicious::Command::prefork</a>を使って、複数プロセスアークテクチャに切り替えることができます。 これは複数CPUコアとコピーオンライトメモリ管理を利用できる利点を持っています。</p>

<pre>$ ./script/my_app prefork
Server available at http://127.0.0.1:3000</pre>

<p>組み込みのWebサーバーは<a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>のイベントループに基づいているので、 ノンブロッキングの処理をスケールするのに最適です。 けれども、アプリケーションが多くのブロッキング処理を実行する必要があるならば、 それぞれのワーカーが処理を行えるように、 ワーカープロセスを増やして、ひとつのワーカーあたりが同時に処理できる接続数を減らすことができます。 (<code>1</code>程度に小さく)</p>

<pre>$ ./script/my_app prefork -m production -w 10 -c 1
Server available at http://127.0.0.1:3000</pre>

<p>スタートアップの間にマネージャプロセスにおいて、 アプリケーションが事前ロードされます。 これは、イベントループを開始しないので、 新しいワーカープロセスがフォークされ、イベントループの開始するときは いつでも、 <a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>の<code>next_tick</code>を使用することができます。</p>

<pre>use Mojolicious::Lite;

Mojo::IOLoop->next_tick(sub {
  app->log->info("Worker $$ star...ALL GLORY TO THE HYPNOTOAD!");
});

get '/' => {text => 'Hello Wor...ALL GLORY TO THE HYPNOTOAD!'};</pre>

<h2><a class='u'
name="Morbo"
>Morbo</a></h2>

<p><a href="/Mojolicious::Guides::Tutorial.html">Mojolicious::Guides::Tutorial</a>読んだら、 <a href="/Mojo::Server::Morbo.html">Mojo::Server::Morbo</a>に親しんでください。</p>

<pre>Mojo::Server::Morbo
+- Mojo::Server::Daemon</pre>

<p>基本的には、プロジェクトで変更されたファイルを検知して、 新しい<a href="/Mojo::Server::Daemon.html">Mojo::Server::Daemon</a>をフォークするリスターターです。 ですので、開発モードだけで利用するようにしてください。</p>

<pre>$ morbo script/my_app
Server available at http://127.0.0.1:3000.</pre>

<h2><a class='u'
name="Hypnotoad"
>Hypnotoad</a></h2>

<p>より大きなアプリケーションのため、 <a href="/Mojolicious.html">Mojolicious</a> は UNIX に最適化された プレフォーキングウェブサーバ <a href="/Mojo::Server::Hypnotoad.html">Mojo::Server::Hypnotoad</a> を含んでいます。 これにより、あなたは複数の CPU コアと書き込み時コピー (copy-on-write) を利用でき、数千の並列クライアントの受け入れまでスケールアップすることができます。</p>

<pre>Mojo::Server::Hypnotoad
|- Mojo::Server::Daemon [1]
|- Mojo::Server::Daemon [2]
|- Mojo::Server::Daemon [3]
`- Mojo::Server::Daemon [4]</pre>

<p>これは<a href="/Mojo::Server::Prefork.html">Mojo::Server::Prefork</a> Webサーバーを基礎にしていおり、 <a href="/Mojo::Server::Daemon.html">Mojo::Server::Daemon</a>にプリフォーク機能を追加するものですが、 プロダクション環境において、特別に最適化されています。 アプリケーションを開始するには、<a href="/hypnotoad.html">hypnotoad</a>スクリプトを使用します。 これは、ポート<code>8080</code>でリッスンし、サーバープロセスを 自動的にデーモン化し、for <a href="/Mojolicious.html">Mojolicious</a>と <a href="/Mojolicious::Lite.html">Mojolicious::Lite</a>アプリケーション のモードを<code>production</code>にします。</p>

<pre>$ hypnotoad ./script/my_app</pre>

<p>書かれたアプリケーションから、<a href="/Mojo.html">Mojo</a>の<code>config</code>を使って、多くのコンフィグの設定をすることができます。 すべての設定のリストは<a href="/Mojo::Server::Hypnotoad.html">Mojo::Server::Hypnotoad</a>の設定の項目をみてください.</p>

<pre>use Mojolicious::Lite;

app->config(hypnotoad => {listen => ['http://*:3000']});

get '/' => {text => 'ALL GLORY TO THE HYPNOTOAD!'};

app->start;</pre>

<p><a href="/Mojolicious::Plugin::Config.html">Mojolicious::Plugin::Config</a>か<a href="/Mojolicious::Plugin::JSONConfig.html">Mojolicious::Plugin::JSONConfig</a>の設定ファイルに<code>hypnotoad</code>セクションを追加することもできます。</p>

<pre># myapp.conf
{
  hypnotoad => {
    listen  => ['https://*:443?cert=/etc/server.crt&key=/etc/server.key'],
    workers => 10
  }
};</pre>

<p>しかし、最も大きい利点の一つは、ダウンタイムがないソフトウェア更新(ホットデプロイメント)を サポートしていることです。 これは、実行時にサーバを止めたり、ただ一つの接続要求も失ったり することなく、ただコマンドを再実行するだけで <a href="/Mojolicious.html">Mojolicious</a> や Perl、システムライブラリでさえ更新できることを意味しています。</p>

<pre>$ hypnotoad script/my_app
Starting hot deployment for Hypnotoad server 31841.</pre>

<p>リバースプロキシーの後ろで<code>Hypnotoad</code>を使っている場合は、プロキシのサーポートを有効にしたい かもしれません。<a href="/Mojolicious.html">Mojolicious</a>は<code>X-Forwarded-For</code>, <code>X-Forwarded-Proto</code> を自動的に検知します。</p>

<pre># myapp.conf
{hypnotoad => {proxy => 1}};</pre>

<p>スタートアップの間に、マネージャープロセスの中でアプリケーションのプリロードが行われます。 新しいワーカープロセスがフォークされたときに必ずコードを実行するために、 <a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>のタイマーを使うことができます。</p>

<pre>use Mojolicious::Lite;

Mojo::IOLoop->timer(0 => sub {
  app->log->info("Worker $$ star...ALL GLORY TO THE HYPNOTOAD!");
});

get '/' => {text => 'Hello Wor...ALL GLORY TO THE HYPNOTOAD!'};

app->start;</pre>

<h2><a class='u'
name="_"
>ゼロダウンタイムソフトウェアアップグレード</a></h2>

<p>上で見たように、Hypnotoadはゼロダウンタイムソフトウェアアップグレードのとても簡単な方法を提供します。 また、<code>SO_REUSEPORT</code>をサポートしているモダンなオペレーティングシステム上では、 組み込みのすべてのWebサーバーで機能する他の利用可能な方法もあります。</p>

<pre> $ ./script/my_app prefork -P /tmp/first.pid -l http://*:8080?reuse=1
 Server available at http://127.0.0.1:8080</pre>

<p>しなければならないことは、二つ目のWebサーバーを同じポートで起動して、 その後に、最初のWebサーバーを緩やかに停止することだけです。</p>

<pre>$ ./script/my_app prefork -P /tmp/second.pid -l http://*:8080?reuse=1
Server available at http://127.0.0.1:8080
$ kill -s TERM `cat /tmp/first.pid`</pre>

<p>両方のWebサーバーは<code>reuse</code>パラメーターで起動する必要があることを 覚えておいてください。</p>

<h2><a class='u'
name="Nginx"
>Nginx</a></h2>

<p>最近の最も人気のある構成の一つは、 Nginx のリバースプロキシの後ろに 組み込みプリフォークサーバを置くことです。 新しいバージョンではWebSocketもサポートしています。</p>

<pre>upstream myapp {
  server 127.0.0.1:8080;
}
server {
  listen 80;
  server_name localhost;
  location / {
    proxy_pass http://myapp;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
  }
}</pre>

<h2><a class='u'
name="Apache/mod_proxy"
>Apache/mod_proxy</a></h2>

<p>もうひとつのよいリバースプロキシはApacheの<code>mod_proxy</code>でしょう。 設定は上記のNginxにとてもよく似ています。</p>

<pre><VirtualHost *:80>
  ServerName localhost
  <Proxy *>
    Order deny,allow
    Allow from all
  </Proxy>
  ProxyRequests Off
  ProxyPreserveHost On
  ProxyPass / http://localhost:8080/ keepalive=On
  ProxyPassReverse / http://localhost:8080/
  RequestHeader set X-Forwarded-Proto "http"
</VirtualHost></pre>

<h2><a class='u'
name="Apache/CGI"
>Apache/CGI</a></h2>

<p><code>CGI</code>がサポートされており、あなたの <a href="/Mojolicious.html">Mojolicious</a> アプリケーションは <code>CGI</code> スクリプトとして実行されていることを 自動的に検知します。</p>

<pre>ScriptAlias / /home/sri/myapp/script/my_app</pre>

<h2><a class='u'
name="PSGI/Plack"
>PSGI/Plack</a></h2>

<p><a href="https://metacpan.org/pod/PSGI" class="podlinkpod"
>PSGI</a> は Perl ウェブフレームワークとサーバの間のインターフェースです。 <a href="https://metacpan.org/pod/Plack" class="podlinkpod"
>Plack</a> は PSGI ミドルウェア、ヘルパ、ウェブサーバへのアダプタを含む Perl モジュールとツールキットです。 <a href="https://metacpan.org/pod/PSGI" class="podlinkpod"
>PSGI</a> と <a href="https://metacpan.org/pod/Plack" class="podlinkpod"
>Plack</a> は Python の WSGI と Ruby の Rack に触発されています。 <a href="/Mojolicious.html">Mojolicious</a> アプリケーションは、 <a href="https://metacpan.org/pod/Plack" class="podlinkpod"
>Plack</a> でデプロイするのが とてつもなく簡単です。</p>

<pre>$ plackup ./script/my_app</pre>

<p><a href="https://metacpan.org/pod/Plack" class="podlinkpod"
>Plack</a> は、あなたが <code>FCGI</code>, <code>SCGI</code>, <code>mod_perl</code> などから 選択できるように、多くのサーバやプロトコルへのアダプタを提供します。 必ずアプリケーションのホームディレクトリから <code>plackup</code> を実行してください。 そうでないとライブラリが見つからないかもしれません。</p>

<pre>$ plackup ./script/my_app -s FCGI -l /tmp/myapp.sock</pre>

<p><code>plackup</code> はスクリプトをロードするのに奇妙なトリックを使っているため、 <a href="/Mojolicious.html">Mojolicious</a> がアプリケーションのホームディレクトリを常に検知できるとは 限りません。そのような場合は、単に <code>MOJO_HOME</code> 環境変数を使いましょう。 同じ理由で、<code>app->start</code> はアプリケーションのスクリプトの中の 最後の Perl の文である必要があります。</p>

<p><code>MOJO_REVERSE_PROXY</code>環境変数はプロキシのサポートのために 利用することができます。 これは<a href="/Mojolicious.html">Mojolicious</a>が自動的に、 <code>X-Forwarded-For</code>と<code>X-Forwarded-Proto</code> を見ることによって自動的に行います。</p>

<pre>$ MOJO_REVERSE_PROXY=1 plackup ./script/my_app</pre>

<p>古いサーバーのアダプタで、アプリケーションのホームディレクトリが、 正しく検地されなかった場合は、 <code>MOJO_HOME</code>環境変数を使用することができます。</p>

<pre>$ MOJO_HOME=/home/sri/my_app plackup ./script/my_app</pre>

<p>いくつかのサーバのアダプタは <code>.psgi</code> ファイルを要求するかもしれません。 そのような場合は、それらにアプリケーションのスクリプトを指定すれば よいだけです。なぜならスクリプトは <code>PLACK_ENV</code> 環境変数の存在を検知すると 自動的にそのように振舞うからです。</p>

<h2><a class='u'
name="Plack"
>Plackミドルウェア</a></h2>

<p><code>myapp.fcgi</code>などのラッパースクリプトは、デプロイメントとアプリケーションロジックを 分離するのにとてもよい方法です。</p>

<pre>#!/usr/bin/env plackup -s FCGI
use Plack::Builder;

builder {
  enable 'Deflater';
  require './script/my_app';
};</pre>

<p><a href="/Mojo::Server::PSGI.html">Mojo::Server::PSGI</a>は、ラップされたスクリプトにおいて、 アプリケーションをロードし、カスタマイズするために、直接利用できます。</p>

<pre>#!/usr/bin/env plackup -s FCGI
use Mojo::Server::PSGI;
use Plack::Builder;

builder {
  enable 'Deflater';
  my $server = Mojo::Server::PSGI->new;
  $server->load_app('./script/my_app');
  $server->app->config(foo => 'bar');
  $server->to_psgi_app;
};</pre>

<p>けれども、アプリケーションの中でミドルウェアを使うこともできます。</p>

<pre>use Mojolicious::Lite;
use Plack::Builder;

get '/welcome' => sub {
  my $c = shift;
  $c->render(text => 'Hello Mojo!');
};

builder {
  enable 'Deflater';
  app->start;
};</pre>

<h2><a class='u'
name="_"
>書き換え</a></h2>

<p>時には、あなたは、自分でサーバの設定を変えることができない ブラックボックス環境、または、 <code>X-*</code> ヘッダーで補助情報を伝える リバースプロキシの背後でアプリケーションをデプロイしなければ ならないかもしれません。 そのような場合、あなたは入ってくるリクエストを書き換えるのに <a href="/Mojolicious.html">Mojolicious</a>の<code>before_dispatch</code> フックを使用できます。</p>

<pre># "X-Forwarded-HTTPS"ヘッダーが"https"に設定されていた場合にスキーマを変更
$app->hook(before_dispatch => sub {
  my $c = shift;
  $c->req->url->base->scheme('https')
    if $c->req->headers->header('X-Forwarded-HTTPS');
});</pre>

<p>リバースプロキシは、通常はアプリケーションはデプロイされたパスの情報渡さないので、 やってくるリクエストのベースパスを書き換えることが一般的です。</p>

<pre># productionモードではパスの最初の部分とスラッシュをベースパスに移動
$app->hook(before_dispatch => sub {
  my $c = shift;
  push @{$c->req->url->base->path->trailing_slash(1)},
    shift @{$c->req->url->path->leading_slash(0)};
}) if $app->mode eq 'production';</pre>

<p><a href="/Mojo::URL.html">Mojo::URL</a>オブジェクトは扱いやすいです。 ルーティングの行き先を表現したURL (foo/bar?baz=yada)がいつでもベースURL(http://example.com/myapp/)からの相対的なものになるからです。このURLはは開発環境においての表現です。</p>

<h2><a class='u'
name="_"
>アプリケーションの埋め込み</a></h2>

<p>次から次へ、設定ファイル、データベース接続、他のスクリプトの中のヘルパーなどの<a href="/Mojolicious.html">Mojolicious</a>アプリケーションのパーツを再利用したくなるかもしれません。 次のような<a href="/Mojo::Server.html">Mojo::Server</a>をベースにしたモックサーバーで、それらを埋め込むことができます。</p>

<pre>use Mojo::Server;

# モックサーバーでアプリケーションをロード
my $server = Mojo::Server->new;
my $app = $server->load_app('./myapp.pl');

# 完全に初期化されたアプリケーションにアクセス
say $app->static->root;
say $app->config->{secret_identity};
say $app->dumper(just => 'a helper test');
say $app->build_controller->render_to_string(template => 'foo');</pre>

<p><a href="/Mojolicious::Plugin::Mount.html">Mojolicious::Plugin::Mount</a>プラグインを使えば、 複数のアプリケーションをひとつに結合して、一緒にデプロイすることができます。</p>

<pre>use Mojolicious::Lite;

plugin Mount => {'test1.example.com' => '/home/sri/myapp1.pl'};
plugin Mount => {'test2.example.com' => '/home/sri/myapp2.pl'};

app->start;</pre>

<h2><a class='u'
name="Web"
>Webサーバーの埋め込み</a></h2>

<p>組み込みのWebサーバー<a href="/Mojo::Server::Daemon.html">Mojo::Server::Daemon</a>を、 なんらの理由で新しいリアクターのバックエンドに統合できない外部のイベントループのような外部の環境に埋め込むために、 <a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>の<code>one_tick</code>を使用することもできます。</p>

<pre>use Mojolicious::Lite;
use Mojo::IOLoop;
use Mojo::Server::Daemon;

# 通常のアクション
get '/' => {text => 'Hello World!'};

# カスタムのdaemonでアプリケーションに接続
my $daemon =
  Mojo::Server::Daemon->new(app => app, listen => ['http://*:8080']);
$daemon->prepare_ioloop;

# 外部の環境から"one_tick"を繰り返し呼び出す
Mojo::IOLoop->one_tick while 1;</pre>

<h1><a class='u'
name="Web"
>リアルタイムWeb</a></h1>

<p>リアルタイムWebはComet(ロングポーリング), イベントソース、WebSocketを含むテクノロジーの集合のことです。 伝統的なプルモデルを頼りにする代わりに、コンテンツを生成してすぐに、消費者にプッシュすることができます。 すべての組み込みサーバーはノンブロッキングI/Oを使っていて、 <a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>のリアクターをベースにしています。 多くの強力な機能によって、リアルタイムWebアプリケーションを 数千の並列のクライアントにスケールアップすることができるでしょう。</p>

<h2><a class='u'
name="Web"
>Webサービスのバックエンド</a></h2>

<p>Since <a href="/Mojo::UserAgent.html">Mojo::UserAgent</a>は<a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>のリアクターをベースに作られているので、 ノンブロッキングで利用されるとき、たとえば高いレイテンシのバックエンドWebサーバーであっても、 組み込みのWebサーバーをブロックしません。</p>

<pre>use Mojolicious::Lite;

# MetaCPANで「mojolicious」を検索
get '/' => sub {
  my $c = shift;
  $c->ua->get('api.metacpan.org/v0/module/_search?q=mojolicious' => sub {
    my ($ua, $tx) = @_;
    $c->render('metacpan', hits => $tx->res->json->{hits}{hits});
  });
};

app->start;
__DATA__

@@ metacpan.html.ep
<!DOCTYPE html>
<html>
  <head><title>MetaCPAN results for "mojolicious"</title></head>
  <body>
    % for my $hit (@$hits) {
      <p><%= $hit->{_source}{release} %></p>
    % }
  </body>
</html></pre>

<h2><a class='u'
name="_"
>同期イベント</a></h2>

<p>並列リクエストのような複数のイベントは<a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>の<code>delay</code>で簡単に同期させることができます。 これは、継続パススタイルを使って、ネストされた深いクロージャーを避けるのに役立ちます。</p>

<pre>use Mojolicious::Lite;
use Mojo::URL;

# MetaCPANで"mojo"と"mango"を検索
get '/' => sub {
  my $c = shift;

  # ふたつのステップででレスポンスを準備
  $c->delay(

    # 並列リクエスト
    sub {
      my $delay = shift;
      my $url   = Mojo::URL->new('api.metacpan.org/v0/module/_search');
      $url->query({sort => 'date:desc'});
      $c->ua->get($url->clone->query({q => 'mojo'})   => $delay->begin);
      $c->ua->get($url->clone->query({q => 'minion'}) => $delay->begin);
    },

    # 遅らせた描画
    sub {
      my ($delay, $mojo, $minion) = @_;
      $c->render(json => {
        mojo   => $mojo->res->json('/hits/hits/0/_source/release'),
        minion => $minion->res->json('/hits/hits/0/_source/release')
    }
  );
};

app->start;</pre>

<h2><a class='u'
name="_"
>タイマー</a></h2>

<p><a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>イベントループの主要なもうひとつの機能はタイマーです。 このタイマーは、<a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>の<code>timer</code>によって生成することができ、 たとえば、レスポンスの遅らせた描画に利用することができます。 <code>sleep</code>とことなって、並列に処理される他のリクエストがブロックされることはありません。</p>

<pre>use Mojolicious::Lite;
use Mojo::IOLoop;

# レスポンスを描画する前に3秒待つ
get '/' => sub {
  my $c = shift;
  Mojo::IOLoop->timer(3 => sub {
    $c->render(text => 'Delayed by 3 seconds!');
  });
};

app->start;</pre>

<p><a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>の<code>recurring</code>によって生成された、 再燃タイマーはとても強力ですが、 手動で停止させる必要があります。 そうでなければ、それらはイベントを発行し続けます。</p>

<pre>use Mojolicious::Lite;
use Mojo::IOLoop;

# ふたつめのステップで、5から1まで数える
get '/' => sub {
  my $c = shift;

  # 再燃タイマーを開始
  my $i = 1;
  my $id = Mojo::IOLoop->recurring(1 => sub {
    $c->write_chunk($i);
    $c->finish if $i++ == 5;
  });

  # 再燃タイマーを停止
  $c->on(finish => sub { Mojo::IOLoop->remove($id) });
};

app->start;</pre>

<p>タイマーは特定のリクエストに紐づけられていないので、 スタートアップ時に生成することもできます。</p>

<pre> use Mojolicious::Lite;
 use Mojo::IOLoop;

 # 10秒ごとにバックグラウンドでタイトルをチェック
 my $title = 'Got no title yet.';
 Mojo::IOLoop->recurring(10 => sub {
   app->ua->get('http://mojolicio.us' => sub {
     my ($ua, $tx) = @_;
     $title = $tx->res->dom->at('title')->text;
   });
 });

 # 現在のタイトルを表示
 get '/' => sub {
   my $c = shift;
   $c->render(json => {title => $title});
 };

 app->start;</pre>

<p>すべてのイベントは、協調的に処理されることを覚えておいてください。 ですので、コールバックで長くブロックしてはいけません。</p>

<h2><a class='u'
name="_"
>イベントの中での例外</a></h2>

<p>タイマーと他のノンブロッキング処理は、単一のイベントループの中で 実行されているので、 アプリケーションの外側において、 コールバックの中で投げられた例外は、 自動的にキャッチすることができません。 けれども、<a href="/Mojo::Reactor.html">Mojo::Reactor</a>の<code>error</code>イベントを購読することによって、 手動で処理することができます。また、コールバックの中では、キャッチすることができます。</p>

<pre>use Mojolicious::Lite;
use Mojo::IOLoop;

# アプリケーションのログにエラーメッセージをフォワードする
Mojo::IOLoop->singleton->reactor->on(error => sub {
  my ($reactor, $err) = @_;
  app->log->error($err);
});

# 例外だけをロギング (と、接続のタイムアウト)
get '/connection_times_out' => sub {
  my $c = shift;
  Mojo::IOLoop->timer(2 => sub {
    die 'This request will not be getting a response';
  });
};

# 例外が捕らえられ、処理される
get '/catch_exception' => sub {
  my $c = shift;
  Mojo::IOLoop->timer(2 => sub {
    eval { die 'This request will be getting a response' };
    $c->reply->exception($@) if $@;
  });
};

app->start;</pre>

<p>すべてのエラーは、警告に変換される、デフォルトのサブスクライバーが、 通常、フォールバックとして<a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>に追加されます。</p>

<pre>Mojo::IOLoop->singleton->reactor->unsubscribe('error');</pre>

<p>開発中、あるいは、クラッシュが単に好ましいアプリケーションにおいては、 すべてのサブスクライバーを取り除くことによって、 コールバックの中で投げられる、すべての例外を、致命的なものにすることができます。</p>

<h2><a class='u'
name="WebSocketWeb"
>WebSocketによるWebサービス</a></h2>

<p>WebSocketプロトコルは、サーバーとクライアントの間での、双方向でレイテンシーの低いコミュニケーションチャンネルです。 メッセージの受け取りは、トランザクションの<a href="/Mojo::Transaction::WebSocket.html">Mojo::Transaction::WebSocket</a>の <code>message</code>イベントを<a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>on</code>で購読するだけなのでとても簡単です。</p>

<pre>use Mojolicious::Lite;

# ブラウザ側のコードによるテンプレート
get '/' => 'index';

# WebSocketのエコーサービス
websocket '/echo' => sub {
  my $c = shift;

  # 接続された
  $c->app->log->debug('WebSocket opened');

  # 接続のために少しだけインアクティビティタイムアウトを増やす
  $c->inactivity_timeout(300);

  # やってきたメッセージ
  $c->on(message => sub {
    my ($c, $msg) = @_;
    $c->send("echo: $msg");
  });

  # 接続が閉じられた
  $c->on(finish => sub {
    my ($c, $code, $reason) = @_;
    $c->app->log->debug("WebSocket closed with status $code");
  });
};

app->start;
__DATA__

@@ index.html.ep
<!DOCTYPE html>
<html>
  <head><title>Echo</title></head>
  <body>
    <script>
      var ws = new WebSocket('<%= url_for('echo')->to_abs %>');

      // やってきたメッセージ
      ws.onmessage = function(event) {
        document.body.innerHTML += event.data + '<br/>';
      };

      // でていくメッセージ
      window.setInterval(function () { ws.send('Hello Mojo!') }, 1000);
    </script>
  </body>
</html></pre>

<p><a href="/Mojo::Transaction::WebSocket.html">Mojo::Transaction::WebSocket</a>の<code>finish</code>イベントはWebSocketの接続が閉じられた直後に発行されます。</p>

<pre>$c->tx->with_compression;</pre>

<p>You can activate <code>permessage-deflate</code> compression with <a href="/Mojo::Transaction::WebSocket.html">Mojo::Transaction::WebSocket</a>の<code>with_compression</code>を使って、 <code>permessage-deflate</code>圧縮を有効にすることができます。 これはパフォーマンスを改善しますが、接続あたりのメモリ少量が300KB増えます。</p>

<h2><a class='u'
name="WebSocket"
>WebSocketの試験</a></h2>

<p>WebSocketの接続の上でのメッセージのやり取りは動的なものですが、 しばしば予測可能なものです。 これはむしろうれしいことで、<a href="/Test::Mojo.html">Test::Mojo</a>のAPIが利用できます。</p>

<pre>use Test::More;
use Test::Mojo;

# アプリケーションを含む
use FindBin;
require "$FindBin::Bin/../echo.pl";

# エコーWebサービスの試験
my $t = Test::Mojo->new;
$t->websocket_ok('/echo')
  ->send_ok('Hello Mojo!')
  ->message_ok
  ->message_is('echo: Hello Mojo!')
  ->finish_ok;

# JSON Webサービスの試験
$t->websocket_ok('/echo.json')
  ->send_ok({json => {test => [1, 2, 3]}})
  ->message_ok
  ->json_message_is('/test', [1, 2, 3])
  ->finish_ok;

done_testing();</pre>

<h2><a class='u'
name="Web"
>イベントソースによるWebサービス</a></h2>

<p>HTML5のイベントソースはロングポーリング(<a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>write</code>を使うなど)の特別な形式で、 サーバーからクライアントへDOMイベントを直接送信することができます。 これは一方行なので、クライアントからサーバーへのデータの送信は、 Ajaxリクエストを使う必要があります。 しかしながら、利点は、HTTPプロトコルを透過的に再利用しているので、 低レベルのインフラしか必要としないことです。</p>

<pre>use Mojolicious::Lite;

# ブラウザサイドのコードによるテンプレート
get '/' => 'index';

# ログメッセージのためのイベントソース
get '/events' => sub {
  my $c = shift;

  # 接続のタイムアウトを少し増加させる
  $c->inactivity_timeout(300);

  # コンテンツタイプを変更して、レスポンスヘッダをファイナライズ
  $c->res->headers->content_type('text/event-stream');
  $c->write;

  # "message"イベントを購読紙、"log"イベントをブラウザに送る
  my $cb = $c->app->log->on(message => sub {
    my ($log, $level, $message) = @_;
     $c->write("event:log\ndata: [$level] @lines\n\n");
  });

  # 終わったら、"message"イベントを購読するのを再びやめる
   $c->on(finish => sub {
    my $c = shift;
    $c->app->log->unsubscribe(message => $cb);
  });
};

app->start;
__DATA__

@@ index.html.ep
<!DOCTYPE html>
<html>
  <head><title>LiveLog</title></head>
  <body>
    <script>
      var events = new EventSource('<%= url_for 'events' %>');

      // Subscribe to "log" event
      events.addEventListener('log', function(event) {
        document.body.innerHTML += event.data + '<br/>';
      }, false);
    </script>
  </body>
</html></pre>

<p><a href="/Mojo::Log.html">Mojo::Log</a>の<code>message</code>イベントは、新しいログメッセージ毎に放出され、 <a href="/Mojo::Transaction.html">Mojo::Transaction</a>の<code>finish</code>イベントはトランザクションが終了したときに放出されます。</p>

<h2><a class='u'
name="_"
>マルチパートアップロードのストリーミング</a></h2>

<p><a href="/Mojolicious.html">Mojolicious</a>は<a href="/Mojo::EventEmitter.html">Mojo::EventEmitter</a>をベースにしたとても洗練されたイベントシステムで、 ほとんどすべての層でイベントをすぐに使えます。 協力してWeb開発におけるもっとも難しい部類に入る問題を解決することができるでしょう。</p>

<pre>use Mojolicious::Lite;
use Scalar::Util 'weaken';

# マルチパートアップロードの間に入って、
# チャンクを受け取るするごとにログを出力する
hook after_build_tx => sub {
  my $tx = shift;

  # マルチパートアップロードを識別して「upgrade」イベントを購読
  weaken $tx;
  $tx->req->content->on(upgrade => sub {
    my ($single, $multi) = @_;
    return unless $tx->req->url->path->contains('/upload');

    # 正しいものを発見するために「part」イベントを購読
    $multi->on(part => sub {
      my ($multi, $single) = @_;

      # すべてのヘッダの存在を確実なものにするために、「body」イベントを購読
      $single->on(body => sub {
        my $single = shift;

        # 正しいパーツを持っていることを確実にし、「read」イベントを購読
        return unless $single->headers->content_disposition =~ /example/;
        $single->unsubscribe('read')->on(read => sub {
          my ($single, $bytes) = @_;

          # 受け取ったすべてのチャンクのサイズをログに出力
          app->log->debug(length($bytes) . ' bytes uploaded');
        });
      });
    });
  });
};

# DATAセクションのフォームをアップロード
get '/' => 'index';

# マルチパートアップロードをストリーミング
post '/upload' => {text => 'Upload was successful.'};

app->start;
__DATA__

@@ index.html.ep
<!DOCTYPE html>
<html>
  <head><title>Streaming multipart upload</title></head>
  <body>
    %= form_for upload => (enctype => 'multipart/form-data') => begin
      %= file_field 'example'
      %= submit_button 'Upload'
    % end
  </body>
</html></pre>

<h2><a class='u'
name="_"
>イベントループ</a></h2>

<p>内部的に<a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>リアクターは複数のイベントループのバックエンドを利用できます。 たとえば<a href="https://metacpan.org/pod/EV" class="podlinkpod"
>EV</a>はインストールされていれば自動的に利用されます。 <a href="https://metacpan.org/pod/AnyEvent" class="podlinkpod"
>AnyEvent</a>のようなイベントループも正しく動かすことができます。</p>

<p>だれがイベントループのバックエンドをコントロールするかは重要ではありません。</p>

<pre>use Mojo::UserAgent;
use EV;
use AnyEvent;

# MetaCPANで"mojolicious"を検索
my $cv = AE::cv;
my $ua = Mojo::UserAgent->new;
$ua->get('api.metacpan.org/v0/module/_search?q=mojolicious' => sub {
  my ($ua, $tx) = @_;
  $cv->send($tx->res->json('/hits/hits/0/_source/release'));
});
say $cv->recv;</pre>

<p>たとえば、組み込みのWebサーバーを<a href="/AnyEvent.html">AnyEvent</a>アプリケーションに組み込むこともできます。</p>

<pre>use Mojolicious::Lite;
use Mojo::Server::Daemon;
use EV;
use AnyEvent;

# 通常のアクション
get '/' => {text => 'Hello World!'};

# アプリケーションをWebサーバーで接続して、接続の受付を開始
my $daemon
  = Mojo::Server::Daemon->new(app => app, listen => ['http://*:8080']);
$daemon->start;

# AnyEventにコントロールさせる
AE::cv->recv;</pre>

<h1><a class='u'
name="_"
>ユーザーエージェント</a></h1>

<p>我々が <a href="/Mojolicious.html">Mojolicious</a> はウェブフレームワークであると言うとき、 我々は本当にそう言っています。 <a href="/Mojo::UserAgent.html">Mojo::UserAgent</a>は完全の機能を持ったHTTPとWebSocketのユーザーエージェントです。</p>

<h2><a class='u'
name="_"
>ウェブスクレイピング</a></h2>

<p>ウェブサイトから情報をスクレイピングするのが以前にこれほど面白かったことは ありません。 組込みの XML/HTML5 パーサ <a href="/Mojo::DOM.html">Mojo::DOM</a> は[[Mojo::Message]の<code>dom</code>を 通して利用可能で、 スタンドアロンパーサに理解できる 全ての CSS3 セレクタをサポートします。 特にWebアプリケーションをテストするための強力とツールとなります。</p>

<pre>use Mojo::UserAgent;

# Webサイトをフェッチ
my $ua = Mojo::UserAgent->new;
my $tx = $ua->get('mojolicio.us/perldoc');

# ファイルを抽出
say 'Title: ', $tx->res->dom->at('head > title')->text;

# ヘッドを抽出
$tx->res->dom('h1, h2, h3')->each(sub { say 'Heading: ', shift->all_text });

# テキストより多くの者を抽出するためにすべてのノードを再帰的に訪れる
  for my $n ($tx->res->dom->descendant_nodes->each) {
  # テキストかCDATAノード
  print $n->content if $n->type eq 'text' || $n->type eq 'cdata';

  # 画像のための代わりのテキストをインクルード
  print $n->{alt} if $n->type eq 'tag' && $n->tag eq 'img';
}</pre>

<p>特に、あなたの <a href="/Mojolicious.html">Mojolicious</a> アプリケーションの単体テストでは、 これは非常に強力なツールとなり得ます。</p>

<h2><a class='u'
name="JSON_"
>JSON ウェブサービス</a></h2>

<p>最近のほとんどのウェブサービスは、 JSON データ交換フォーマットを ベースにしています。 それで、<a href="/Mojolicious.html">Mojolicious</a> には、おそらく最速の pure-Perl 実装である <a href="/Mojo::JSON.html">Mojo::JSON</a> が組み込まれています。</p>

<pre>use Mojo::UserAgent;
use Mojo::URL;

# 新しいユーザーエージェント
my $ua = Mojo::UserAgent->new;

# MetaCPANで"mojolicious"を検索して、最新のリリースをリストする
my $url = Mojo::URL->new('http://api.metacpan.org/v0/release/_search');
$url->query({q => 'mojolicious', sort => 'date:desc'});
for my $hit (@{$ua->get($url)->res->json->{hits}{hits}}) {
  say "$hit->{_source}{name} ($hit->{_source}{author})";
}</pre>

<h2><a class='u'
name="_"
>ベーシック認証</a></h2>

<p>ユーザ名とパスワードを URL に追加するだけです。 <code>Authorization</code>ヘッダーは、自動的に生成されます。</p>

<pre>my $ua = Mojo::UserAgent->new;
say $ua->get('https://sri:secret@mojolicio.us/hideout')->res->body;</pre>

<h2><a class='u'
name="_"
>追加リクエストを装飾</a></h2>

<p><a href="/Mojo::UserAgent.html">Mojo::UserAgent</a> は自動的にリダイレクトを辿ることができ、 <code>start</code>イベントによって、トランザクションが初期化された後、 接続がそれらに関連づけられる前に、それぞれのトランザクションへの 直接アクセスを可能にします。</p>

<pre># 10 までのリダイレクトを追跡するユーザーエージェント
my $ua = Mojo::UserAgent->new(max_redirects => 10);

# 各リクエストに気の利いたヘッダを追加
$ua->on(start => sub {
  my ($ua, $tx) = @_;
  $tx->req->headers->header('X-Bender' => 'Bite my shiny metal ass!');
  say 'Request: ', $tx->req->url->clone->to_abs;
});

# リダイレクトされるであろうリクエスト
say 'Title: ', $ua->get('google.com')->res->dom->at('head > title')->text;</pre>

<p>これはプロキシへの <code>CONNECT</code> リクエストに対してでさえも動作します。</p>

<h2><a class='u'
name="_"
>コンテンツジェネレーター</a></h2>

<p>複数のリクエストに対して、繰り返し同じ種類のコンテンツを生成できます。</p>

<pre>use Mojo::UserAgent;
use Mojo::Asset::File;

# "stream"ジェネレーターを生成
my $ua = Mojo::UserAgent->new;
$ua->transactor->add_generator(stream => sub {
  my ($transactor, $tx, $path) = @_;
  $tx->req->content->asset(Mojo::Asset::File->new(path => $path));
});

# PUTとPOSTを通して複数のファイルのストリーミングを送信
$ua->put('http://example.com/upload'  => stream => '/home/sri/mojo.png');
$ua->post('http://example.com/upload' => stream => '/home/sri/minion.png');</pre>

<p><code>json</code>と<code>form</code>コンテンツジェネレーターがいつでも利用可能です。</p>

<pre>use Mojo::UserAgent;

# PATCHを使って"application/json"コンテンツを送信
my $ua = Mojo::UserAgent->new;
my $tx = $ua->patch('http://api.example.com' => json => {foo => 'bar'});

# GETを通してクエリパラメーターを送信
my $tx2 = $ua->get('http://search.example.com' => form => {q => 'test'});

# POSTを通して"application/x-www-form-urlencoded"コンテンツを送信
my $tx3 = $ua->post('http://search.example.com' => form => {q => 'test'});

# PUTを通して"multipart/form-data"コンテンツを送信
my $tx4 = $ua->put('http://upload.example.com' =>
  form => {test => {content => 'Hello World!'}});</pre>

<p>コンテンツジェネレーターのより多くの情報については、 <a href="/Mojo::UserAgent::Transactor.html">Mojo::UserAgent::Transactor</a>の<code>tx</code>を見てください。</p>

<h2><a class='u'
name="_"
>大きなファイルのダウンロード</a></h2>

<p><a href="/Mojo::UserAgent.html">Mojo::UserAgent</a> で大きなファイルをダウンロードするときは、 <code>250KB</code> を越えるものすべてを自動的に一時ファイルに流すので、 メモリ使用量を心配する必要は全くありません。 ファイルを永続的に移動させるのに<a href="/Mojo::Asset::File.html">Mojo::Asset::File</a>の<code>move_to</code> を利用することができます。</p>

<pre># 最新の Mojolicious tarball を取得しよう
my $ua = Mojo::UserAgent->new(max_redirects => 5);
my $tx = $ua->get('https://www.github.com/kraih/mojo/tarball/master');
$tx->res->content->asset->move_to('mojo.tar.gz');</pre>

<p>また、極端に大きなファイルからの保護のため、デフォルトで <code>16MB</code> の 大域的な限界があります。これは <a href="/Mojo::Message.html">Mojo::Message</a>の<code>max_message_size</code>か <code>MOJO_MAX_MESSAGE_SIZE</code> 環境変数で 調整することができます。</p>

<pre># 1GBに制限を増やす
$ENV{MOJO_MAX_MESSAGE_SIZE} = 1073741824;</pre>

<h2><a class='u'
name="_"
>大きなファイルのアップロード</a></h2>

<p>大きなファイルのアップロードはさらに簡単です。</p>

<pre>use Mojo::UserAgent;

# POST と "multipart/form-data" 経由でファイルをアップロード
my $ua = Mojo::UserAgent->new;
$ua->post('example.com/upload' =>
  form => {image => {file => '/home/sri/hello.png'}});</pre>

<p>メモリ使用量を心配する必要はなく、すべてのデータが ファイルから直接ストリーミングされるでしょう。</p>

<h2><a class='u'
name="_"
>ストリーミングレスポンス</a></h2>

<p>ほとんどの HTTP クライアントにおいて、ストリーミングレスポンスを 受け取るのは実に扱いにくい場合がありますが、 <a href="/Mojo::UserAgent.html">Mojo::UserAgent</a> はそれを本当に簡単にします。</p>

<pre># 通常のトランザクションを構築
my $ua = Mojo::UserAgent->new;
my $tx = $ua->build_tx(GET => 'http://mojolicio.us');

# 無限サイズのレスポンスを受け入れる
$tx->res->max_message_size(0);

# デフォルトのコンテントパーサーを無効にするために「read」イベントを置き換える
$tx->res->content->unsubscribe('read')->on(read => sub {
  my ($content, $chunk) = @_;
  say "Streaming: $chunk";
});

# トランザクションの処理
$tx = $ua->start($tx);</pre>

<p><a href="/Mojo::Content.html">Mojo::Content</a>の<code>read</code>イベントはデータの断片の到着毎に放出されます。 必要であればチャンクドエンコーディングは透過的に扱われるでしょう。</p>

<h2><a class='u'
name="_"
>ストリーミングリクエスト</a></h2>

<p>ストリーミングリクエストを送るのもほとんど同じくらい簡単です。</p>

<pre># 通常のトランザクションを構築
my $ua = Mojo::UserAgent->new;
my $tx = $ua->build_tx(GET => 'http://mojolicio.us');

# ボディの準備
my $body = 'Hello world!';
$tx->req->headers->content_length(length $body);

# 排出コールバックで直接書き込みを開始
my $drain;
$drain = sub {
  my $content = shift;
  my $chunk   = substr $body, 0, 1, '';
  $drain      = undef unless length $body;
  $content->write($chunk, $drain);
};
$tx->req->content->$drain;

# トランザクションの処理
$tx = $ua->start($tx);</pre>

<p><a href="/Mojo::Content.html">Mojo::Content</a>の<code>write</code>に渡された排出コールバックは、 前のチャンクの全部が実際に書き込まれるたびに、 呼び出されます。</p>

<h2><a class='u'
name="_"
>ノンブロッキング</a></h2>

<p><a href="/Mojo::UserAgent.html">Mojo::UserAgent</a> は根底からノンブロッキングになるように設計されており、 全てのノンブロッキングAPI はただの簡単で便利なラッパーです。 特に、ウェブクローリングのような待ち時間が大きな処理では、 同時に多くの並列接続をアクティブに保つことができるので、 これは非常に便利です。</p>

<pre>use Mojo::UserAgent;
use Mojo::IOLoop;

# 並列のノンブロッキングリクエスト
my $ua = Mojo::UserAgent->new;
$ua->get('http://metacpan.org/search?q=mojo' => sub {
  my ($ua, $mojo) = @_;
   ...
  say $mojo->res->dom->at('title')->text;
});
$ua->get('http://metacpan.org/search?q=minion' => sub {
  my ($ua, $minion) = @_;
  say $minion->res->dom->at('title')->text;
});

# 必要であればイベントループを開始
Mojo::IOLoop->start unless Mojo::IOLoop->is_running;</pre>

<p>あなたは <a href="/Mojo::IOLoop.html">Mojo::IOLoop</a> イベントループを完全に制御できます。</p>

<h2><a class='u'
name="_"
>並列のブロッキングリクエスト</a></h2>

<p>複数のノンブロッキングリクエストを同期させるために、 <a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>の<code>delay</code>を使うことによって、 ブロッキングの振る舞いをエミュレートすることができます。 結果のトランザクションは、ランダムな順であることに注目してください。</p>

<pre># 同期のノンブロッキングリクエストと結果のキャプチャ
my $ua    = Mojo::UserAgent->new;
my $delay = Mojo::IOLoop->delay;
$ua->get('http://mojolicio.us'         => $delay->begin);
$ua->get('http://mojolicio.us/perldoc' => $delay->begin);
my ($tx, $tx2) = $delay->wait;</pre>

<p><a href="/Mojo::IOLoop::Delay.html">Mojo::IOLoop::Delay</a>の<code>finish</code>は、 <a href="/Mojolicious.html">Mojolicious</a>アプリケーションの内部と同様にスタンドアロンで動かすことができなければならない コードのために利用されます。</p>

<pre>use Mojo::UserAgent;
use Mojo::IOLoop;

# ノンブロッキングリクエストを同期させる
my $ua    = Mojo::UserAgent->new;
my $delay = Mojo::IOLoop->delay(sub {
  my ($delay, $mojo, $minion) = @_;
  say $mojo->res->dom->at('title')->text;
  say $minion->res->dom->at('title')->text;
});
$ua->get('http://metacpan.org/search?q=mojo'   => $delay->begin);
$ua->get('http://metacpan.org/search?q=minion' => $delay->begin);
$delay->wait;</pre>

<p><a href="/Mojo::IOLoop::Delay.html">Mojo::IOLoop::Delay</a>の<code>wait</code>はこのコードをポータブルにします。 すでに実行されているイベントループの中、あるいは、 要求に応じて開始して、働きます。</p>

<h2><a class='u'
name="WebSockets"
>WebSockets</a></h2>

<p>WebSocketはサーバーサイドだけではなく、 新しいコネクションを開くために <a href="/Mojo::UserAgent.html">Mojo::UserAgent</a>の<code>websocket</code>を使用することができます。 これはいつでもノンブロッキングです。</p>

<p>ハンドシェイクは、いくらかの追加のヘッダーのついて、通常のHTTPリクエストです。 これは、クッキーを含むこともできます。 サーバーから<code>101</code>レスポンスの通知がユーザーエージェントに続いて送られます。 ユーザーエージェントの接続は確立され、 WebSocketプロトコルを使った通信が開始します。</p>

<pre> use Mojo::UserAgent;
 use Mojo::IOLoop;

 # エコーサービスのためにWebSocketを開く
 my $ua = Mojo::UserAgent->new;
 $ua->websocket('ws://echo.websocket.org' => sub {
   my ($ua, $tx) = @_;

   # WebSocketハンドシェイクが成功したかチェック
   say 'WebSocket handshake failed!' and return unless $tx->is_websocket;

   # WebSocketが閉じられるのを待つ
   $tx->on(finish => sub {
     my ($tx, $code, $reason) = @_;
     say "WebSocket closed with status $code.";
   });

   # ひとつのメッセージを受け取った後にWebSocketを閉じる
   $tx->on(message => sub {
     my ($tx, $msg) = @_;
     say "WebSocket message: $msg";
     $tx->finish;
   });

   # サーバーにメッセージを送信
   $tx->send('Hi!');
 });

 # 必要であればイベントループを開始
 Mojo::IOLoop->start unless Mojo::IOLoop->is_running;</pre>

<h2><a class='u'
name="_"
>コマンドライン</a></h2>

<p>コマンド行から膨大な HTML ファイルをチェックするのが嫌ではありませんか? ありがたいことに<a href="/Mojolicious::Command::get.html">Mojolicious::Command::get</a>はこの状況を一変させます。 <a href="/Mojo::DOM.html">Mojo::DOM</a> のCSS3 セレクタと<a href="/Mojo::JSON::Pointer.html">Mojo::JSON::Pointer</a>のJSONポインター で実際に重要な部分だけを選ぶことができます。</p>

<pre>$ mojo get http://mojolicio.us 'head > title'</pre>

<p>全ての id 属性のリストについてはどうですか?</p>

<pre>$ mojo get http://mojolicio.us '*' attr id</pre>

<p>または、全ての見出しタグのテキスト内容については?</p>

<pre>$ mojo get http://mojolicio.us 'h1, h2, h3' text</pre>

<p>おそらく三番目の見出しのテキストは?</p>

<pre>$ mojo get http://mojolicio.us 'h1, h2, h3' 3 text</pre>

<p>入れ子の子要素からも全てのテキストを抽出できます。</p>

<pre>$ mojo get http://mojolicio.us '#mojobar' all</pre>

<p>リクエストをカスタマイズすることもできます。</p>

<pre>$ mojo get -M POST -c 'Hello!' http://mojolicio.us
$ mojo get -H 'X-Bender: Bite my shiny metal ass!' http://google.com</pre>

<p>リダイレクトを辿り、全ての (HTTP) ヘッダメッセージを見ることができます。</p>

<pre>$ mojo get -r -v http://google.com 'head > title'</pre>

<p>JSONデータ構造から本当に必要な情報を抽出できます。</p>

<pre>$ mojo get https://api.metacpan.org/v0/author/SRI /name</pre>

<p>これはあなたのアプリケーションをテストするための非常に貴重な ツールかもしれません。</p>

<pre>$ ./myapp.pl get /welcome 'head > title'</pre>

<h2><a class='u'
name="_"
>ワンライナー</a></h2>

<p>試験のためのすばやいハックのために、<a href="/ojo.html">ojo</a>ワンライナーはすぐれた選択です。</p>

<pre>$ perl -Mojo -E 'say g("mojolicio.us")->dom->at("title")->text'</pre>

<h1><a class='u'
name="_"
>アプリケーション</a></h1>

<p>いつでもアプリケーションのハックを お楽しみ下さい。</p>

<h2><a class='u'
name="_"
>ベーシック認証</a></h2>

<p>ベーシック認証のデータは、<code>Authorization</code>ヘッダから、 自動的に抽出されます。</p>

<pre>use Mojolicious::Lite;

get '/' => sub {
  my $c = shift;

  # ユーザー名"Bender"とパスワード"rocks"をチェック
  return $c->render(text => 'Hello Bender!')
    if $c->req->url->to_abs->userinfo eq 'Bender:rocks';

  # 認証を要求
  $c->res->headers->www_authenticate('Basic');
  $c->render(text => 'Authentication required!', status => 401);
};

app->start;</pre>

<p>これは、安全な認証メカニズムのために、TLSを一緒に使うこともできます。</p>

<pre>$ ./myapp.pl daemon -l 'https://*:3000?cert=./server.crt&key=./server.key'</pre>

<h2><a class='u'
name="_"
>設定ファイルを追加</a></h2>

<p>アプリケーションに設定ファイルを追加するには ホームディレクトリに追加し、 <a href="/Mojolicious::Plugin::Config.html">Mojolicious::Plugin::Config</a>プラグインを読み込むだけです。 デフォルトの設定ファイル名は<a href="/Mojolicious.html">Mojolicious</a>の<code>moniker</code>の 値(<code>myapp</code>)に基づき、それに<code>.conf</code>を追加したもの(myapp.conf)になります。 プラグイン</p>

<pre>$ mkdir myapp
$ cd myapp
$ touch myapp.pl
$ chmod 744 myapp.pl
$ echo '{name => "my Mojolicious application"};' > myapp.conf</pre>

<p>設定ファイル単なるPerlのスクリプトです。 ハッシュリファレンスを返してください。 <a href="/Mojo.html">Mojo</a>の<code>config</code>メソッドを使って、 すべての設定が利用できます。 これは<a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>config</code>ヘルパーです。</p>

<pre> use Mojolicious::Lite;

 plugin 'Config';

 my $name = app->config('name');
 app->log->debug("Welcome to $name");

 get '/' => 'with_config';

 app->start;
 __DATA__
 @@ with_config.html.ep
 <!DOCTYPE html>
 <html>
   <head><title><%= config 'name' %></title></head>
   <body>Welcome to <%= config 'name' %></body>
 </html></pre>

<p>Alternatively you can also use configuration files in the JSON format with <a href="https://metacpan.org/pod/Mojolicious%3A%3APlugin%3A%3AJSONConfig" class="podlinkpod"
>Mojolicious::Plugin::JSONConfig</a>.</p>

<h2><a class='u'
name="_"
>アプリケーションにプラグインを追加</a></h2>

<p>コードをよりよくまとめ、アプリケーションの早口からヘルパーを守るために、 プラグインを作成することができます。</p>

<pre>$ mkdir -p lib/MyApp/Plugin
$ touch lib/MyApp/Plugin/MyHelpers.pm</pre>

<p>これは、通常のプラグイン、または、<a href="/Mojolicious::Plugin.html">Mojolicious::Plugin</a> のサブクラスとして、動作します。 プラグイン名にプレフィックスを使うことによって、ネストしたヘルパーを使って、 衝突を避けることができます。</p>

<pre>package MyApp::Plugin::MyHelpers;
use Mojo::Base 'Mojolicious::Plugin';

sub register {
  my ($self, $app) = @_;
  $app->helper('my_helpers.render_with_header' => sub {
    my ($c, @args) = @_;
    $c->res->headers->header('X-Mojo' => 'I <3 Mojolicious!');
    $c->render(@args);
  });
}

1;</pre>

<p>多くのアプリケーション限定のプラグインを持つことができませす。 通常のプラグインと異なる部分は、完全なクラス名を使って ロードする必要があることです。</p>

<pre>use Mojolicious::Lite;

use lib 'lib';

plugin 'MyApp::Plugin::MyHelpers';

get '/' => sub {
  my $c = shift;
  $c->my_helpers->render_with_header(text => 'I ♥ Mojolicious!');
};

app->start;</pre>

<p>もちろん、 これらのプラグインは、 ひとつ以上のヘルパーを 含むことができます。 より多くのアイデアは、 <a href="/Mojolicious::Plugins.html">Mojolicious::Plugins</a>にあります。</p>

<h2><a class='u'
name="Mojolicious"
>Mojoliciousにコマンドを追加</a></h2>

<p>おそらくこれまで、<a href="/Mojolicious::Commands.html">Mojolicious::Commands</a>で説明されている組み込みの多くのコマンドを使って きたのではないでしょうか。 でも、新しいコマンドを追加して、自動的にコマンドラインインターフェースに 加えることができるんです。</p>

<pre>package Mojolicious::Command::spy;
use Mojo::Base 'Mojo::Command';

has description => 'Spy on application';
has usage       => "Usage: APPLICATION spy [TARGET]\n";

sub run {
  my ($self, @args) = @_;

  # シークレットパスフレーズを出力
  say for @{$self->app->secrets} if $args[0] eq 'secrets';

  # モードの出力
  say $self->app->mode if $args[0] eq 'mode';
}

1;</pre>

<p><a href="/Mojo::Command.html">Mojo::Command</a>における多くの便利なメソッドと属性は オーバーライドすることが可能です。</p>

<pre>$ mojo spy secret
The secret of this application is "Mojolicious::Lite".

$ ./myapp.pl spy secret
The secret of this application is "secret".</pre>

<p>コマンドライン引数はすぐに渡され、すぐに使ってオーバーロードできる <a href="/Mojolicious::Command.html">Mojolicious::Command</a>の便利な属性とメソッドがあります。</p>

<pre> $ mojo spy secrets
 HelloWorld

 $ ./myapp.pl spy secrets
 secr3t</pre>

<p>コマンドアプリケーションを特別なものにするために カスタム名前空間を<a href="/Mojolicious::Commands.html">Mojolicious::Commands</a>の<code>namespaces</code> を使って追加できます。</p>

<pre># アプリケーション
package MyApp;
use Mojo::Base 'Mojolicious';

sub startup {
  my $self = shift;

  # コマンドが読み込まれる別の名前空間を追加
  push @{$self->commands->namespaces}, 'MyApp::Command';
}

1;</pre>

<p><code>-h</code>/<code>--help</code>, <code>--home</code>、<code>-m</code>/<code>--mode</code>コマンドは、 <a href="/Mojolicious::Commands.html">Mojolicious::Commands</a>によって、 自動的に処理され、 すべてのコマンドで共有されます。</p>

<pre>$ ./myapp.pl spy -m production mode
production</pre>

<p>すべての共有されるオプションの完全なリストは、 <a href="/Mojolicious::Commands.html">Mojolicious::Commands</a>の<code>使い方</code>をみてください。</p>

<h2><a class='u'
name="_"
>アプリケーションの上でコードを実行する</a></h2>

<p><a href="/Mojolicious.html">Mojolicious</a>アプリケーションの上で、すばやいワンライナーを実行することについて考えたことがありますか。 <a href="/Mojolicious::Command::eval.html">Mojolicious::Command::eval</a>コマンドでそれを実行することができ、アプリケーションのインスタンス自体には <code>app</code>でアクセスできます。</p>

<pre>$ mojo generate lite_app myapp.pl
$ ./myapp.pl eval 'say for @{app->static->paths}'</pre>

<p><code>verbose</code>オプションで、自動的に戻り値あるいはPerlのデータ構造を<code>STDOUT</code>に出力させることができます。</p>

<pre>$ ./myapp.pl eval -v 'app->static->paths->[0]'
$ ./myapp.pl eval -V 'app->static->paths'</pre>

<h2><a class='u'
name="_"
>あなたのアプリケーションをインストール可能に</a></h2>

<p>あなたの <a href="/Mojolicious.html">Mojolicious</a> アプリケーションを CPAN にリリースすることを これまで考えたことはありますか? それは実際、あなたが考えるよりはるかに簡単です。</p>

<pre>$ mojo generate app MyApp
$ cd my_app
$ mv public lib/MyApp/
$ mv templates lib/MyApp/</pre>

<p>トリックは、モジュールを自動的にインストールできるように、 <code>public</code>, <code>templates</code> ディレクトリを移動することにあります。</p>

<pre>package MyApp;
use Mojo::Base 'Mojolicious';

use File::Basename 'dirname';
use File::Spec::Functions 'catdir';

# 全ての CPAN モジュールはバージョンを必要とします。
our $VERSION = '1.0';

sub startup {
  my $self = shift;

  # インストール可能なホームディレクトリへ切替
  $self->home->parse(catdir(dirname(__FILE__), 'MyApp'));

  # インストール可能な "public" ディレクトリへ切替
  $self->static->paths->[0] = $self->home->rel_dir('public');

  # インストール可能な "templates" ディレクトリへ切替
  $self->renderer->paths->[0] = $self->home->rel_dir('templates');

  $self->plugin('PODRenderer');

  my $r = $self->routes;
  $r->route('/welcome')->to('example#welcome');
}

1;</pre>

<p>ついに、少しの小さな変更が、アプリケーションスクリプト になされました。 シェバングは、推奨される<code>#!perl</code>になりました。 これは、ツールチェーンが、 インストール中に適切なシェバングに書き換えるでしょう。 また、 インストール可能なスクリプトはアップデートされたデュアルライフモジュールを 壊さないように、 <a href="https://metacpan.org/pod/lib" class="podlinkpod"
>lib</a>よりも、<a href="https://metacpan.org/pod/FindBin" class="podlinkpod"
>FindBin</a>を使いましょう。</p>

<pre>#!perl

use strict;
use warnings;

use FindBin;
BEGIN { unshift @INC, "$FindBin::Bin/../lib" }

# アプリケーションのコマンドラインインターフェースを開始
require Mojolicious::Commands;
Mojolicious::Commands->start_app('MyApp');</pre>

<p>これが本当にすべてであり、今、あなたのアプリケーションは、他のいかなる CPAN モジュールのようにもパッケージすることができます。</p>

<pre>$ ./script/my_app generate makefile
$ perl Makefile.PL
$ make test
$ make manifest
$ make dist</pre>

<p>もしPAUSEアカウント(http://pause.perl.org)を持っていれば、 アップロードすることもできます。</p>

<pre>$ mojo cpanify -u USER -p PASS MyApp-0.01.tar.gz</pre>

<h2><a class='u'
name="Hello_World"
>Hello World</a></h2>

<p>データ量を問題とするなら、これが <a href="/Mojolicious::Lite.html">Mojolicious::Lite</a> で書ける最小の <code>Hello World</code> アプリケーションです。</p>

<pre>use Mojolicious::Lite;
any {text => 'Hello World!'};
app->start;</pre>

<p>パターンのない全てのルートはデフォルトで <code>/</code> となり、ルータによって 実際のコードが実行されなくとも自動レンダリングが始まるため、 これは動作します。 レンダラは、スタッシュから <code>text</code> の値を拾い、レスポンスを生成します。</p>

<h2><a class='u'
name="Hello_World_"
>Hello World ワンライナー</a></h2>

<p>上記の <code>Hello World</code> の例は、 <a href="/ojo.html">ojo</a> ワンライナーでさらに少しだけ 短くすることができます。</p>

<pre>$ perl -Mojo -E 'a({text => "Hello World!"})->start' daemon</pre>

<p>そして、 <a href="/Mojolicious::Commands.html">Mojolicious::Commands</a> からの全てのコマンドを使うことができます。</p>

<pre>$ perl -Mojo -E 'a({text => "Hello World!"})->start' get -v /</pre>

<h2><a class='u'
name="_"
>より学ぶには</a></h2>

<p><a href="/Mojolicious::Guides.html">Mojolicious::Guides</a>を学び続けてください。また<a href="http://github.com/kraih/mojo/wiki" class="podlinkurl"
>Mojolicious wiki</a>を見ることもできます。wikiには多くのユーザーによる多くのドキュメントやサンプルがあります。</p>

<h1><a class='u'
name="_"
>サポート</a></h1>

<p>ドキュメントに答えが見つからなくって質問があるときは、 <a href="http://groups.google.com/group/mojolicious" class="podlinkurl"
>メーリングリスト</a>か 公式のIRCチャンネルであるirc.perl.orgの#mojoでためらわずに質問してください。</p>

<p>(Mojolicious 6.05を反映)</p>

<!-- end doc -->

</body></html>

  </div>
  <div class="bottom">
    <!-- bottom -->

  </div>
</div>

        </div>
        <div class="side">
          <!-- side -->
<div class="side-list">
  <div class="side-list-title">
    Side Bar
  </div>
  <ul>
    <li><a href="/list.html">Entries</a></li>
    <li>Bar</li>
    <li>Baz</li>
  </ul>
</div>

        </div>
      </div>
      <div class="footer">
        <!-- footer -->
<a href="https://github.com/yuki-kimoto/giblog">Giblog</a>

      </div>
    </div>
  </body>
</html>
