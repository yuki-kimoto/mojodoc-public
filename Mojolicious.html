<!DOCTYPE html>
<html>
  <head>
    <!-- meta -->
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0">
<link rel="icon" type="image/x-icon" href="/images/giblog-logo.png">
<link rel="stylesheet" type="text/css" href="/css/common.css">

<title> - Mojoliciousドキュメント 日本語訳</title>
<meta name="description" content="Mojolicious API リファレンス">
  </head>
  <body>
    <div class="container">
      <div class="header">
        <!-- header -->
<div class="main">
  <h1>
    <a href="/">Mojoliciousドキュメント 日本語訳</a>
  </h1>
</div>

      </div>
      <div class="main">
        <div class="content">
          <div class="entry">
  <div class="top">
    <!-- top -->

  </div>
  <div class="middle">
    <html><head><title>名前</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.40,
  using Pod::Simple::PullParser v3.40,
  under Perl v5.028000 at Tue Apr  7 04:08:46 2020 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<p><a href="/Mojolicious API リファレンス.html">Mojolicious API リファレンス</a></p>

<h1><a href="/Mojolicious.html"></a><a class='u'
name="_"
>名前</a></h1>

<p>Mojolicious - リアルタイムWebフレームワーク</p>

<h1><a class='u'
name="_"
>使い方</a></h1>

<pre># アプリケーション
package MyApp;
use Mojo::Base 'Mojolicious';

# ルート(Route)
sub startup {
  my $self = shift;
  $self->routes->get('/hello')->to('foo#hello');
}

# コントローラー
package MyApp::Controller::Foo;
use Mojo::Base 'Mojolicious::Controller';

# アクション
sub hello {
  my $self = shift;
  $self->render(text => 'Hello World!');
}</pre>

<h1><a class='u'
name="_"
>説明</a></h1>

<p>強力なL <Mojo> Web上に構築された素晴らしいリアルタイムWebフレームワーク 開発ツールキット。 RESTfulなルート、プラグイン、コマンドをサポート Perl風のテンプレート、コンテンツネゴシエーション、セッション管理、フォーム検証、 テストフレームワーク、静的ファイルサーバ、<code>CGI</code>/<code>PSGI</code>検出、ファーストクラス のUnicodeサポート。より多くは、新名が発見してください。</p>

<p>素晴らしいドキュメントである<a href="/Mojolicious::Guides.html">Mojolicious::Guides</a>を見てください。</p>

<h1><a class='u'
name="_"
>フック</a></h1>

<p><a href="/Mojolicious.html">Mojolicious</a>は並べられた順で次のフックを発行します。</p>

<pre>$app->hook(after_dispatch => sub {...});</pre>

<h2><a class='u'
name="before_server_start"
>before_server_start</a></h2>

<p>アプリケーションサーバーが起動する直前に発行されます。 <a href="https://metacpan.org/pod/Mojo%3A%3AServer%3A%3ACGI" class="podlinkpod"
>Mojo::Server::CGI</a>を除くすべてのビルトインサーバーを含むサポートがあります。</p>

<pre>$app->hook(before_server_start => sub {
  my ($server, $app) = @_;
  ...
});</pre>

<p>アプリケーションサーバーを動的に再構成したり、サーバー診断情報を収集したりするのに便利です。 （サーバーとアプリケーションオブジェクトを渡します）</p>

<h2><a class='u'
name="after_build_tx"
>after_build_tx</a></h2>

<p>トランザクションが構築された直後、かつ HTTP リクエストが解析される前に 発生します。</p>

<pre>$app->hook(after_build_tx => sub {
  my ($tx, $app) = @_;
  ...
});</pre>

<p>これはとても強力なフックで簡単には利用されるべきではないでしょう。より進んだ機能としてアップロードの 進捗バーなどに利用できますが、埋め込まれたアプリケーションでは、 ホストアプリケーションだけが、トランザクションをビルドできるので、 機能しないということに 注意してください。 (トランザクションとアプリケーションのインスタンスが渡されます。)</p>

<h2><a class='u'
name="around_dispatch"
>around_dispatch</a></h2>

<p>新しいリクエストを受信した直後に発行され、ディスパッチプロセス全体をラップします。 ですので、チェーンを継続するためには、次のフックに手動で転送する必要があります。 。<a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の"reply->exception"は、チェーンにおける最初のフックで、 "reply->exception"の呼び出しが最後です。あなたのディスパッチは、この間に入ります。</p>

<pre>$app->hook(around_dispatch => sub {
  my ($next, $c) = @_;
  ...
  $next->();
  ...
});</pre>

<p>これは非常に強力なフックであり、安易に使用してはいけません。 たとえば、アプリケーション全体の例外処理をカスタマイズします。 あなたのツールボックスの中のハンマーと考えてください。 （次のフックにつながるコールバックと デフォルトのコントローラオブジェクトを渡します）</p>

<h2><a class='u'
name="before_dispatch"
>before_dispatch</a></h2>

<p>静的ファイルサーバーとルーターが仕事を開始する直前に発生します。</p>

<pre>$app->hook(before_dispatch => sub {
  my $c = shift;
  ...
});</pre>

<p>入ってくるリクエストや、その他の前処理タスクを書き換えるのにとても有用です。 (デフォルトのコントローラオブジェクトが渡されます)</p>

<h2><a class='u'
name="after_static"
>after_static</a></h2>

<p>静的ファイルサーバーが生成した静的ファイルの応答の後に発生します。</p>

<pre>$app->hook(after_static => sub {
  my $c = shift;
  ...
});</pre>

<p>ほとんどの場合は静的ファイルのレスポンスの後処理のために利用されます。 (デフォルトのコントローラーオブジェクトを渡されます。)</p>

<h2><a class='u'
name="before_routes"
>before_routes</a></h2>

<p>静的ファイルサーバーが静的ファイルをサーブすべきかどうか決定した後、 ルーターが仕事を開始する前に発生します。</p>

<pre>$app->hook(before_routes => sub {
  my $c = shift;
  ...
});</pre>

<p>ほとんどの場合はカスタムディスパッチャーのためか、 メトリクスを収集するために利用されます。 (デフォルトのコントローラーオブジェクトが渡されます。)</p>

<h2><a class='u'
name="around_action"
>around_action</a></h2>

<p>アクションが実行されたすぐ後にフックが発行され、それをラップします。 チェーンを続けたい場合は、次のフックヘ手動で進めなければなりません。 デフォルトのアクションのディスパッチはチェーンの最後のフックです。 あなたのものは、その前に実行されます。</p>

<pre>$app->hook(around_action => sub {
  my ($next, $c, $action, $last) = @_;
  ...
  return $next->();
});</pre>

<p>これはとても強力なフックで、軽い気持ちで利用されるべきではありません。 たとえば、追加の引数をアクションに渡したり、 戻り値を違った方法で処理したりすることができます。 (次のフックに導くコールバック、現在のコントローラーオブジェクト、 アクションコールバック、このアクションがエンドポイントである場合の フラグが渡されます。)</p>

<h2><a class='u'
name="before_render"
>before_render</a></h2>

<p>レンダラーによって生成されたコンテンツの前に、フックが発行されます。 このフックは動的な性質のために、順序がばらばらで呼びだれることに 注意してください。 埋め込みのアプリケーションでは、描画しているアプリケーションでだけ 動くでしょう。</p>

<pre>$app->hook(before_render => sub {
  my ($c, $args) = @_;
  ...
});</pre>

<p>ほとんどの場合、レンダラーに渡される引数を 事前に処理するために利用されます。 (現在のコントローラーオブジェクトと描画の引数が渡されます。)</p>

<h2><a class='u'
name="after_render"
>after_render</a></h2>

<p>部分的ではないコンテンツがレンダラーによって生成された後に発生します。 このフックは動的な性質のために、適切でなく実行される可能性があり、 埋め込みのアプリケーションの場合はレンダリングしているアプリケーションのため だけに働くことに注意してください。</p>

<pre>$app->hook(after_render => sub {
  my ($c, $output, $format) = @_;
  ...
});</pre>

<p>ほとんどの場合は、動的に生成されたコンテンツの後処理に利用されます。 (現在のコントローラーオブジェクト、コンテンツへのリファレンス、フォーマットが渡されます。)</p>

<h2><a class='u'
name="after_dispatch"
>after_dispatch</a></h2>

<p>描画されたコンテンツの後に、逆順で発生します。 このフックは動的な性質のために、適切でなく実行される可能性があり、 埋め込みのアプリケーションの場合はレンダリングしているアプリケーションのため だけに働くことに注意してください。</p>

<pre>$app->hook(after_dispatch => sub {
  my $c = shift;
  ...
});</pre>

<p>外にでていくレスポンスを再編集し、タスクを後処理するのに便利です。 (コントローラーオブジェクトが渡されます。)</p>

<h2><a class='u'
name="around_dispatch"
>around_dispatch</a></h2>

<p><code>before_dispatch</code>の直前に発生し、ディスパッチプロセス全体をラップします。 ですので、チェーンを続けたいときは手動で<code>next</code>フックを進めなければなりません。 <a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>reply->exception</code>によるデフォルトの例外処理は、 チェーンの最初フックと最後のディスパッチの呼び出しです。 あなたのものはその間にあります。</p>

<pre>$app->hook(around_dispatch => sub {
  my ($next, $c) = @_;
  $next->();
});</pre>

<p>これはとても強力なフックで簡単には利用されるべきではありませんが、 たとえば、アプリケーションの広い例外をカスタマイズすることができます。 ツールボックスの中でとても強力なものと考えられます。 (次のフックに続くクロージャーと現在のコントローラーのオブジェクトが渡されます。)</p>

<h1><a class='u'
name="_"
>属性</a></h1>

<p><a href="/Mojolicious.html">Mojolicious</a> は <a href="/Mojo.html">Mojo</a> から全ての属性を継承しており、 以下の新しい 属性を実装しています。</p>

<h2><a class='u'
name="commands"
>commands</a></h2>

<pre>my $commands = $app->commands;
$app         = $app->commands(Mojolicious::Commands->new);</pre>

<p>アプリケーションのためのコマンドラインインターフェース。 デフォルトは<a href="/Mojolicious::Commands.html">Mojolicious::Commands</a>オブジェクト。</p>

<pre># コマンドをロードするための他の名前空間
push @{$app->commands->namespaces}, 'MyApp::Command';</pre>

<h2><a class='u'
name="controller_class"
>controller_class</a></h2>

<pre>my $class = $app->controller_class;
$app      = $app->controller_class('Mojolicious::Controller');</pre>

<p>デフォルトのコントローラーとして利用されるクラスで、 デフォルトは <a href="/Mojolicious::Controller.html">Mojolicious::Controller</a> です。</p>

<h2><a class='u'
name="home"
>home</a></h2>

<pre>my $home = $app->home;
$app     = $app->home(Mojo::Home->new);</pre>

<p>アプリケーションのホームディレクトリで、デフォルトでは<a href="/Mojo::Home.html">Mojo::Home</a>オブジェクトです。 このオブジェクトは実際のパスに文字列化することができます。</p>

<pre># ホームディレクトリを基準にしたポータブルなパスを生成
my $path = $app->home->child('data', 'important.txt');</pre>

<h2><a class='u'
name="log"
>log</a></h2>

<pre>my $log = $app->log;
$app    = $app->log(Mojo::Log->new);</pre>

<p>アプリケーションのロギング層です。デフォルトでは<a href="/Mojo::Log.html">Mojo::Log</a>オブジェクトです。 レベルはデフォルトで<code>MOJO_LOG_LEVEL</code>環境変数か、モードが<code>development</code>なら<code>debug</code>、そうでない場合は、<code>info</code>になります。 すべてのメッセージは、<code>STDERR</code>か、<code>log</code>が存在していた場合は、<code>log/$mode.log</code>に出力されます。</p>

<pre># debugメッセージをログに出力
 $app->log->debug('It works!');</pre>

<h2><a class='u'
name="max_request_size"
>max_request_size</a></h2>

<pre>my $max = $app->max_request_size;
$app    = $app->max_request_size(16777216);</pre>

<p>リクエストの最大バイトサイズ。デフォルトは<a href="/Mojo::Message.html">Mojo::Message</a>の値です。値を<code>0</code>に設定すると、 リクエストに無限のサイズを許可します。この値を大きくすると劇的に、メモリ使用が増えることに注意してください。 たとえば、とても大きなリクエストボディを<a href="https://metacpan.org/pod/Mojo%3A%3AMessage" class="podlinkpod"
>Mojo::Message</a>の"dom"か<a href="https://metacpan.org/pod/Mojo%3A%3AMessage" class="podlinkpod"
>Mojo::Message</a>の"json"で解析を試みようとする場合などです。</p>

<h2><a class='u'
name="mode"
>mode</a></h2>

<pre>my $mode = $app->mode;
$app     = $app->mode('production');</pre>

<p>アプリケーションのオペレーションモード、 デフォルトは、<code>MOJO_MODE</code>と<code>PLACK_ENV</code>からの値、 あるいは<code>development</code>です。</p>

<h2><a class='u'
name="moniker"
>moniker</a></h2>

<pre>my $moniker = $app->moniker;
$app        = $app->moniker('foo_bar');</pre>

<p>このアプリケーションのモニカー。設定ファイルのためのデフォルトの ファイル名としてしばしば利用されます。 <a href="/Mojo::Util.html">Mojo::Util</a>の<code>decamelize</code>でアプリケーションクラスを デキャメライズしたものがデフォルトの値です。</p>

<h2><a class='u'
name="plugins"
>plugins</a></h2>

<pre>my $plugins = $app->plugins;
$app        = $app->plugins(Mojolicious::Plugins->new);</pre>

<p>プラグインマネージャー。デフォルトは <a href="https://metacpan.org/pod/Mojolicious%3A%3APlugins" class="podlinkpod"
>Mojolicious::Plugins</a> オブジェクトです。 通常はこれを気にしなくても構いません。</p>

<p>プラグインをロードしたいのであれば<code>plugin</code>メソッドを利用してください。</p>

<pre># プラグインをロードするための他の名前空間を追加
push @{$app->plugins->namespaces}, 'MyApp::Plugin';</pre>

<h2><a class='u'
name="renderer"
>renderer</a></h2>

<pre>my $renderer = $app->renderer;
$app         = $app->renderer(Mojolicious::Renderer->new);</pre>

<p>アプリケーションで内容を表示するのに使用され、デフォルトは <a href="/Mojolicious::Renderer.html">Mojolicious::Renderer</a>オブジェクトです。 コンテンツの生成に関するより多くの情報を得るには、 <a href="/Mojolicious::Guides::Rendering.html">Mojolicious::Guides::Rendering</a> を見てください。</p>

<pre># 圧縮を有効にする
$app->renderer->compress(1);

# 他の"templates"ディレクトリを追加
push @{$app->renderer->paths}, '/home/sri/templates';

# 優先順位の高い他の"templates"ディレクトリを追加
unshift @{$app->renderer->paths}, '/home/sri/themes/blue/templates';

# DATAセクションのテンプレートのための他のクラスを追加
push @{$app->renderer->classes}, 'Mojolicious::Plugin::Fun';</pre>

<h2><a class='u'
name="routes"
>routes</a></h2>

<pre>my $routes = $app->routes;
$app       = $app->routes(Mojolicious::Routes->new);</pre>

<p>ルートディスパッチャ。デフォルトは <a href="https://metacpan.org/pod/Mojolicious%3A%3ARoutes" class="podlinkpod"
>Mojolicious::Routes</a> オブジェクトです。 startup メソッドの中で、アプリケーションに URL のエンドポイントを 定義するために使用します。</p>

<pre># ルートの追加
my $r = $app->routes;
$r->get('/foo/bar')->to('test#foo', title => 'Hello Mojo!');
$r->post('/baz')->to('test#baz');

# コントローラーをロードするために他の名前空間を追加
push @{$app->routes->namespaces}, 'MyApp::MyController';</pre>

<h2><a class='u'
name="secrets"
>secrets</a></h2>

<pre>my $secrets = $app->secrets;
$app        = $app->secrets(['passw0rd']);</pre>

<p>署名付きクッキーのための秘密のパスフレーズで、 デフォルトはこのアプリケーションの<code>moniker</code>の値です。 これはあまりセキュアではありませんので、変更すべきです。 セキュアではないデフォルトを使っている限り、 ログファイルの中に、パスフレーズを変えるように思い起こさせる デバッグメッセージが出力されます。 けれども、それらすべては確認のためです。 パスフレーズを回転させることによって存在しているすべての書名つきクッキーを 無効にすることなしに、セキュリティを向上させることができます。 新しいものは先頭に追加し、後ろから取り除いてください。</p>

<pre># パスフレーズをローテーションさせる。
$app->secrets(['new_passw0rd', 'old_passw0rd', 'very_old_passw0rd']);</pre>

<h2><a class='u'
name="sessions"
>sessions</a></h2>

<pre>my $sessions = $app->sessions;
$app         = $app->sessions(Mojolicious::Sessions->new);</pre>

<p>簡単な署名付きクッキーに基いたセッションで、デフォルトは <a href="https://metacpan.org/pod/Mojolicious%3A%3ASessions" class="podlinkpod"
>Mojolicious::Sessions</a> オブジェクトです。 通常はこれは無視してください。 セッションのデータを利用するための情報としては<a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>session</code>を見てください。</p>

<pre># すべてのセッションのために利用されるクッキー名を変更する
$app->sessions->cookie_name('mysession');

# 同じサイトの機能を無効にする
$app->sessions->samesite(undef);</pre>

<h2><a class='u'
name="static"
>static</a></h2>

<pre>my $static = $app->static;
$app       = $app->static(Mojolicious::Static->new);</pre>

<p><code>public</code> ディレクトリから静的資源を提供するためのもので、デフォルトは <a href="https://metacpan.org/pod/Mojolicious%3A%3AStatic" class="podlinkpod"
>Mojolicious::Static</a> オブジェクトです。</p>

<pre># 他の"public"ディレクトリを追加
push @{$app->static->paths}, '/home/sri/public';

# 高い優先順位で、他の"public"ディレクトリを追加
unshift @{$app->static->paths}, '/home/sri/themes/blue/public';

# DATAセクションにおける静的ファイルのためのクラスを追加
push @{$app->static->classes}, 'Mojolicious::Plugin::Fun';

# ビルトインのファビコンを削除
delete $app->static->extra->{'favicon.ico'};</pre>

<h2><a class='u'
name="types"
>types</a></h2>

<pre>my $types = $app->types;
$app      = $app->types(Mojolicious::Types->new);</pre>

<p>MIMEタイプをファイル拡張子に紐づけるための割り当て。デフォルトは<a href="/Mojolicious::Types.html">Mojolicious::Types</a>オブジェクト。</p>

<pre># カスタムのMIMEタイプを追加
$app->types->type(twt => 'text/tweet');</pre>

<h2><a class='u'
name="types"
>types</a></h2>

<pre>my $types = $app->types;
$app      = $app->types(Mojolicious::Types->new);</pre>

<p>ファイル拡張子に関連付けられるMIMEタイプ。</p>

<pre>$app->types->type(twt => 'text/tweet');</pre>

<h2><a class='u'
name="ua"
>ua</a></h2>

<pre>my $ua = $app->ua;
$app   = $app->ua(Mojo::UserAgent->new);</pre>

<p>アプリケーションで利用するための完全な機能を持つHTTP1.1ユーザーエージェント。 デフォルトは<a href="/Mojo::UserAgent.html">Mojo::UserAgent</a>オブジェクトです。</p>

<pre># ブロッキングなリクエストを実行
say $app->ua->get('example.com')->result->body;</pre>

<h2><a class='u'
name="validator"
>validator</a></h2>

<pre>my $validator = $app->validator;
$app          = $app->validator(Mojolicious::Validator->new);</pre>

<p>パラメーターを検証する。 デフォルトは、<a href="/Mojolicious::Validator.html">Mojolicious::Validator</a>オブジェクトです。</p>

<pre># バリデーションのチェックを追加
$app->validator->add_check(foo => sub {
  my ($v, $name, $value) = @_;
  return $value ne 'foo';
});

# バリデーションのフィルターを追加
$app->validator->add_filter(quotemeta => sub {
  my ($v, $name, $value) = @_;
  return quotemeta $value;
});</pre>

<h1><a class='u'
name="_"
>メソッド</a></h1>

<p><a href="/Mojolicious.html">Mojolicious</a> は <a href="/Mojo.html">Mojo</a> から全てのメソッドを継承しており、以下の新しい メソッドを実装しています。</p>

<h2><a class='u'
name="build_controller"
>build_controller</a></h2>

<pre>my $c = $app->build_controller;
my $c = $app->build_controller(Mojo::Transaction::HTTP->new);
my $c = $app->build_controller(Mojolicious::Controller->new);</pre>

<p>デフォルトコントローラーオブジェクトを"controller_class"で構築する。</p>

<pre># アプリケーションからテンプレートを描画
my $foo = $app->build_controller->render_to_string(template => 'foo');</pre>

<h2><a class='u'
name="build_tx"
>build_tx</a></h2>

<pre>my $tx = $app->build_tx;</pre>

<p><a href="/Mojo::Transaction::HTTP.html">Mojo::Transaction::HTTP</a>オブジェクトを構築し、"after_build_tx"フックを発生させます。</p>

<h2><a class='u'
name="config"
>config</a></h2>

<pre>my $hash = $app->config;
my $foo  = $app->config('foo');
$app     = $app->config({foo => 'bar'});
$app     = $app->config(foo => 'bar');</pre>

<p>アプリケーションの設定。</p>

<pre># 値の削除
my $foo = delete $app->config->{foo};

# 複数の値を一度に代入する
$app->config(foo => 'test', bar => 23);</pre>

<h2><a class='u'
name="defaults"
>defaults</a></h2>

<pre>my $hash = $app->defaults;
my $foo  = $app->defaults('foo');
$app     = $app->defaults({foo => 'bar'});
$app     = $app->defaults(foo => 'bar');</pre>

<p><a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>stash</code>のための デフォルト値です。新しいリクエストのたびに設定されます。</p>

<pre># 値を取り除く
my $foo = delete $app->defaults->{foo};

# 複数の値を一度に代入
$app->defaults(foo => 'test', bar => 23);</pre>

<h2><a class='u'
name="dispatch"
>dispatch</a></h2>

<pre>$app->dispatch(Mojolicious::Controller->new);</pre>

<p><a href="/Mojolicious.html">Mojolicious</a>アプリケーションの心臓部で、リクエストごとに静的ディスパッチャ、 ルートディスパッチャを呼び出し、それらに <a href="/Mojolicious::Controller.html">Mojolicious::Controller</a> オブジェクトを渡します。</p>

<h2><a class='u'
name="handler"
>handler</a></h2>

<pre>$app->handler(Mojo::Transaction::HTTP->new);
$app->handler(Mojolicious::Controller->new);</pre>

<p>デフォルトのコントローラーをセットアップし、すべてのリクエストに対し"around_dispatch"フックを発生させます。</p>

<h2><a class='u'
name="handler"
>handler</a></h2>

<pre>$app->handler(Mojo::Transaction::HTTP->new);
$app->handler(Mojolicious::Controller->new);</pre>

<p>デフォルトコントローラを準備し、リクエストごとに<code>around_dispatch</code>フックを発行します。</p>

<h2><a class='u'
name="helper"
>helper</a></h2>

<pre>$app->helper(foo => sub {...});</pre>

<p>コントローラオブジェクトとアプリケーションオブジェクトのメソッドとして、 また、 <code>ep</code> テンプレートの関数として利用できる新しいヘルパーを追加します。</p>

<p>デフォルトで利用可能な、すべてのヘルパーのリストは<a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>と<a href="/Mojolicious::Plugin::TagHelpers.html">Mojolicious::Plugin::TagHelpers</a>を見てください。</p>

<pre># ヘルパー
$app->helper(cache => sub { state $cache = {} });

# アプリケーション
$app->cache->{foo} = 'bar';
my $result = $app->cache->{foo};

# コントローラー
$c->cache->{foo} = 'bar';
my $result = $c->cache->{foo};

# テンプレート
% cache->{foo} = 'bar';
%= cache->{foo}</pre>

<h2><a class='u'
name="hook"
>hook</a></h2>

<pre>$app->hook(after_dispatch => sub {...});</pre>

<p>フックで<a href="/Mojolicious.html">Mojolicious</a>を拡張します。 すべてのリクエストで無差別にコードを共有することを可能にします。 利用できるフックのすべてのリストは<code>フック</code>を見てください。</p>

<pre># すでに定義されているレスポンスコードがあれば、ディスパッチャーは実行されません
$app->hook(before_dispatch => sub {
  my $c = shift;
  $c->render(text => 'Skipped static file server and router!')
    if $c->req->url->path->to_route =~ /do_not_dispatch/;
});</pre>

<h2><a class='u'
name="new"
>new</a></h2>

<pre>my $app = Mojolicious->new;
my $app = Mojolicious->new(moniker => 'foo_bar');
my $app = Mojolicious->new({moniker => 'foo_bar'});</pre>

<p>新しい <a href="/Mojolicious.html">Mojolicious</a> アプリケーションを構築し、<code>startup</code>を呼び出します。 ホームディレクトリを自動的に検知し、現在の実行モードに基いてロギングを 準備します。 レンダラ、静的ディスパッチャ、プラグインのデフォルトセット、 デフォルトの例外を処理する<code>around_dispatch</code>フックを発生準備します。</p>

<h2><a class='u'
name="plugin"
>plugin</a></h2>

<pre>$app->plugin('some_thing');
$app->plugin('some_thing', foo => 23);
$app->plugin('some_thing', {foo => 23});
$app->plugin('SomeThing');
$app->plugin('SomeThing', foo => 23);
$app->plugin('SomeThing', {foo => 23});
$app->plugin('MyApp::Plugin::SomeThing');
$app->plugin('MyApp::Plugin::SomeThing', foo => 23);
$app->plugin('MyApp::Plugin::SomeThing', {foo => 23});</pre>

<p><a href="/Mojolicious::Plugins.html">Mojolicious::Plugins</a>の<code>register_plugin</code>を使ってプラグインをロードします。 すべての</p>

<p><a href="/Mojolicious.html">Mojolicious</a>に含まれているすべてのサンプルプラグインのリストは<a href="/Mojolicious::Plugins.html">Mojolicious::Plugins</a>の <code>プラグイン</code>の項目で見ることができます。</p>

<h2><a class='u'
name="start"
>start</a></h2>

<pre>$app->start;
$app->start(@ARGV);</pre>

<p>アプリケーションのために<a href="/Mojolicious::Commands.html">Mojolicious::Commands</a>の<code>start</code>でコマンドライン インターフェースを開始します。</p>

<p><code>-h</code>/<code>--help</code>, <code>--home</code>と<code>-m</code>/<code>--mode</code>のオプションは、 すべてのコマンドで共有され、コンパイルタイムの間に、 <code>@ARGV</code>から解析されることに注意してください。</p>

<pre># いつもデーモンを開始
$app->start('daemon', '-l', 'http://*:8080');</pre>

<h2><a class='u'
name="startup"
>startup</a></h2>

<pre>$app->startup;</pre>

<p>これはアプリケーションにおけるあなたの主要フックです。アプリケーション開始時に 呼び出されます。サブクラスでオーバーロードされます。</p>

<pre>sub startup {
  my $self = shift;
}</pre>

<h1><a class='u'
name="_"
>ヘルパー</a></h1>

<p>上記の属性とメソッドに加えて、Mojoliciousのインスタンスにおいてヘルパーを呼び出すことができます。 これは<a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>と<a href="/Mojolicious::Plugin::TagHelpers.html">Mojolicious::Plugin::TagHelpers</a>からすべての ヘルパーを含んでいます。 アプリケーションのヘルパーはいつでも新しい<code>controller_class</code>インスタンスから呼び出されることに 注意してください。ですのでそれらは、リクエストやレスポンスやスタッシュを含むコントローラーの状態に依存したり、 コントローラの状態を変更することはできません。</p>

<pre># ヘルパーを呼ぶ
say $app->dumper({foo => 'bar'});

# 長いバージョン
say $app->build_controller->helpers->dumper({foo => 'bar'});</pre>

<p>(Mojolicious 8.12を反映。2019年6月3日更新)</p>

<!-- end doc -->

</body></html>

  </div>
  <div class="bottom">
    <!-- bottom -->

  </div>
</div>

        </div>
        <div class="side">
          <!-- side -->
<div class="side-list">
  <div class="side-list-title">
    Side Bar
  </div>
  <ul>
    <li><a href="/list.html">Entries</a></li>
    <li>Bar</li>
    <li>Baz</li>
  </ul>
</div>

        </div>
      </div>
      <div class="footer">
        <!-- footer -->
<a href="https://github.com/yuki-kimoto/giblog">Giblog</a>

      </div>
    </div>
  </body>
</html>
