<!DOCTYPE html>
<html>
  <head>
    <!-- meta -->
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0">
<link rel="icon" type="image/x-icon" href="/images/giblog-logo.png">
<link rel="stylesheet" type="text/css" href="/css/common.css">

<title> - Mojoliciousドキュメント 日本語訳</title>
<meta name="description" content="Mojolicious::Guides::Rendering - コンテンツのレンダリング">
  </head>
  <body>
    <div class="container">
      <div class="header">
        <!-- header -->
<div class="main">
  <h1>
    <a href="/">Mojoliciousドキュメント 日本語訳</a>
  </h1>
</div>

      </div>
      <div class="main">
        <div class="content">
          <div class="entry">
  <div class="top">
    <!-- top -->

  </div>
  <div class="middle">
    <html><head><title>名前</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.40,
  using Pod::Simple::PullParser v3.40,
  under Perl v5.028000 at Tue Apr  7 04:16:24 2020 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<h1><a href="/Mojolicious::Guides::Rendering.html"></a><a class='u'
name="_"
>名前</a></h1>

<p>Mojolicious::Guides::Rendering - コンテンツのレンダリング</p>

<h1><a class='u'
name="_"
>概要</a></h1>

<p>本書は、<a href="/Mojolicious.html">Mojolicious</a>レンダラを使ったコンテンツ生成について説明します。</p>

<h1><a class='u'
name="_"
>概念</a></h1>

<p>すべての<a href="/Mojolicious.html">Mojolicious</a>開発者が知るべき本質</p>

<h2><a class='u'
name="_"
>レンダラ</a></h2>

<p>レンダラは、複数のテンプレートシステムとデータエンコードモジュールを利用して、スタッシュデータを実際のレスポンスに変換する小さなブラックボックスです。</p>

<pre>{text => 'Hello.'}                 -> 200 OK, text/html, 'Hello.'
{json => {x => 3}}                 -> 200 OK, application/json, '{"x":3}'
{text => 'Oops.', status => '410'} -> 410 Gone, text/html, 'Oops.'</pre>

<p>開発者またはルーティングから十分な情報が提供されれば、テンプレートは自動的に検出されます。テンプレート名は<code>template.format.handler</code>命名規則に従うことが期待されています。<code>template</code>はデフォルトでは<code>controller/action</code>またはルート名です。デフォルトの<code>format</code>は<code>html</code>、<code>handler</code>は<code>ep</code> です。</p>

<pre>{controller => 'users', action => 'list'} -> 'users/list.html.ep'
{template => 'foo', format => 'txt'}      -> 'foo.txt.ep'
{template => 'foo', handler => 'epl'}     -> 'foo.html.epl'</pre>

<p><code>controller</code>値は、<a href="/Mojo::Util.html">Mojo::Util</a>の<code>decamelize</code>によって<code>CamelCase</code>から<code>snake_case</code>に変換されます。<code>-</code>文字は<code>/</code> に置き換えられます。</p>

<pre>{controller => 'My::Users', action => 'add'} -> 'my/users/add.html.ep'
{controller => 'my-users', action => 'show'} -> 'my/users/show.html.ep'</pre>

<p>テンプレートはすべてアプリケーションの<code>template</code>ディレクトリに置いてください。このパスは<a href="/Mojolicious::Renderer.html">Mojolicious::Renderer</a>の<code>paths</code>で変更できます。または、<a href="/Mojolicious::Renderer.html">Mojolicious::Renderer</a>の<code>classes</code>のうちいずれかの<code>DATA</code>セクションに記述してください。</p>

<pre>__DATA__;

@@ time.html.ep
% use Time::Piece;
% my $now = localtime;
<!DOCTYPE html>
<html>
  <head><title>Time</title></head>
  <body>The time is <%= $now->hms %>.</body>
</html>

@@ hello.txt.ep
...</pre>

<p>レンダラは、プラグインを使用して追加のテンプレートシステムをサポートするように簡単に拡張できますが、それについては後で詳しく説明します。</p>

<h2><a class='u'
name="Perl"
>埋め込みPerl</a></h2>

<p><a href="/Mojolicious.html">Mojolicious</a>には埋め込みPerlまたは<code>ep</code>と呼ばれる、すぐに使える最小限でありながら非常に強力なテンプレートシステムが含まれています。それは<a href="https://metacpan.org/pod/Mojo%3A%3ATemplate" class="podlinkpod"
>Mojo::Template</a>に基づいています。そして、少数の特別なタグと改行文字を使ってPerlコードを実際のコンテンツに埋め込むことができます。すべてのテンプレートに対して<code>strict</code>、<code>warnings</code>、<code>utf8</code>とPerl 5.10 <code>features|feature</code>が自動的に有効になります。</p>

<pre><% Perlコード %>
<%= Perl式、XML文字がエスケープされた結果が返されます %>
<%== Perl式、評価結果が返されます %>
<%# デバッグに役立つコメント %>
<%%  "<%"に置換されます。テンプレートの生成に使えます %>
% Perlコード行、"<% line =%>"（説明は後ほど）として扱われます
%= Perl式行、"<%= line %>"として扱われます
%= Perl式行、"<%= line %>"として扱われます
%# コメント行、デバッグに役立ちます
%% "％"に置き換えられ、テンプレートを生成するのに便利です</pre>

<p>タグと行はほとんど同じように機能しますが、コンテキストによって使い分けると見た目が少し良くなるでしょう。セミコロンは、すべての式に自動で追加されます。</p>

<pre><% my $i = 10; %>
<ul>
  <% for my $j (1 .. $i) { %>
    <li>
      <%= $j %>
    </li>
  <% } %>
</ul>

% my $i = 10;
<ul>
  % for my $j (1 .. $i) {
    <li>
      %= $j
    </li>
  % }
</ul></pre>

<p>空白文字の扱いが異なることを別にすれば、両方のサンプルは似たPerlのコードを生成します。そのまま変換すると次のようになるでしょう。</p>

<pre>my $output = '';
my $i = 10;
$output .= '<ul>';
for my $j (1 .. $i) {
  $output .= '<li>';
  $output .= xml_escape scalar + $j;
  $output .= '</li>';
}
$output .= '</ul>';
return $output;</pre>

<p>イコールサインを追加すると、Perl式の結果に含まれる文字列<code>< </code>、<code>></code>、<code>＆</code>、<code>'</code>、<code>"</code>のエスケープを無効にできます。エスケープは、アプリケーションに対するXSS攻撃を防ぐためにデフォルトでおこなわれます。</p>

<pre><%= 'I ♥ Mojolicious!' %>
<%== '<p>I ♥ Mojolicious!</p>' %></pre>

<p><a href="/Mojo::ByteStream.html">Mojo::ByteStream</a>オブジェクトだけは自動エスケープの対象外です。</p>

<pre><%= b('<p>I ♥ Mojolicious!</p>') %></pre>

<p>タグの前後にある文字列は、追加のイコール記号をタグの最後につけることによって、除去できます。</p>

<pre><% for (1 .. 3) { %>
  <%= 'この式の前後にある空白文字はトリムされます' =%>
<% } %></pre>

<p>改行はバックスラッシュでエスケープできます。</p>

<pre>これは <%= 1 + 1 %>  \
1行になります</pre>

<p>改行の直前のバックスラッシュはもう一つのバックスラッシュ によってエスケープできます。</p>

<pre>これは <%= 1 + 1 %> \\
複数行に \\
なります</pre>

<p>最後の文字がバックスラッシュでない限り、改行文字はすべてのテンプレートに自動的に追加されます。また、テンプレートの末尾の空行は無視されます。</p>

<pre>末尾に改行文字が付きません <%= 1 + 1 %> \</pre>

<p>テンプレートの最初で、名前に無効な文字を含まないスタッシュ値は通常の変数として自動的に初期化され、コントローラオブジェクトは<code>$self</code>と<code>$c</code>の両方が自動的に初期化されます。</p>

<pre>$c->stash(name => 'tester');

Hello <%= $name %> from <%= $self->tx->remote_address %>.</pre>

<p><code>myapp.*</code>のようなプレフィックスは、通常はテンプレートの中で見せたくないスタッシュ値に使います。</p>

<pre>$c->stash('myapp.name' => 'tester');</pre>

<p>たくさんのヘルパー関数が利用可能ですが、後ほど紹介します。</p>

<pre><%= dumper {foo => 'bar'} %></pre>

<h1><a class='u'
name="_"
>基礎</a></h1>

<p>すべてのMojolicious開発者が知っておくべきもっとも一般的に利用される機能</p>

<h2><a class='u'
name="_"
>自動的な描画</a></h2>

<p><a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>render</code>メソッドを呼び出すことで、レンダラを手動で起動できます。しかし、通常は必要ありません。なぜならルータの処理が終わったとき、何もレンダリングされていない場合はレンダラが自動的に呼び出されるからです。これは、何もアクションを実行しない、テンプレートだけを指し示すルーティングを作成できるということです。</p>

<pre>$c->render;</pre>

<p>ただし、大きな違いがひとつあります。<code>render</code>を手動で呼ぶことによって、テンプレートが現在のコントローラオブジェクトを使用し、アプリケーションクラスの<a href="/Mojolicious.html">Mojolicious</a>の<code>controller_class</code>属性で指定されたデフォルトコントローラを使用しないことを保証できます。</p>

<pre>$c->render_later;</pre>

<p><a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>render_later</code>メソッドを使って自動レンダリングを無効にすることもできます。 これは、ノンブロッキング操作を先に実行したい場合にレンダリングを遅らせるのに非常に便利です。</p>

<h2><a class='u'
name="_"
>テンプレートの描画</a></h2>

<p>レンダラはいつも正しいテンプレートを検知しようとしますが、スタッシュの<code>template</code>の値を使って描画するテンプレートを指定することもできます。最後のスラッシュより前の部分は、テンプレートを探すサブディレクトリとして解釈されます。</p>

<pre># foo/bar/baz.*.*
$c->render(template => 'foo/bar/baz');</pre>

<p>特定の<code>format</code>や<code>handler</code>を選択することも同様に簡単です。</p>

<pre># foo/bar/baz.txt.epl
$c->render(template => 'foo/bar/baz', format => 'txt', handler => 'epl');</pre>

<p>特定のテンプレートの描画は、とてもよくあるタスクなのでショートカットが用意されています。</p>

<pre>$c->render('foo/bar/baz')</pre>

<p>テンプレートが実際に存在するかどうかわからない場合には、複数ある代わりのテンプレートを試すために <a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>render_maybe</code>メソッドを使うこともできます。</p>

<pre>$c->render_maybe('localized/bar') or $self->render('foo/bar');</pre>

<h2><a class='u'
name="_"
>文字列への描画</a></h2>

<p>描画の結果をレスポンスとして生成するのではなく、直接使いたい場合もあることでしょう。たとえば、Eメールを送る場合などです。<a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>render_to_string</code> を使って行えます。</p>

<pre>my $html = $c->render_to_string('mail');</pre>

<p>エンコーディングは実行されません。結果を他のテンプレートで再利用したり、バイナリデータを生成することが簡単になります。</p>

<pre>my $pdf = $c->render_to_string('invoice', format => 'pdf');
$self->render(data => $pdf, format => 'pdf');</pre>

<p>すべての渡された引数は、自動的にローカライズされ、 描画処理の間だけ利用できます。</p>

<h2><a class='u'
name="_"
>テンプレートバリアント</a></h2>

<p>異なったデバイス間でアプリケーションの見た目をよくするためには、複数あるテンプレートからいずれかを選択するために、<code>variant</code>スタッシュ値が利用できます。</p>

<pre># foo/bar/baz.html+phone.ep
# foo/bar/baz.html.ep
$c->render('foo/bar/baz', variant => 'phone');</pre>

<p>このスタッシュ値はとても自由に使えます。なぜなら、その名前のテンプレートが実際に存在したときだけ適用され、存在しなければ一般的なテンプレートにフォールバックするからです。</p>

<h2><a class='u'
name="_"
>インラインテンプレートの描画</a></h2>

<p><code>ep</code>のようないくつかのレンダラは、テンプレートをインラインで渡すことができます。</p>

<pre>$c->render(inline => 'The result is <%= 1 + 1%>!');</pre>

<p>自動検知はパスに依存するため、<code>handler</code>を与える必要があるかもしれません。</p>

<pre>$c->render(inline => "<%= shift->param('foo') %>", handler => 'epl');</pre>

<h2><a class='u'
name="_"
>テキストの描画</a></h2>

<p>文字列は<code>text</code>スタッシュ値を使ってバイトに変換できます。与えた値は<a href="/Mojolicious::Renderer.html">Mojolicious::Renderer</a>の<code>encoding</code>で自動的にエンコードされます。</p>

<pre>$c->render(text => 'I ♥ Mojolicious!');</pre>

<h2><a class='u'
name="_"
>データの描画</a></h2>

<p>生のバイトはスタッシュの<code>data</code>の値によって描画できます。エンコーディングは実行されません。</p>

<pre>$c->render(data => $bytes);</pre>

<h2><a class='u'
name="JSON"
>JSONの描画</a></h2>

<p>スタッシュの<code>json</code> の値を使用すると、Perlデータ構造がレンダラに渡され、<a href="/Mojo::JSON.html">Mojo::JSON</a>を使用してJSONに直接エンコードされます。</p>

<pre>$c->render(json => {foo => [1, 'test', 3]});</pre>

<h2><a class='u'
name="_"
>ステータスコード</a></h2>

<p>レスポンスのステータスコードを、スタッシュの<code>status</code>の値によって変更できます。</p>

<pre>$c->render(text => 'Oops.', status => 500);</pre>

<h2><a class='u'
name="_"
>コンテンツタイプ</a></h2>

<p>レスポンスの<code>Content-Type</code>ヘッダは、実際のスタッシュの<code>format</code>の値に対応するMIMEタイプが元になっています。</p>

<pre># Content-Type: text/plain
$c->render(text => 'Hello.', format => 'txt');

# Content-Type: image/png
$c->render(data => $bytes, format => 'png');</pre>

<p>これらの対応は、<a href="/Mojolicious.html">Mojolicious</a>の<code>types</code>を使って、簡単に拡張したり変更したりできます。</p>

<pre># 新しいMIMEタイプの追加
$app->types->type(md => 'text/markdown');</pre>

<h2><a class='u'
name="_"
>スタッシュデータ</a></h2>

<p>データは、どのようなPerlのネイティブなデータ型のものであれ、<code>stash</code>を通してテンプレートにレファレンスとして渡せます。</p>

<pre>$c->stash(description => 'web framework');
$c->stash(frameworks  => ['Catalyst', 'Mojolicious']);
$c->stash(spinoffs    => {minion => 'job queue'});

=head1 説明
%= $frameworks->[1]
%= $spinoffs->{minion}</pre>

<p>以下はすべてPerlの通常の制御構造なので、どれもうまく動きます。</p>

<pre>% for my $framework (@$frameworks) {
  <%= $framework %> is a <%= $description %>.
% }

% if (my $description = $spinoffs->{minion}) {
  Minion is a <%= $description %>.
% }</pre>

<p>さまざまな方法でレンダリングされる可能性があり、スタッシュ値が実際に設定されるかどうかわからない場合は、単に<a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>stash</code> を使用します。</p>

<pre>% if (my $spinoffs = stash 'spinoffs') {
  Minion is a <%= $spinoffs->{minion} %>.
% }</pre>

<h2><a class='u'
name="_"
>ヘルパー</a></h2>

<p>ヘルパーは、アプリケーション、コントローラー、テンプレートのどこででも使える小さな関数の集まりです。</p>

<pre>=head2 テンプレート
%= dumper [1, 2, 3]

# アプリケーション
my $serialized = $app->dumper([1, 2, 3]);

# コントローラー
my $serialized = $c->dumper([1, 2, 3]);</pre>

<p>デフォルトヘルパーとタグヘルパーは区別されます。デフォルトヘルパーは、<a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>dumper</code>のようにより汎用的なものです。一方、タグヘルパーは<a href="/Mojolicious::Plugin::TagHelpers.html">Mojolicious::Plugin::TagHelpers</a>の<code>link_to</code>のようにテンプレート専用であり、主にHTMLタグの生成に使用されます。</p>

<pre>%= link_to Mojolicious => 'https://mojolicious.org'</pre>

<p>コントローラーでは、<a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>helpers</code>メソッドを使ってヘルパーだけが呼び出されるように制限し、既存のメソッドとの衝突を防げます。</p>

<pre>my $serialized = $c->helpers->dumper([1, 2, 3]);</pre>

<p>すべての組み込みのヘルパーのリストは、<a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a> と<a href="/Mojolicious::Plugin::TagHelpers.html">Mojolicious::Plugin::TagHelpers</a>にあります。</p>

<h2><a class='u'
name="_"
>コンテンツネゴシエーション</a></h2>

<p>リソースの表現方法が複数あったり、RESTに忠実なコンテンツネゴーシエーションを行う必要があるときは、<a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>render</code>の代わりに<a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>respond_to</code>も使用できます。</p>

<pre># /hello (Accept: application/json) -> "json"
# /hello (Accept: text/xml)         -> "xml"
# /hello.json                       -> "json"
# /hello.xml                        -> "xml"
# /hello?format=json                -> "json"
# /hello?format=xml                 -> "xml"
$c->respond_to(
  json => {json => {hello => 'world'}},
  xml  => {text => '<hello>world</hello>'}
);</pre>

<p>もっとも適切な表現が<code>format</code>、<code>GET</code>/<code>POST</code>パラメーター、スタッシュの<code>format</code>の値または<code>Accept</code>リクエストヘッダから自動的に選択され、スタッシュの<code>format</code>の値に格納されます。<code>Accept</code>リクエストヘッダまたは<code>Content-Type</code>レスポンスヘッダのMIMEタイプマッピングを変更するには、<a href="/Mojolicious.html">Mojolicious</a>の<code>types</code>を使用します。</p>

<pre>$c->respond_to(
  json => {json => {hello => 'world'}},
  html => sub {
    $self->content_for(head => '<meta name="author" content="sri">');
    $self->render(template => 'hello', message => 'world')
  }
);</pre>

<p>ひとつの<code>render</code>コールに含めるには表現が複雑すぎる場合は、コールバックを使用できます。</p>

<pre># /hello (Accept: application/json) -> "json"
# /hello (Accept: text/html)        -> "html"
# /hello (Accept: image/png)        -> "any"
# /hello.json                       -> "json"
# /hello.html                       -> "html"
# /hello.png                        -> "any"
# /hello?format=json                -> "json"
# /hello?format=html                -> "html"
# /hello?format=png                 -> "any"
$c->respond_to(
  json => {json => {hello => 'world'}},
  html => {template => 'hello', message => 'world'},
  any  => {text => '', status => 204}
);</pre>

<p>実行可能な表現が見つからない場合は、<code>any</code>によるフォールバックが行われるか、 空の<code>204</code>レスポンスが自動的に描画されます。</p>

<pre># /hello                      -> "html"
# /hello (Accept: text/html)  -> "html"
# /hello (Accept: text/xml)   -> "xml"
# /hello (Accept: text/plain) -> undef
# /hello.html                 -> "html"
# /hello.xml                  -> "xml"
# /hello.txt                  -> undef
# /hello?format=html          -> "html"
# /hello?format=xml           -> "xml"
# /hello?format=txt           -> undef
if (my $format = $self->accepts('html', 'xml')) {
  ...
}</pre>

<p>より高度なネゴシエーションのロジックには、<a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>accepts</code>ヘルパーを使うこともできます。</p>

<h2><a class='u'
name="not_found"
>例外と<code>not_found</code>ページの描画</a></h2>

<p>これまでにすでに組み込みの<code>404</code>（Not Found）や<code>500</code>（Server Error）ページを見たことがあるでしょう。間違いがあるとき自動的に描画されます。これはあなた自身が書いた例外ハンドリングが失敗したときのためのフォールバックです。開発中にとくに役に立つことでしょう。例外ページは、 <a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>reply->exception</code>や<a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>reply->not_found</code>ヘルパーを使って手動で描画することもできます。</p>

<pre>use Mojolicious::Lite;
use Scalar::Util 'looks_like_number';

get '/divide/:dividend/by/:divisor' => sub {
  my $c = shift;

  my $dividend = $c->param('dividend');
  my $divisor  = $c->param('divisor');

  # 404
  return $self->reply->not_found
    unless looks_like_number $dividend && looks_like_number $divisor;

  # 500
  return $self->reply->exception('Division by zero!') if $divisor == 0;

  # 200
  $self->render(text => $dividend / $divisor);
};

app->start;</pre>

<p>例外ページのテンプレートは自由に変更できます。本番環境では、にアプリケーションにより関連した内容をユーザー表示したいことが多いですからね。レンダラは、組み込みのデフォルトテンプレートにフォールバックする前に<code>exception.$mode.$format.*</code>または<code>not_found.$mode.$format.*</code>を毎回探します。</p>

<pre>use Mojolicious::Lite;

get '/dies' => sub { die 'Intentional error' };

app->start;
__DATA__;

@@ exception.production.html.ep
<!DOCTYPE html>
<html>
  <head><title>Server error</title></head>
  <body>
    <h1>Exception</h1>
    <p><%= $exception->message %></p>
    =head2 スタッシュ
    <pre><%= dumper $snapshot %></pre>
  </body>
</html></pre>

<p><a href="/Mojolicious.html">Mojolicious</a>の<code>before_render</code>フックを使えば、 レンダラに渡された引数を処理に割り入って変更できるようになり、より高度なカスタマイズが可能になります。</p>

<pre>use Mojolicious::Lite;

hook before_render => sub {
  my ($c, $args) = @_;

  # 例外テンプレートが確実に描画されるようにする
  return unless my $template = $args->{template};
  return unless $template eq 'exception';

  # コンテンツネゴシエーションで許可されている場合にJSONレンダリングに切り替える
  $args->{json} = {exception => $self->stash('exception')}if $self->accepts('json');
};

get '/' => sub { die "This sho...ALL GLORY TO THE HYPNOTOAD!\n" };

app->start;</pre>

<h2><a class='u'
name="_"
>レイアウト</a></h2>

<p><code>ep</code>テンプレートを使うほとんどの場合で、生成したコンテンツをHTMLの雛形の中にラップしたいのではないでしょうか。レイアウト機能のおかげでこれはとても簡単にできます。</p>

<pre>use Mojolicious::Lite;

get '/' => {template => 'foo/bar'};

app->start;
__DATA__;

@@ foo/bar.html.ep
% layout 'mylayout';
Hello World!

@@ layouts/mylayout.html.ep
<!DOCTYPE html>
<html>
  <head><title>MyApp</title></head>
  <body><%= content %></body>
</html></pre>

<p><a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>layout</code>ヘルパーを使って適切なレイアウトテンプレートを選択し、現在のテンプレートの結果を<a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>content</code>ヘルパーで配置できます。ふつうのスタッシュ値を<code>layout</code>ヘルパーに渡すこともできます。</p>

<pre>use Mojolicious::Lite;

get '/' => {template => 'foo/bar'};

app->start;
__DATA__;

@@ foo/bar.html.ep
% layout 'mylayout', title => 'Hi there!';
Hello World!

@@ layouts/mylayout.html.ep
<!DOCTYPE html>
<html>
  <head><title><%= $title %></title></head>
  <body><%= content %></body>
</html></pre>

<p><code>layout</code>ヘルパーを使う代わりに、スタッシュの<code>layout</code>の値、または、<code>layout</code>引数を渡してrenderメソッドを呼び出すこともできます。</p>

<pre>$c->render(template => 'mytemplate', layout => 'mylayout');</pre>

<p><code>layout</code>のスタッシュ値をアプリケーション全体で利用できるようにするには、<a href="/Mojolicious.html">Mojolicious</a>の<code>defaults</code>が使えます。</p>

<pre>$app->defaults(layout => 'mylayout');</pre>

<p>レイアウトは<a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>render_to_string</code>でも利用可能ですが、 <code>layout</code>の値はレンダラの引数(スタッシュの値ではなく)として渡される必要があります。</p>

<pre>my $html = $c->render_to_string('reminder', layout => 'mail');</pre>

<h2><a class='u'
name="_"
>部分テンプレート</a></h2>

<p>大きなテンプレートは、より小さくて管理しやすいかたまりに分割できます。こうしてできた部分テンプレートは、その他のテンプレートと共有できます。<a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>include</code>ヘルパーを使えば、あるテンプレートを別のテンプレートにインクルードできます。</p>

<pre>use Mojolicious::Lite;

get '/' => {template => 'foo/bar'};

app->start;
__DATA__;

@@ foo/bar.html.ep
<!DOCTYPE html>
<html>
  %= include '_header', title => 'Howdy'
  <body>Bar</body>
</html>

@@ _header.html.ep
<head><title><%= $title %></title></head></pre>

<p>部分テンプレートにはなんでも好きな名前が付けられます。でも、名前の先頭にアンダースコアを付けるのが通例になっています。</p>

<h2><a class='u'
name="_"
>再利用可能なテンプレートブロック</a></h2>

<p>同じことを繰り返すのは楽しくありません。だから、通常のPerlサブルーチンのように動く再利用可能なテンプレートブロックが<code>ep</code>に書けるようになっています。<code>begin</code>と<code>end</code>キーワードを使います。両方のキーワードは囲いタグであって、本物のPerlコードではないことに気を付けてください。そのため、<code>begin</code>と<code>end</code>の後に置けるのは空白文字だけです。</p>

<pre>use Mojolicious::Lite;

get '/' => 'welcome';

app->start;
__DATA__;

@@ welcome.html.ep
<% my $block = begin %>
  % my $name = shift;
  Hello <%= $name %>.
<% end %>
<%= $block->('Wolfgang') %>
<%= $block->('Baerbel') %></pre>

<p>単純にPerlコードに変換すると次のようになるでしょう。</p>

<pre>my $output = '';
my $block  = sub {
  my $name   = shift;
  my $output = '';
  $output .= 'Hello ';
  $output .= xml_escape scalar + $name;
  $output .= '.';
  return Mojo::ByteStream->new($output);
};
$output .= xml_escape scalar + $block->('Wolfgang');
$output .= xml_escape scalar + $block->('Baerbel');
return $output;</pre>

<p>テンプレートブロックはテンプレート間で共有できませんが、多くの場合、テンプレートの部品をヘルパーに渡すために使われます。</p>

<h2><a class='u'
name="_"
>ヘルパーの追加</a></h2>

<p>アクションは小さく、なるべく多くのコードが再利用できるようにしましょう。ヘルパーはこれをとても簡単にします。ヘルパーは現在のコントローラーオブジェクトを第一引数として渡すので、これを使ってアクションでできるたくさんのことが行えます。</p>

<pre>use Mojolicious::Lite;

helper debug => sub {
  my ($c, $str) = @_;
  $c->app->log->debug($str);
};

get '/' => sub {
  my $c = shift;
  $c->debug('アクションからのHello!');
} => 'index';

app->start;
__DATA__;

@@ index.html.ep
% debug 'テンプレートからのHello!';</pre>

<p>ヘルパーは最後の引数にテンプレートブロックを受け取ることもできます。たとえば、タグヘルパーやフィルターを使うのに最適です。ヘルパーの結果を<a href="/Mojo::ByteStream.html">Mojo::ByteStream</a>オブジェクトにラップすることで、間違えて二重エスケープをすることを防げます。</p>

<pre>use Mojolicious::Lite;
use Mojo::ByteStream;

helper trim_newline => sub {
  my ($c, $block) = @_;
  my $result = $block->();
  $result =~ s/\n//g;
  return Mojo::ByteStream->new($result);
};

get '/' => 'index';

app->start;
__DATA__;

@@ index.html.ep
%= trim_newline begin
  Some text.
  %= 1 + 1
  More text.
% end</pre>

<p>スタッシュ値と同様に、<code>myapp.*</code>のようなプレフィックスを使用することで、テンプレートのなかにむき出しの関数としてヘルパーを書かなくて済みます。また、アプリケーションが大きくなるにつれて、ネームスペース中に整理できるようになります。すべてのプレフィックスは自動的に、 現在のコントローラーオブジェクトを含んだプロキシオブジェクトを返却する ヘルパーになります。また、そこからはネストされたヘルパーを呼び出せます。</p>

<pre>use Mojolicious::Lite;

helper 'cache_control.no_caching' => sub {
  my $c = shift;
  $c->res->headers->cache_control('private, max-age=0, no-cache');
};

helper 'cache_control.five_minutes' => sub {
  my $c = shift;
  $c->res->headers->cache_control('public, max-age=300');
};

get '/news' => sub {
  my $c = shift;
  $c->cache_control->no_caching;
  $c->render(text => 'Always up to date.');
};

get '/some_older_story' => sub {
  my $c = shift;
  $c->cache_control->five_minutes;
  $c->render(text => 'This one can be cached for a bit.');
};

app->start;</pre>

<p>ヘルパーは再定義可能ですが、衝突を避けるために、よく注意してください。</p>

<h2><a class='u'
name="_"
>コンテンツブロック</a></h2>

<p><a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>content_for</code>ヘルパーを使うと、コンテンツのブロック全体をあるテンプレートから別のテンプレートへと渡せます。レイアウトがサイドバー等の独立したセクションをテンプレートに挿入する場合にとても便利です。</p>

<pre>use Mojolicious::Lite;

get '/' => 'foo';

app->start;
__DATA__;

@@ foo.html.ep
% layout 'mylayout';
% content_for header => begin
  <meta http-equiv="Content-Type" content="text/html">
% end
<div>Hello World!</div>
% content_for header => begin
  <meta http-equiv="Pragma" content="no-cache">
% end

@@ layouts/mylayout.html.ep
<!DOCTYPE html>
<html>
  <head><%= content 'header' %></head>
  <body><%= content %></body>
</html></pre>

<h2><a class='u'
name="_"
>フォーム</a></h2>

<p>HTMLフォームをより効率的に構築するために、<a href="/Mojolicious::Plugin::TagHelpers.html">Mojolicious::Plugin::TagHelpers</a>の<code>form_for</code> のようなタグヘルパーを使うことができます。ルート名が与えられていれば、リクエストメソッドが自動的に選択されます。ほとんどのブラウザは、フォームをサブミットするメソッドとして<code>GET</code>と<code>POST</code>だけを許可していて、<code>PUT</code>や<code>DELETE</code>には対応していないので、<code>_method</code>クエリパラメーターで偽装できます。</p>

<pre>use Mojolicious::Lite;

get '/' => 'form';

# PUT  /nothing
# POST /nothing?_method=PUT
put '/nothing' => sub {
  my $c = shift;

  # リダイレクトで二重フォーム送信を防ぐ
  my $value = $c->param('whatever');
  $c->flash(confirmation => "We did nothing with your value ($value).");
  $c->redirect_to('form');
};

app->start;
__DATA__;

@@ form.html.ep
<!DOCTYPE html>
<html>
  <body>
    % if (my $confirmation = flash 'confirmation') {
      <p><%= $confirmation %></p>
    % }
    %= form_for nothing => begin
      %= text_field whatever => 'I ♥ Mojolicious!'
      %= submit_button
    % end
  </body>
</html></pre>

<p>二重フォーム送信を防ぐために<a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>flash</code>と<a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>redirect_to</code>は一緒に使用されることが多く、リダイレクトされたページをリロードすると消える確認メッセージをユーザーが受信できるようになります。</p>

<h2><a class='u'
name="_"
>フォーム検証</a></h2>

<p>アプリケーションに送信する<code>GET</code>と<code>POST</code>パラメーターは<a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>validation</code>メソッドを使って検証できます。すべての未知のフィールドはデフォルトで無視されるので、どれを<a href="/Mojolicious::Validator::Validation.html">required</a>の<code>required</code>にして、どれを<a href="/Mojolicious::Validator::Validation.html">optional</a>の<code>optional</code>にするのかを、値のチェックを実行する前に決める必要があります。すべてのチェックはすぐに実行されます。<a href="/Mojolicious::Validator::Validation.html">Mojolicious::Validator::Validation</a>の<code>is_valid</code>のようなメソッドからすぐに結果を得て、より高度な検証ロジックを構築できます。</p>

<pre>use Mojolicious::Lite;

get '/' => sub {
  my $c = shift;

  # パラメーターが送信されたかをチェック
  my $v = $c->validation;
  return $c->render('index') unless $v->has_data;

  # パラメーターを検証する(「pass」は「pass_again」に依存)
  $v->required('user')->size(1, 20)->like(qr/^[a-z0-9]+$/);
  $v->required('pass_again')->equal_to('pass')
    if $v->optional('pass')->size(7, 500)->is_valid;

  # 検証が失敗したかをチェック
  return $c->render('index') if $v->has_error;

  # 結果を描画する
  $c->render('thanks');
};

app->start;
__DATA__;

@@ index.html.ep
<!DOCTYPE html>
<html>
  <head>
    <style>
      label.field-with-error { color: #dd7e5e }
      input.field-with-error { background-color: #fd9e7e }
    </style>
  </head>
  <body>
    %= form_for index => begin
      %= label_for user => 'Username (required, 1-20 characters, a-z/0-9)'
      <br>
      %= text_field 'user', id => 'user'
      %= submit_button
      <br>
      %= label_for pass => 'Password (optional, 7-500 characters)'
      <br>
      %= password_field 'pass', id => 'pass'
      <br>
      %= label_for pass_again => 'Password again (equal to the value above)'
      <br>
      %= password_field 'pass_again', id => 'pass_again'
    % end
  </body>
</html>

@@ thanks.html.ep
<!DOCTYPE html>
<html><body>Thank you <%= validation->param('user') %>.</body></html></pre>

<p><a href="/Mojolicious::Plugin::TagHelpers.html">Mojolicious::Plugin::TagHelpers</a>のタグヘルパーによって生成されたフォーム要素は 自動的に以前の値を復元し、検証が失敗したフィールドのclass属性に<code>field-with-error</code>を 追加します。CSSによるスタイリングが簡単になります。</p>

<pre><label class="field-with-error" for="user">
  Username (required, only characters e-t)
</label>
<input class="field-with-error" type="text" name="user" value="sri"></pre>

<p>利用可能なチェックの完全なリストは、 <a href="/Mojolicious::Validator.html">Mojolicious::Validator</a>の<code>CHECKS</code>を参照してください。</p>

<h2><a class='u'
name="_"
>フォーム検証チェックの追加</a></h2>

<p>検証チェックは<a href="/Mojolicious::Validator.html">Mojolicious::Validator</a>の<code>add_check</code>を使って登録できます。成功した場合はfalse値を返します。true値を使用して追加情報を渡すことができます。追加情報は<a href="/Mojolicious::Validator::Validation.html">Mojolicious::Validator::Validation</a>の<code>error</code>で取得できます。</p>

<pre>use Mojolicious::Lite;

# 「range（範囲）」チェックを追加する
app->validator->add_check(range => sub {
  my ($v, $name, $value, $min, $max) = @_;
  return $value < $min || $value > $max;
});

get '/' => 'form';

post '/test' => sub {
  my $c = shift;

  # カスタムチェックでパラメーターを検証する
  my $v = $c->validation;
  $v->required('number')->range(3, 23);

  # 検証が失敗したときフォームを再描画する
  return $c->render('form') if $v->has_error;

  # リダイレクトで二重フォーム送信を防ぐ
  $c->flash(number => $v->param('number'));
  $c->redirect_to('form');
};

app->start;
__DATA__;

@@ form.html.ep
<!DOCTYPE html>
<html>
  <body>
    % if (my $number = flash 'number') {
      <p>ありがとう。数値 <%= $number %> は有効です。</p>
    % }
    %= form_for test => begin
      % if (my $err = validation->error('number')) {
        <p>
          %= '値が必要です。' if $err->[0] eq 'required'
          %= '値は3から23の範囲で入力してください。' if $err->[0] eq 'range'
        </p>
      % }
      %= text_field 'number'
      %= submit_button
    % end
  </body>
</html></pre>

<h2><a class='u'
name="(CSRF)"
>クロスサイトリクエストフォージェリー(CSRF)</a></h2>

<p>CSRFはWebアプリケーションに対する非常に一般的な攻撃であり、普通のリンクなどを介して、ログインしているユーザーが送信するつもりのないフォームを送信するように仕掛けます。この攻撃からユーザー守るためにすべきことは、<a href="/Mojolicious::Plugin::TagHelpers.html">Mojolicious::Plugin::TagHelpers</a>の<code>csrf_field</code>を使って隠しフィールドをフォームに追加し、<a href="/Mojolicious::Validator::Validation.html">Mojolicious::Validator::Validation</a>の<code>csrf_protect</code>で 検証することだけです。</p>

<pre>use Mojolicious::Lite;

get '/' => {template => 'target'};

post '/' => sub {
  my $c = shift;

  # CSRFトークンのチェック
  my $v = $c->validation;
  return $c->render(text => '不正なCSRFトークンです！', status => 403)
    if $v->csrf_protect->has_error('csrf_token');

  my $city = $v->required('city')->param('city');
  $c->render(text => "低軌道イオン砲が$cityに向けられている！")
    unless $v->has_error;
} => 'target';

app->start;
__DATA__;

@@ target.html.ep
<!DOCTYPE html>
<html>
  <body>
    %= form_for target => begin
      %= csrf_field
      %= label_for city => 'どの街に低軌道イオン砲を向ける？'
      %= text_field 'city', id => 'city'
      %= submit_button
    %= end
  </body>
</html></pre>

<p>Ajaxリクエストなどの場合、<a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>csrf_token</code>ヘルパーを使用してトークンを直接生成することもできます。それから、トークンを<code>X-CSRF-Token</code>リクエストヘッダーと一緒に渡します。</p>

<h1><a class='u'
name="_"
>発展</a></h1>

<p>一般的ではないが、より強力な機能。</p>

<h2><a class='u'
name="_"
>テンプレートの継承</a></h2>

<p>継承はレイアウトの概念を一歩進めます。<a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>content</code>ヘルパーと <a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>extends</code>ヘルパーを使って、名前付きブロックを含むテンプレートスケルトンを構築できます。スケルトンテンプレートは、子テンプレートによってオーバーライドできます。</p>

<pre>use Mojolicious::Lite;

# first > mylayout
get '/first' => {template => 'first', layout => 'mylayout'};

# third > second > first > mylayout
get '/third' => {template => 'third', layout => 'mylayout'};

app->start;
__DATA__;

@@ layouts/mylayout.html.ep
<!DOCTYPE html>
<html>
  <head><title>Hello</title></head>
  <body><%= content %></body>
</html>

@@ first.html.ep
%= content header => begin
  デフォルトヘッダ―
% end
<div>Hello World!</div>
%= content footer => begin
  デフォルトフッター
% end

@@ second.html.ep
% extends 'first';
% content header => begin
  新しいヘッダー
% end

@@ third.html.ep
% extends 'second';
% content footer => begin
  新しいフッター
% end</pre>

<p>この連鎖を進めれば、とてもハイレベルなテンプレートの再利用が可能になります。</p>

<h2><a class='u'
name="_"
>静的ファイルのサーブ</a></h2>

<p>静的ファイルは、アプリケーションの<code>public</code>ディレクトリから自動的にサーブされます。サーブ対象のディレクトリは<a href="/Mojolicious::Static.html">Mojolicious::Static</a>の<code>paths</code>または<a href="/Mojolicious::Static.html">Mojolicious::Static</a>の<code>classes</code>における<code>DATA</code>セクションによってカスタマイズできます。これで十分でない場合、<a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>reply->static</code> や <a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>reply->file</code>を使って手動でサーブすることもできます。</p>

<pre>use Mojolicious::Lite;

get '/' => sub {
  my $c = shift;
  $c->reply->static('index.html');
};

get '/some_download' => sub {
  my $c = shift;
  $c->res->headers->content_disposition('attachment; filename=bar.png;');
  $c->reply->static('foo/bar.png');
};

get '/leak' => sub {
  my $c = shift;
  $c->reply->file('/etc/passwd');
};

app->start;</pre>

<h2><a class='u'
name="_"
>カスタムレスポンス</a></h2>

<p>多くのレスポンス内容は、静的であれ動的であれ、<a href="/Mojo::Asset::File.html">Mojo::Asset::File</a> と <a href="/Mojo::Asset::Memory.html">Mojo::Asset::Memory</a> オブジェクトによってサーブされます。キャッシュされたJSONデータや一時ファイルなどの静的コンテンツ のために、<a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>reply->asset</code> を使って、コンテンツネゴシエーションを<code>Range</code>、<code>If-Modified-Since</code>、<code>If-None-Match</code>ヘッダーで行いつつコンテンツをサーブできます。</p>

<pre>use Mojolicious::Lite;
use Mojo::Asset::File;

get '/leak' => sub {
  my $c = shift;
  $c->res->headers->content_type('text/plain');
  $c->reply->asset(Mojo::Asset::File->new(path => '/etc/passwd'));
};

app->start;</pre>

<p>さらに強力なコントロールを得るために、ヘルパーを無視して <a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>rendered</code>メソッドを使い、レスポンスの生成が完了した時点をレンダラに知らせることもできます。</p>

<pre>use Mojolicious::Lite;
use Mojo::Asset::File;

get '/leak' => sub {
  my $c = shift;
  $c->res->headers->content_type('text/plain');
  $c->res->content->asset(Mojo::Asset::File->new(path => '/etc/passwd'));
  $c->rendered(200);
};

app->start;</pre>

<h2><a class='u'
name="_"
>ヘルパープラグイン</a></h2>

<p>便利なヘルパーは、複数のアプリケーション間で共有したいこともあることでしょう。プラグインを使えば簡単です。</p>

<pre>package Mojolicious::Plugin::DebugHelper;
use Mojo::Base 'Mojolicious::Plugin';

sub register {
  my ($self, $app) = @_;
  $app->helper(debug => sub {
    my ($c, $str) = @_;
    $c->app->log->debug($str);
  });
}

1;</pre>

<p><code>register</code> メソッドがプラグインを読み込んだ時点でコールされます。そして、アプリケーションにヘルパーを追加するためには、 <a href="/Mojolicious.html">Mojolicious</a>の<code>helper</code>を使います。</p>

<pre>use Mojolicious::Lite;

plugin 'DebugHelper';

get '/' => sub {
  my $c = shift;
  $c->debug('It works!');
  $c->render(text => 'Hello!');
};

app->start;</pre>

<p>CPAN完全互換の配布用プラグインのためのスケルトンを自動的に生成できます。</p>

<pre>$ mojo generate plugin DebugHelper</pre>

<p>もし<code>PAUSE</code>アカウントを持っていれば(<a href="http://pause.perl.org" class="podlinkurl"
>http://pause.perl.org</a>でリクエストできます)、わずか数コマンドでCPANにリリースできます。</p>

<pre>$ perl Makefile.PL
$ make test
$ make manifest
$ make dist
$ mojo cpanify -u USER -p PASS Mojolicious-Plugin-DebugHelper-0.01.tar.gz</pre>

<h2><a class='u'
name="_"
>プラグインへのコンテンツのバンドル</a></h2>

<p>テンプレートや静的ファイルなどのアセットは、プラグインにバンドルできます。CPANにリリースする場合でも大丈夫です。</p>

<pre>$ mojo generate plugin AlertAssets
$ mkdir Mojolicious-Plugin-AlertAssets/lib/Mojolicious/Plugin/AlertAssets
$ cd Mojolicious-Plugin-AlertAssets/lib/Mojolicious/Plugin/AlertAssets
$ mkdir public
$ echo 'alert("Hello World!");' > public/alertassets.js
$ mkdir templates
$ echo '%= javascript "/alertassets.js"' > templates/alertassets.html.ep</pre>

<p>プラグインの名前に基づいた 合理的なユニークな名前を付けましょう。そして、<code>register</code>が呼ばれるとき、対応するディレクトリを検索パスの一覧に追加します。</p>

<pre>package Mojolicious::Plugin::AlertAssets;
use Mojo::Base 'Mojolicious::Plugin';

use Mojo::File 'path';

sub register {
  my ($self, $app) = @_;

  # "templates"と"public"ディレクトリを追加する
  my $base = path(__FILE__)->sibling('AlertAssets');
  push @{$app->renderer->paths}, $base->child('templates')->to_string;
  push @{$app->static->paths},   $base->child('public')->to_string;
}

1;</pre>

<p>プラグインをいったんインストールし、読み込めば、両方とも通常の<code>templates</code>と<code>public</code>ディレクトリのように機能します。優先順位は少し低くなります。</p>

<pre>use Mojolicious::Lite;

plugin 'AlertAssets';

get '/alert_me';

app->start;
__DATA__;

@@ alert_me.html.ep
<!DOCTYPE html>
<html>
  <head>
    <title>Alert me!</title>
    %= include 'alertassets'
  </head>
  <body>You've been alerted.</body>
</html></pre>

<p>すると、バンドルしたプラグインの<code>DATA</code>セクションにあるアセットと同じように使用できます。</p>

<pre>package Mojolicious::Plugin::AlertAssets;
use Mojo::Base 'Mojolicious::Plugin';

sub register {
  my ($self, $app) = @_;

  # クラスを追加する
  push @{$app->renderer->classes}, __PACKAGE__;
  push @{$app->static->classes},   __PACKAGE__;
}

1;
__DATA__;

@@ alertassets.js
alert("Hello World!");

@@ alertassets.html.ep
%= javascript "/alertassets.js"</pre>

<h2><a class='u'
name="_"
>動的コンテンツの後処理</a></h2>

<p>一般的に<a href="/Mojolicious.html">Mojolicious</a>の<code>after_dispatch</code>フックによる後処理はとても簡単ですが、レンダラによって生成されたコンテンツのためには、<a href="/Mojolicious.html">Mojolicious</a>の<code>after_render</code>を使うのがより効率的です。</p>

<pre>use Mojolicious::Lite;
use IO::Compress::Gzip 'gzip';

hook after_render => sub {
  my ($c, $output, $format) = @_;

  # "gzip => 1" がスタッシュにセットされているかを確認する
  return unless $c->stash->{gzip};

  # ユーザーエージェントがgzip圧縮を許可するかどうかを確認する
  return unless ($c->req->headers->accept_encoding // '') =~ /gzip/i;
  $c->res->headers->append(Vary => 'Accept-Encoding');

  # gzipでコンテンツを圧縮する
  $c->res->headers->content_encoding('gzip');
  gzip $output, \my $compressed;
  $$output = $compressed;
};

get '/' => {template => 'hello', title => 'Hello', gzip => 1};

app->start;
__DATA__;

@@ hello.html.ep
<!DOCTYPE html>
<html>
  <head><title><%= title %></title></head>
  <body>Compressed content.</body>
</html></pre>

<p>動的に生成されたコンテンツのすべてを圧縮したい場合は、<a href="/Mojolicious::Renderer.html">Mojolicious::Renderer</a>の<code>compress</code>を有効にすることもできます。</p>

<h2><a class='u'
name="_"
>ストリーミング</a></h2>

<p>すべてのコンテンツを一度に描画する必要はありません。<a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>write</code>を使って小さなチャンクを連続で流すこともできます。</p>

<pre>use Mojolicious::Lite;

get '/' => sub {
  my $c = shift;

  # ボディを準備する
  my $body = 'Hello World!';
  $c->res->headers->content_length(length $body);

  # 排出コールバックに直接書き込みを開始する
  my $drain;
  $drain = sub {
    my $c = shift;
    my $chunk = substr $body, 0, 1, '';
    $drain = undef unless length $body;
    $c->write($chunk, $drain);
  };
  $c->$drain;
};

app->start;</pre>

<p>前のデータチャンク全部が実際に書き込まれるたびに、排出コールバックが実行されます。</p>

<pre>HTTP/1.1 200 OK
Date: Sat, 13 Sep 2014 16:48:29 GMT
Content-Length: 12
Server: Mojolicious (Perl)

Hello World!</pre>

<p><code>Content-Length</code>ヘッダーを提供する代わりに、<a href="/Mojolicious.html">Mojolicious</a>の<code>finish</code>を使用して、完了したときに接続を手動で閉じることもできます。</p>

<pre>use Mojolicious::Lite;

get '/' => sub {
  my $c = shift;

  # ボディを準備する
  my $body = 'Hello World!';

  # 排出コールバックに直接書き込みを開始する
  my $drain;
  $drain = sub {
    my $c = shift;
    my $chunk = substr $body, 0, 1, '';
    length $chunk ?$c->write($chunk, $drain) : $c->finish;
  };
  $c->$drain;
};

app->start;</pre>

<p>Keep-aliveを妨げるため、この方法はかなり非効率的ですが、EventSourceおよび同様のアプリケーションのために必要な場合があります。</p>

<pre>HTTP/1.1 200 OK
Date: Sat, 13 Sep 2014 16:48:29 GMT
Connection: close
Server: Mojolicious (Perl)

Hello World!</pre>

<h2><a class='u'
name="_"
>チャンク化されたトランスファーエンコーディング</a></h2>

<p>コンテンツがとても動的な場合は、レスポンスコンテンツの<code>Content-Length</code>が前もってわからないかもしれません。そのような場合は、チャンク化されたトランスファーエンコーディングや <a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>write_chunk</code>が便利です。一般的な用途として、HTMLドキュメントの<code>head</code>セクションを事前にブラウザに送信し、参照する画像やスタイルシートの事前ロードを高速化できます。</p>

<pre>use Mojolicious::Lite;

get '/' => sub {
  my $c = shift;
  $c->write_chunk('<html><head><title>Example</title></head>' => sub {
    my $c = shift;
    $c->finish('<body>Example</body></html>');
  });
};

app->start;</pre>

<p>オプションの排出コールバックは、処理を継続する前に、すべての以前のチャンクが書き込まれることを保障します。ストリームを終了するためには、<a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>finish</code> を呼び出すか、空データのチャンクを書き込みます。</p>

<pre>HTTP/1.1 200 OK
Date: Sat, 13 Sep 2014 16:48:29 GMT
Transfer-Encoding: chunked
Server: Mojolicious (Perl)

29
<html><head><title>Example</title></head>
1b
<body>Example</body></html>
0</pre>

<p>とくに、長時間応答がないときのタイムアウトと組み合わせるとき、Comet（ロングポーリング）をするのに便利でしょう。Webサーバーによっては制限のために、完璧には動作しないデプロイ環境があるかもしれません。</p>

<h2><a class='u'
name="_"
>エンコーディング</a></h2>

<p>ファイルに保存されたテンプレートは、デフォルトでは<code>UTF-8</code>であると期待されますが、 <a href="/Mojolicious::Renderer.html">Mojolicious::Renderer</a>の<code>encoding</code>を使って簡単に変更できます。</p>

<pre>$app->renderer->encoding('koi8-r');</pre>

<p><code>DATA</code>セクションからのすべてのテンプレートは、必ずPerlスクリプトのエンコーディングになります。</p>

<pre>use Mojolicious::Lite;

get '/heart';

app->start;
__DATA__;

@@ heart.html.ep
I ♥ Mojolicious!</pre>

<h2><a class='u'
name="Base64DATA"
>Base64エンコードDATAファイル</a></h2>

<p>画像などのBase64でエンコードされた静的ファイルは、テンプレートと同じように、簡単にアプリケーションの<code>DATA</code>セクションに保存できます。</p>

<pre>use Mojolicious::Lite;

get '/' => {text => 'I ♥ Mojolicious!'};

app->start;
__DATA__;

@@ favicon.ico (base64)
...base64 encoded image...</pre>

<h2><a class='u'
name="DATA_"
>DATA テンプレートのインフレ―ト</a></h2>

<p>ファイルとして保存されているテンプレートは、<code>DATA</code>セクションのファイルよりも優先されます。ファイルテンプレートはアプリケーションのデフォルトセットとして含めることができ、ユーザーは後にこれをカスタマイズできます。<a href="/Mojolicious::Command::Author::inflate.html">Mojolicious::Command::Author::inflate</a>コマンドで<code>DATA</code>セクションにあるすべてのテンプレートと静的ファイルを、実際のファイルとして<code>templates</code>および<code>public</code> ディレクトリに書き込みます。</p>

<pre>$ ./myapp.pl inflate...</pre>

<h2><a class='u'
name="_"
>テンプレート文法のカスタマイズ</a></h2>

<p>EPRendererプラグインをカスタム設定と一緒にロードすることによって、簡単にテンプレートの文法全体を変更できます。</p>

<pre>use Mojolicious::Lite;

plugin EPRenderer => {
  name     => 'mustache',
  template => {
    tag_start => '{{',
    tag_end   => '}}'
  }
};

get '/' => 'index';

app->start;
__DATA__;

@@ index.html.mustache
Hello {{= $name }}.</pre>

<p><a href="/Mojo::Template.html">Mojo::Template</a>は利用できるすべてのオプションを含んでいます。</p>

<h2><a class='u'
name="_"
>お気に入りテンプレートシステムの追加</a></h2>

<p><a href="/Mojolicious::Plugin::EPRenderer.html">Mojolicious::Plugin::EPRenderer</a>が提供する<code>ep</code>ではないテンプレートシステムがお好みのこともあるでしょう。また、CPANに登録されているプラグインのなかにお気に入りが見つからないかもしれません。そんなときは、新しい<code>handler</code> を <code>register</code>が呼び出されるとき、<a href="/Mojolicious::Renderer.html">Mojolicious::Renderer</a>の<code>add_handler</code>で追加すれば大丈夫です。</p>

<pre>package Mojolicious::Plugin::MyRenderer;
use Mojo::Base 'Mojolicious::Plugin';

sub register {
  my ($self, $app) = @_;

  # "mine"ハンドラーの追加
  $app->renderer->add_handler(mine => sub {
    my ($renderer, $c, $output, $options) = @_;

    # ワンタイム使用インラインテンプレートのチェック
    my $inline_template = $options->{inline};

    # "templates"ディレクトリに適切なテンプレートがあるかをチェック
    my $template_path = $renderer->template_path($options);

    # DATAセクションに適切なテンプレートがあるかをチェック
    my $data_template = $renderer->get_data_template($options);

    # この部分はあなたのテンプレートシステムに応じて変わります :)
    ...

    # 描画された結果をレンダラに渡す
    $$output = 'Hello World!';

    # またはエラーが起きたら終了する
    die 'Something went wrong with the template';
  });
}

1;</pre>

<p><code>inline</code>テンプレートは、ユーザーによって提供されると、オプションとともに渡されます。アプリケーションの<code>templates</code>ディレクトリを検索するには<a href="/Mojolicious::Renderer.html">Mojolicious::Renderer</a>の<code>template_path</code>が、<code>DATA</code>セクションを検索するには<a href="/Mojolicious::Renderer.html">Mojolicious::Renderer</a>の<code>get_data_template</code>が使えます。</p>

<pre>use Mojolicious::Lite;

plugin 'MyRenderer';

# インラインテンプレートの描画
get '/inline' => {inline => '...', handler => 'mine'};

# DATAセクションのテンプレートを描画
get '/data' => {template => 'test'};

app->start;
__DATA__;

@@ test.html.mine
...</pre>

<h2><a class='u'
name="_"
>バイナリデータを生成するためのハンドラを追加する</a></h2>

<p>デフォルトでは、レンダラはすべての<code>handler</code>が自動的にエンコードされる必要がある文字を生成しますが、代わりにバイトを生成することで簡単に無効にできます。</p>

<pre>use Mojolicious::Lite;
use Storable 'nfreeze';

# "storable"ハンドラを追加
app->renderer->add_handler(storable => sub {
  my ($renderer, $c, $output, $options) = @_;

  # 自動的なエンコーディングを削除
  delete $options->{encoding};

  # スタッシュのデータをエンコード
  $$output = nfreeze delete $c->stash->{storable};
});

# "storable" 値がすでにセットされている場合に"ハンドラ" 値を自動的にセットする
app->hook(before_render => sub {
  my ($c, $args) = @_;
  $args->{handler} = 'storable'
    if exists $args->{storable} || exists $c->stash->{storable};
});

get '/' => {storable => {i => '♥ mojolicious'}};

app->start;</pre>

<p><a href="/Mojolicious.html">Mojolicious</a>の<code>before_render</code>フックは、<code>storable</code>のようなスタッシュ値のために<code>handler</code>値を明示的にセットしなくて済むようにするなど、個別に対応するために使用できます。</p>

<pre># 明示的な"handler" 値
$c->render(storable => {i => '♥ mojolicious'}, handler => 'storable');

# 暗黙的な "handler" 値（"before_render" フックを使用）
$c->render(storable => {i => '♥ mojolicious'});</pre>

<h1><a class='u'
name="_"
>もっと学ぶには</a></h1>

<p>さあ、<a href="/Mojolicious::Guides.html">Mojolicious::Guides</a> を続けるか、<a href="http://github.com/mojolicious/mojo/wiki">Mojolicious wiki</a>を見てみましょう。多くの著者がドキュメントやサンプルをたくさん書いています。</p>

<h1><a class='u'
name="_"
>サポート</a></h1>

<p>このドキュメントでわからない部分があれば、 <a href="http://groups.google.com/group/mojolicious">mailing list</a> か<code>irc.freenode.net</code> (<a href="https://kiwiirc.com/nextclient/#irc://irc.freenode.net/mojo?nick=guest-?" class="podlinkurl"
>chat now!</a>)の公式IRCチャンネル <code>#mojo</code> まで気軽に質問してください。 (2019/08/16 Mojolicious 8.12を反映)</p>

<!-- end doc -->

</body></html>

  </div>
  <div class="bottom">
    <!-- bottom -->

  </div>
</div>

        </div>
        <div class="side">
          <!-- side -->
<div class="side-list">
  <div class="side-list-title">
    Side Bar
  </div>
  <ul>
    <li><a href="/list.html">Entries</a></li>
    <li>Bar</li>
    <li>Baz</li>
  </ul>
</div>

        </div>
      </div>
      <div class="footer">
        <!-- footer -->
<a href="https://github.com/yuki-kimoto/giblog">Giblog</a>

      </div>
    </div>
  </body>
</html>
