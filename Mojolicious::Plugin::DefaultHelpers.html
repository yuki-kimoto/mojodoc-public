<!DOCTYPE html>
<html>
  <head>
    <!-- meta -->
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0">
<link rel="icon" type="image/x-icon" href="/images/giblog-logo.png">
<link rel="stylesheet" type="text/css" href="/css/common.css">

<title> - Mojoliciousドキュメント 日本語訳</title>
<meta name="description" content="Mojolicious API リファレンス">
  </head>
  <body>
    <div class="container">
      <div class="header">
        <!-- header -->
<div class="main">
  <h1>
    <a href="/">Mojoliciousドキュメント 日本語訳</a>
  </h1>
</div>

      </div>
      <div class="main">
        <div class="content">
          <div class="entry">
  <div class="top">
    <!-- top -->

  </div>
  <div class="middle">
    <html><head><title>名前</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.40,
  using Pod::Simple::PullParser v3.40,
  under Perl v5.028000 at Tue Apr  7 04:08:46 2020 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<p><a href="/Mojolicious API リファレンス.html">Mojolicious API リファレンス</a></p>

<h1><a href="/Mojolicious::Plugin::DefaultHelpers.html"></a><a class='u'
name="_"
>名前</a></h1>

<p>Mojolicious::Plugin::DefaultHelpers - デフォルトヘルパープラグイン</p>

<h1><a class='u'
name="_"
>使い方</a></h1>

<pre># Mojolicious
$self->plugin('DefaultHelpers');

# Mojolicious::Lite
plugin 'DefaultHelpers';</pre>

<h1><a class='u'
name="_"
>説明</a></h1>

<p><a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>は<a href="/Mojolicious.html">Mojolicious</a>の レンダラのヘルパーの集合です。 これはコアのプラグインで、いつでも有効になっており、 そのコードは新しいプラグインを構築する ことを学ぶための良いサンプルです。</p>

<p>デフォルトで利用可能なプラグインの一覧は<a href="/Mojolicious::Plugins.html">Mojolicious::Plugins</a>の<code>プラグイン</code>の項目を見てください。</p>

<h1><a class='u'
name="_"
>ヘルパー</a></h1>

<h2><a class='u'
name="accepts"
>accepts</a></h2>

<pre>my $formats = $c->accepts;
my $format  = $c->accepts('html', 'json', 'txt');</pre>

<p><a href="/Mojolicious::Renderer.html">Mojolicious::Renderer</a>の<code>accepts</code>を使って <code>Accept</code>リクエストヘッダー、スタッシュの<code>format</code>の値、 あるいはから、リソースのためにもっともよい可能な表現 を選択します。<code>GET</code>/<code>POST</code>パラメーターの<code>format</code>の値 デフォルトでは優先順位が検知できなかった場合は、最初の拡張子が返却されます。</p>

<pre># JSONが受け入れかのうかチェック
$c->render(json => {hello => 'world'}) if $c->accepts('json');

# JSONが明確にリクエストされたかどうかのチェック
$c->render(json => {hello => 'world'}) if $c->accepts('', 'json');

# サポートしない表現
$c->render(data => '', status => 204)
  unless my $format = $c->accepts('html', 'json');

# 選択するための表現を検知
my @formats = @{$c->accepts};</pre>

<h2><a class='u'
name="app"
>app</a></h2>

<pre>%= app->secrets->[0]</pre>

<p><a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>app</code>のエイリアス。</p>

<h2><a class='u'
name="b"
>b</a></h2>

<pre>%= b('Joel is a slug')->slugify</pre>

<p>文字列を<a href="/Mojo::ByteStream.html">Mojo::ByteStream</a>オブジェクトに変換。</p>

<h2><a class='u'
name="c"
>c</a></h2>

<pre>%= c('a', 'b', 'c')->shuffle->join</pre>

<p>リストを<a href="/Mojo::Collection.html">Mojo::Collection</a>オブジェクトに変換。</p>

<h2><a class='u'
name="config"
>config</a></h2>

<pre>%= config 'something'</pre>

<p><a href="/Mojo.html">Mojo</a>の<code>config</code>のエイリアス。</p>

<h2><a class='u'
name="content"
>content</a></h2>

<pre>%= content foo => begin
  test
% end
%= content bar => 'Hello World!'
%= content 'foo'
%= content 'bar'
%= content</pre>

<p>名前つきのバッファの中に、部分的に描画されたコンテンツを保存し、取得します。 一般的には<code>layout</code>と<code>extends</code>を描画するために利用されます。 新しいコンテンツは名前つきバッファがすでに利用されていた場合は、 無視されることに注意してください。</p>

<h2><a class='u'
name="content_for"
>content_for</a></h2>

<pre>% content_for foo => begin
  test
% end
%= content_for 'foo'</pre>

<p><code>content</code>と同じですが、すでに使用中であれば名前つきバッファにコンテンツを追加します。</p>

<pre>% content_for message => begin
  Hello
% end
% content_for message => begin
  world!
% end
%= content 'message'</pre>

<h2><a class='u'
name="content_with"
>content_with</a></h2>

<pre>% content_with foo => begin
  test
% end
%= content_with 'foo'</pre>

<p><code>content</code>と同じですが、使用されていれば置き換えます。</p>

<pre>% content message => begin
  world!
% end
% content_with message => begin
  Hello <%= content 'message' %>
% end
%= content 'message'</pre>

<h2><a class='u'
name="continue"
>continue</a></h2>

<pre>$c->continue;</pre>

<p><a href="/Mojolicious::Routes.html">Mojolicious::Routes</a>の<code>continue</code>でディスパッチチェーンを継続します。</p>

<h2><a class='u'
name="csrf_token"
>csrf_token</a></h2>

<pre>%= csrf_token</pre>

<p><code>session</code>からCSRFトークンを取得します。 もしなけえれば、生成します。</p>

<h2><a class='u'
name="current_route"
>current_route</a></h2>

<pre>% if (current_route 'login') {
  Welcome to Mojolicious!
% }
%= current_route</pre>

<p>現在のルート名をチェック、あるいは取得します。</p>

<h2><a class='u'
name="dumper"
>dumper</a></h2>

<pre>%= dumper {some => 'data'}</pre>

<p><a href="/Mojo::Util.html">Mojo::Util</a>の<code>dumper</code>を使ってPerlのデータ構造をダンプします。 デバッグに便利です。</p>

<h2><a class='u'
name="extends"
>extends</a></h2>

<pre>% extends 'blue';
% extends 'blue', title => 'Blue!';</pre>

<p>テンプレートを拡張します。すべての追加のキーと値のペアは、「stash」にマージされます。</p>

<h2><a class='u'
name="flash"
>flash</a></h2>

<pre>my $foo = $c->flash('foo');
$c      = $c->flash({foo => 'bar'});
$c      = $c->flash(foo => 'bar');
%= flash 'foo'</pre>

<p><a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>flash</code>のエイリアス。</p>

<p>次のリクエストだけに持続するデータストレージ。「session」に保存されます。</p>

<pre># リダイレクトの後にメッセージを表示
$c->flash(message => 'User created successfully!');
$c->redirect_to('show_user', id => 23);</pre>

<h2><a class='u'
name="inactivity_timeout"
>inactivity_timeout</a></h2>

<pre>$c->inactivity_timeout(3600);</pre>

<p><a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>の<code>stream</code>を使って、 現在の接続を見つけ、可能であれば、タイムアウトを増やします。</p>

<pre># 長いバージョン
Mojo::IOLoop->stream($c->tx->connection)->timeout(3600);</pre>

<h2><a class='u'
name="include"
>include</a></h2>

<pre>%= include 'menubar'
%= include 'menubar', format => 'txt'</pre>

<p><a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>render_to_string</code>のエイリアスです。</p>

<h2><a class='u'
name="is_fresh"
>is_fresh</a></h2>

<pre>my $bool = $c->is_fresh;
my $bool = $c->is_fresh(etag => 'abc');
my $bool = $c->is_fresh(last_modified => $epoch);</pre>

<p><a href="/Mojolicious::Static.html">Mojolicious::Static</a>の<code>is_fresh</code>を使って <code>If-None-Match</code>、<code>If-Modified-Since</code>リクエストヘッダを <code>ETag</code>、<code>Last-Modified</code>レスポンスヘッダと比較することによって リクエストの新鮮さをチェックします。</p>

<pre># ETag/Last-Modifiedヘッダーを追加し、描画の前に新鮮さを確認する
$c->is_fresh(etag => 'abc', last_modified => 1424985708)
  ? $c->rendered(304)
  : $c->render(text => 'I ♥ Mojolicious!');</pre>

<h2><a class='u'
name="layout"
>layout</a></h2>

<pre>% layout 'green';
% layout 'green', title => 'Green!';</pre>

<p><code>layout</code>スタッシュの値を設定します。 キーと値のペアは、<code>stash</code>にマージされます。</p>

<h2><a class='u'
name="param"
>param</a></h2>

<pre>%= param 'foo'</pre>

<p><a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>param</code>のエイリアス。</p>

<h2><a class='u'
name="redirect_to"
>redirect_to</a></h2>

<pre>$c = $c->redirect_to('named', foo => 'bar');
$c = $c->redirect_to('named', {foo => 'bar'});
$c = $c->redirect_to('/index.html');
$c = $c->redirect_to('http://example.com/index.html');</pre>

<p><code>302</code>リダイレクトレスポンスを準備します。<code>url_for</code>と同じ引数を受け取ります。</p>

<pre># 永続的な移動
$c->res->code(301);
$c->redirect_to('some_route');

# 一時的なリダイレクト
$c->res->code(307);
$c->redirect_to('some_route');</pre>

<h2><a class='u'
name="reply->asset"
>reply->asset</a></h2>

<pre>$c->reply->asset(Mojo::Asset::File->new);</pre>

<p><a href="/Mojolicious::Static.html">Mojolicious::Static</a>の<code>serve_asset</code>を使って、 <a href="/Mojo::Asset::File.html">Mojo::Asset::File</a>あるいは<a href="/Mojo::Asset::Memory.html">Mojo::Asset::Memory</a>オブジェクトで応答し、 <code>Range</code>, <code>If-Modified-Since</code>,<code>If-None-Match</code>ヘッダで、 コンテンツネゴシエーションを実行します。</p>

<pre># カスタムの修正時刻でアセットをサーブ
my $asset = Mojo::Asset::Memory->new;
$asset->add_chunk('Hello World!')->mtime(784111777);
$c->res->headers->content_type('text/plain');
$c->reply->asset($asset);

# 存在するならば、静的ファイルをサーブ
if (my $asset = $c->app->static->file('images/logo.png')) {
  $c->res->headers->content_type('image/png');
  $c->reply->asset($asset);
}</pre>

<h2><a class='u'
name="reply->exception"
>reply->exception</a></h2>

<pre>$c = $c->reply->exception('Oops!');
$c = $c->reply->exception(Mojo::Exception->new('Oops!'));</pre>

<p>例外テンプレート<code>exception.$mode.$format.*</code>あるいは<code>exception.$format.*</code> を描画し、レスポンスステータスコードを<code>500</code>に設定します。 スタッシュの値の<code>exception</code>には、<a href="/Mojo::Exception.html">Mojo::Exception</a>オブジェクトが設定され <code>snapshot</code>には、テンプレートで使用されている<code>stash</code>のコピーへのが設定されます。</p>

<h2><a class='u'
name="reply->file"
>reply->file</a></h2>

<pre>$c->reply->file('/etc/passwd');</pre>

<p><a href="/Mojolicious.html">Mojolicious</a>の「static」を使って、ファイルシステムの絶対パスから静的ファイルを返答します。</p>

<pre># 長いバージョン
$c->reply->asset(Mojo::Asset::File->new(path => '/etc/passwd'));

# カスタムコンテントタイプで絶対パスからファイルをサーブ
$c->res->headers->content_type('application/myapp');
$c->reply->file('/home/sri/foo.txt');

# 秘密のアプリケーションディレクトリからファイルをサーブ
$c->reply->file($c->app->home->child('secret', 'file.txt'));</pre>

<h2><a class='u'
name="reply->not_found"
>reply->not_found</a></h2>

<pre>$c = $c->reply->not_found;</pre>

<p>Not Foundテンプレート<code>not_found.$mode.$format.*</code>か<code>not_found.$format.*</code> を描画し、レスポンスステータスコードを<code>404</code>に設定します。 スタッシュの値<code>snapshot</code>には、テンプレートで利用されている<code>stash</code>の コピーが設定されます。</p>

<h2><a class='u'
name="reply->static"
>reply->static</a></h2>

<pre>my $bool = $c->reply->static('images/logo.png');
my $bool = $c->reply->static('../lib/MyApp.pm');</pre>

<p><a href="/Mojolicious.html">Mojolicious</a>の<code>static</code>を使って 静的なファイルで応答します。 通常は、<code>public</code>ディレクトリかアプリケーションの<code>DATA</code>セクションが基点です。 このヘルパーは、親ディレクトリへのトラバーサルを防がないことに注意してください。</p>

<pre># カスタムコンテントタイプでファイルを応答する
$c->res->headers->content_type('application/myapp');
$c->reply->static('foo.txt');</pre>

<h2><a class='u'
name="respond_to"
>respond_to</a></h2>

<pre>$c->respond_to(
  json => {json => {message => 'Welcome!'}},
  html => {template => 'welcome'},
  any  => sub {...}
);</pre>

<p><code>Accept</code>リクエストヘッダ、<code>format</code>のスタッシュの値、<code>format</code>のGET/POSTパラメーターから、自動的に可能である最適なリソースの表現を選択します。デフォルトで空の<code>204</code>レスポンスを描画します。 ブラウザは実際にほしいものを知らないことがときどきあるので、 <code>X-Requested-With</code>ヘッダが値に設定されていない場合は、 ひとつ以上のMIMEタイプが含まれた<code>Accept</code>リクエストヘッダは無視されます。</p>

<pre># "json"と"xml"以外のすべては204レスポンスを得る
$c->respond_to(
  json => sub { $c->render_json({just => 'works'}) },
  xml  => {text => '<just>works</just>'},
  any  => {data => '', status => 204}
);</pre>

<p>より発展的なネゴシエーションのためには、 <a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>accepts</code>を使用することができます。</p>

<h2><a class='u'
name="session"
>session</a></h2>

<pre>%= session 'foo'</pre>

<p><a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>session</code>のエイリアス。</p>

<h2><a class='u'
name="stash"
>stash</a></h2>

<pre>%= stash 'foo'
% stash foo => 'bar';</pre>

<p><a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>stash</code>のエイリアス。</p>

<pre>%= stash('name') // 'Somebody'</pre>

<h2><a class='u'
name="timing->begin"
>timing->begin</a></h2>

<pre>$c->timing->begin('foo');</pre>

<p><a href="#timing-%3Eelapsed" class="podlinkpod"
>"timing->elapsed"</a>のために、名前付きのタイムスタンプを生成します。</p>

<h2><a class='u'
name="timing->elapsed"
>timing->elapsed</a></h2>

<pre>my $elapsed = $c->timing->elapsed('foo');</pre>

<p>「timing->begin」で名前付きtimstampが生成されてからの経過時間を秒単位で返します。 生成されたタイムスタンプがない場合は、<code>undef</code>を返します。</p>

<pre># 長いタイミング情報
$c->timing->begin('database_stuff');
...
my $elapsed = $c->timing->elapsed('database_stuff');
$c->app->log->debug("Database stuff took $elapsed seconds");</pre>

<h2><a class='u'
name="timing->rps"
>timing->rps</a></h2>

<pre>my $rps = $c->timing->rps('0.001');</pre>

<p>すべての単独のリクエストが1秒の間に費やした時間があれば、1秒間に実行できるリクエストの小数部を返します。 数が少なすぎる場合は、<code>undef</code>を返します。</p>

<pre># 多くのタイミング情報をログに出力
$c->timing->begin('web_stuff');
...
my $elapsed = $c->timing->elapsed('web_stuff');
my $rps     = $c->timing->rps($elapsed);
$c->app->log->debug("Web stuff took $elapsed seconds ($rps per second)");</pre>

<h2><a class='u'
name="timing->server_timing"
>timing->server_timing</a></h2>

<pre>$c->timing->server_timing('metric');
$c->timing->server_timing('metric', 'Some Description');
$c->timing->server_timing('metric', 'Some Description', '0.001');</pre>

<p>オプションの説明と期間を使って、<code>Server-Timing</code>ヘッダを生成します。</p>

<pre># "Server-Timing: miss"
$c->timing->server_timing('miss');

# "Server-Timing: dc;desc=atl"
$c->timing->server_timing('dc', 'atl');

# "Server-Timing: db;desc=Database;dur=0.0001"
$c->timing->begin('database_stuff');
...
my $elapsed = $c->timing->elapsed('database_stuff');
$c->timing->server_timing('db', 'Database', $elapsed);

# "Server-Timing: miss, dc;desc=atl"
$c->timing->server_timing('miss');
$c->timing->server_timing('dc', 'atl');</pre>

<h2><a class='u'
name="title"
>title</a></h2>

<pre>%= title
% title 'Welcome!';
% title 'Welcome!', foo => 'bar';</pre>

<p><code>title</code>スタッシュの値を、取得、設定します。 すべてのキーと値のペアはスタッシュにマージされます。</p>

<h2><a class='u'
name="ua"
>ua</a></h2>

<pre>%= ua->get('mojolicio.us')->res->dom->at('title')->text</pre>

<p><a href="/Mojo.html">Mojo</a>の<code>ua</code>のエイリアス。</p>

<h2><a class='u'
name="url_for"
>url_for</a></h2>

<pre>%= url_for 'named', controller => 'bar', action => 'baz'</pre>

<p><a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>の<code>url_for</code>のエイリアス。</p>

<pre>%= url_for('/index.html')->query(foo => 'bar')</pre>

<h2><a class='u'
name="url_with"
>url_with</a></h2>

<pre>%= url_with 'named', controller => 'bar', action => 'baz'</pre>

<p><code>url_for</code>と同じですが、現在のリクエストから クエリ文字列を受け継ぎます。</p>

<pre>%= url_with->query({page => 2})</pre>

<h2><a class='u'
name="validation"
>validation</a></h2>

<pre>my $validation = $c->validation;</pre>

<p><code>GET</code>と<code>POST</code>パラメーターを検証するための現在のリクエストのための <a href="/Mojolicious::Validator::Validation.html">Mojolicious::Validator::Validation</a>オブジェクトです。 リクエストボディの部分は、<code>POST</code>パラメーターを解析するために、 メモリ上にロードされる必要があります。 そのために大きくなりすぎないように注意してください、 デフォルトは16MBの制限があります。</p>

<pre># GET/POSTパラメーターを検証
my $v = $c->validation;
$v->required('title', 'trim')->size(3, 50);
my $title = $v->param('title');

# ファイルアップロードを検証
my $v = $c->validation;
$v->required('tarball')->upload->size(1, 1048576);
my $tarball = $v->param('tarball');</pre>

<h1><a class='u'
name="_"
>メソッド</a></h1>

<p><a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>は <a href="https://metacpan.org/pod/Mojolicious%3A%3APlugin" class="podlinkpod"
>Mojolicious::Plugin</a>からすべてのメソッドを継承しており、 次の新しいメソッドを実装しています。</p>

<h2><a class='u'
name="register"
>register</a></h2>

<pre>$plugin->register;</pre>

<p><a href="/Mojolicious.html">Mojolicious</a>アプリケーションにヘルパーを登録します。</p>

<h1><a class='u'
name="_"
>参考</a></h1>

<p><a href="https://metacpan.org/pod/Mojolicious" class="podlinkpod"
>Mojolicious</a>, <a href="https://metacpan.org/pod/Mojolicious%3A%3AGuides" class="podlinkpod"
>Mojolicious::Guides</a>, <a href="http://mojolicio.us" class="podlinkurl"
>http://mojolicio.us</a>.</p>

<p>(Mojolicious 8.12を反映。2019年6月12日更新)</p>

<!-- end doc -->

</body></html>

  </div>
  <div class="bottom">
    <!-- bottom -->

  </div>
</div>

        </div>
        <div class="side">
          <!-- side -->
<div class="side-list">
  <div class="side-list-title">
    Side Bar
  </div>
  <ul>
    <li><a href="/list.html">Entries</a></li>
    <li>Bar</li>
    <li>Baz</li>
  </ul>
</div>

        </div>
      </div>
      <div class="footer">
        <!-- footer -->
<a href="https://github.com/yuki-kimoto/giblog">Giblog</a>

      </div>
    </div>
  </body>
</html>
