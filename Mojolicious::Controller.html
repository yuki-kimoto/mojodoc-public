<!DOCTYPE html>
<html>
  <head>
    <!-- meta -->
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0">
<link rel="icon" type="image/x-icon" href="/images/giblog-logo.png">
<link rel="stylesheet" type="text/css" href="/css/common.css">

<title> - Mojoliciousドキュメント 日本語訳</title>
<meta name="description" content="Mojolicious API リファレンス">
  </head>
  <body>
    <div class="container">
      <div class="header">
        <!-- header -->
<div class="main">
  <h1>
    <a href="/">Mojoliciousドキュメント 日本語訳</a>
  </h1>
</div>

      </div>
      <div class="main">
        <div class="content">
          <div class="entry">
  <div class="top">
    <!-- top -->

  </div>
  <div class="middle">
    <html><head><title>名前</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.40,
  using Pod::Simple::PullParser v3.40,
  under Perl v5.028000 at Tue Apr  7 04:16:23 2020 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<p><a href="/Mojolicious API リファレンス.html">Mojolicious API リファレンス</a></p>

<h1><a href="/Mojolicious::Controller.html"></a><a class='u'
name="_"
>名前</a></h1>

<p>Mojolicious::Controller - コントローラーの基底クラス</p>

<h1><a class='u'
name="_"
>使い方</a></h1>

<pre># コントローラー
package MyApp::Controller::Foo;
use Mojo::Base 'Mojolicious::Controller';

# アクション
sub bar {
  my $self = shift;
  my $name = $self->param('name');
  $self->res->headers->cache_control('max-age=1, no-cache');
  $self->render(json => {hello => $name});
}</pre>

<h1><a class='u'
name="_"
>説明</a></h1>

<p><a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>はあなたの<a href="/Mojolicious.html">Mojolicious</a>のコントローラーの基底クラスです。 アプリケーションで<code>controller_class</code>を設定しない場合の、 <a href="/Mojolicious.html">Mojolicious</a>のデフォルトのコントローラークラスでもあります。</p>

<h1><a class='u'
name="_"
>属性</a></h1>

<p><a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>は<a href="/Mojo::Base.html">Mojo::Base</a>のすべてのメソッドを継承しており、 次の新しいメソッドを実装しています。</p>

<h2><a class='u'
name="app"
>app</a></h2>

<pre>my $app = $c->app;
$c      = $c->app(Mojolicious->new);</pre>

<p>このコントローラディスパッチさせたアプリケーションへの参照。通常は<a href="/Mojolicious.html">Mojolicious</a>オブジェクトです。ウィークリファレンスであることに注意してください。</p>

<pre># アプリケーションのロガーを使う
$c->app->log->debug('Hello Mojo');

# パスの生成
my $path = $c->app->home->child('templates', 'foo', 'bar.html.ep');</pre>

<h2><a class='u'
name="match"
>match</a></h2>

<pre>my $m = $c->match;
$c    = $c->match(Mojolicious::Routes::Match->new);</pre>

<p>現在のリクエストのルートの結果。デフォルトは<a href="/Mojolicious::Routes::Match.html">Mojolicious::Routes::Match</a>オブジェクトです。</p>

<pre># 使い方の例
my $name   = $c->match->endpoint->name;
my $foo    = $c->match->endpoint->pattern->defaults->{foo};
my $action = $c->match->stack->[-1]{action};</pre>

<h2><a class='u'
name="tx"
>tx</a></h2>

<pre>my $tx = $c->tx;
$c     = $c->tx(Mojo::Transaction::HTTP->new);</pre>

<p>現在実行されているトランザクション。通常は <a href="/Mojo::Transaction::HTTP.html">Mojo::Transaction::HTTP</a>か<a href="/Mojo::Transaction::WebSocket.html">Mojo::Transaction::WebSocket</a>オブジェクトです。 このリファレンスは通常は弱いリファレンスです。 ですので、ノンブロッキングの処理を行っていて 下層の接続が早期に閉じられるときは、 リファレンスは他の場所から参照されている必要があります。</p>

<pre># リモートの情報をチェック
my $address = $c->tx->remote_address;
my $port    = $c->tx->remote_port;

# WebSocketメッセージのサイズの制限を16MBに上げる
$c->tx->max_websocket_size(16777216) if $c->tx->is_websocket;

# 接続の状態を知ることなしに、ノンブロッキンの処理を実行する
my $tx = $c->tx;
Mojo::IOLoop->timer(2 => sub {
  $c->app->log->debug($tx->is_finished ? 'Finished' : 'In progress');
});</pre>

<h1><a class='u'
name="_"
>メソッド</a></h1>

<p><a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>は<a href="/Mojo::Base.html">Mojo::Base</a>のすべてのメソッドを継承しており、 次の新しいメソッドを実装しています。</p>

<h2><a class='u'
name="cookie"
>cookie</a></h2>

<pre>my $value = $c->cookie('foo');
$c        = $c->cookie(foo => 'bar');
$c        = $c->cookie(foo => 'bar', {path => '/'});</pre>

<p>リクエストのクッキーの値にアクセスし、新しいレスポンスのクッキーを生成します。 もし同じ名前で共有される複数の値があり、 最後のひとつ以外を取得したい場合は、 <code>every_cookie</code>を使用することができます。</p>

<pre># ドメインと有効期限つきのレスポンスクッキーを作成
$c->cookie(user => 'sri', {domain => 'example.com', expires => time + 60});

# セキュアなレスポンスクッキーを作成
$c->cookie(secret => 'I <3 Mojolicious', {secure => 1, httponly => 1});</pre>

<h2><a class='u'
name="every_cookie"
>every_cookie</a></h2>

<pre>my $values = $c->every_cookie('foo');</pre>

<p><code>cookie</code>と似ていますが、同じ名前で共有されるすべてのリクエストクッキーの値を 配列のリファレンスとして取得します。</p>

<pre>$ 最初のクッキーの値を取得
my $first = $c->every_cookie('foo')->[0];</pre>

<h2><a class='u'
name="every_param"
>every_param</a></h2>

<pre>my $values = $c->every_param('foo');</pre>

<p><code>param</code>と似ていますが、同じ名前で共有されるすべての値を、 配列のリファレンスとして取得します。</p>

<pre># 最初の値を取得
my $first = $c->every_param('foo')->[0];</pre>

<h2><a class='u'
name="every_signed_cookie"
>every_signed_cookie</a></h2>

<pre>my $values = $c->every_signed_cookie('foo');</pre>

<p><code>signed_cookie</code>と同じですが、同じ名前で共有される すべての署名つきリクエストクッキーを、 配列のリファレンスとして取得します。</p>

<pre># 最初の署名つきクッキーの値を取得
my $first = $c->every_signed_cookie('foo')->[0];</pre>

<h2><a class='u'
name="finish"
>finish</a></h2>

<pre>$c = $c->finish;
$c = $c->finish(1000);
$c = $c->finish(1003 => 'Cannot accept data!');
$c = $c->finish('Bye!');</pre>

<p>WebSocketコネクションかロングポーリングストリームを緩やかに終了させます。 このメソッドは、<code>101</code>レスポンスコードでのWebSocketハンドシェイクリクエストに自動的に対応し、 WebSocket接続を確立します。</p>

<h2><a class='u'
name="helpers"
>helpers</a></h2>

<pre>my $helpers = $c->helpers;</pre>

<p>現在のコントローラーオブジェクトを含んでいる プロキシオブジェクトを返却します。 これから、アプリケーション(<code>app</code>)によって提供されているヘルパーを、 呼び出すことが可能です。 これは <a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>と<a href="/Mojolicious::Plugin::TagHelpers.html">Mojolicious::Plugin::TagHelpers</a> のすべてのヘルパーを含んでいます。</p>

<pre># コントローラーメソッドではなく、"title"ヘルパーを確実に使う
$c->helpers->title('Welcome!');

# "reply"コントローラーメソッドではなく、ネストされたヘルパーを使う
$c->helpers->reply->not_found;</pre>

<h2><a class='u'
name="on"
>on</a></h2>

<pre>my $cb = $c->on(finish => sub {...});</pre>

<p><code>tx</code>のイベントを購読します。 <code>tx</code>は通常、<a href="/Mojo::Transaction::HTTP.html">Mojo::Transaction::HTTP</a>か<a href="/Mojo::Transaction::WebSocket.html">Mojo::Transaction::WebSocket</a>オブジェクトです。 このメソッドは自動的にWebSocketハンドシェイクリクエストに対しては<code>101</code>レスポンスステータス で応答することに注意してください。</p>

<pre># トランザクションが終了した後に何かを行う
$c->on(finish => sub {
  my $c = shift;
  $c->app->log->debug('We are done');
});

# WebSocketメッセージを受ける
$c->on(message => sub {
  my ($c, $msg) = @_;
  $c->app->log->debug("Message: $msg");
});

# JSONオブジェクトをWebSocketメッセージを通して受け取る
$c->on(json => sub {
  my ($c, $hash) = @_;
  $c->app->log->debug("Test: $hash->{test}");
});

# WebSocketのバイナリメッセージを受け取る
$c->on(binary => sub {
  my ($c, $bytes) = @_;
  my $len = length $bytes;
  $c->app->log->debug("Received $len bytes");
});</pre>

<h2><a class='u'
name="param"
>param</a></h2>

<pre>my $value = $c->param('foo');
$c        = $c->param(foo => 'ba;r');
$c        = $c->param(foo => qw(ba;r baz));
$c        = $c->param(foo => ['ba;r', 'baz']);</pre>

<p>スタッシュの値として予約されていないルートのプレースホルダーの値、 Get/POSTパラメーター、ファイルのアップロード(これらは、 クエリ文字列、<code>application/x-www-form-urlencoded</code>あるいは<code>multipart/form-data</code> のメッセージボディから、この順番で抽出される) にアクセスします。 同じ名前で共有されている複数の値があり、 最後のひとつ以外にアクセスしたい場合は、 <code>every_param</code>を使用することができます。 POSTパラメーターを解析するために、リクエストボディの部分はメモリ上に読み込まれる必要があるので、 大きすぎないようにするようにしてください。 この制限はデフォルトで16MBです。</p>

<pre># 最初の値を取得
my $first = $c->every_param('foo')->[0];</pre>

<p>さらにコントロールするために、リクエストの情報直接アクセスできます。</p>

<pre># GETパラメーターだけ
my $foo = $c->req->query_params->param('foo');

# POSTパラメーターだけ
my $foo = $c->req->body_params->param('foo');

# GETとPOSTパラメーターだけ
my $foo = $c->req->param('foo');

# アップロードされたファイルだけ
my $foo = $c->req->upload('foo');</pre>

<h2><a class='u'
name="render"
>render</a></h2>

<pre>my $bool = $c->render;
my $bool = $c->render(foo => 'bar', baz => 23);
my $bool = $c->render(template => 'foo/index');
my $bool = $c->render(template => 'index', format => 'html');
my $bool = $c->render(data => $bytes);
my $bool = $c->render(text => 'Hello!');
my $bool = $c->render(json => {foo => 'bar'});
my $bool = $c->render(handler => 'something');
my $bool = $c->render('foo/index');</pre>

<p><a href="/Mojolicious.html">Mojolicious</a>の<code>render</code>を使って コンテンツを描画し、<a href="/Mojolicious.html">Mojolicious</a>の<code>before_render</code>フックと<code>after_render</code>フックを発行します。 レスポンスが生成されない場合は、 <a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>reply->not_found</code>が呼び出されます。 後ろに続くすべてのキーと値のペアは、<code>stash</code>の中にマージされます。</p>

<pre># 文字を描画
$c->render(text => 'I ♥ Mojolicious!');

# 文字を描画(もう一つのやり方)
$c->stash(text => 'I ♥ Mojolicious!')->render;

# バイナリデータを描画
use Mojo::JSON 'encode_json';
$c->render(data => encode_json({test => 'I ♥ Mojolicious!'}));

# JSONを描画
$c->render(json => {test => 'I ♥ Mojolicious!'});

# インラインテンプレートを描画
$c->render(inline => '<%= 1 + 1 %>');

# テンプレート「foo/bar.html.ep」を描画
$c->render(template => 'foo/bar', format => 'html', handler => 'ep');

# 任意の値"foo"と"bar"をつけた、テンプレート"test.*.*"を描画
$c->render(template => 'test', foo => 'test', bar => 23);

# テンプレート「test.xml.*」を描画
$c->render(template => 'test', format => 'xml');</pre>

<h2><a class='u'
name="render_later"
>render_later</a></h2>

<pre>$c->render_later;</pre>

<p>レスポンスの生成を遅らせるために、自動的な描画を無効にします。 レスポンスの中で自動的な描画が結果を返さないときだけ必要になるでしょう。</p>

<pre># 遅らせた描画
$c->render_later;
Mojo::IOLoop->timer(2 => sub {
  $c->render(text => 'Delayed by 2 seconds!');
});</pre>

<h2><a class='u'
name="render_maybe"
>render_maybe</a></h2>

<pre>my $bool = $c->render_maybe;
my $bool = $c->render_maybe(controller => 'foo', action => 'bar');
my $bool = $c->render_maybe('foo/index', format => 'html');</pre>

<p>コンテンツを描画しようとしますが、レスポンスが生成されなければ<a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>reply->not_found</code>を呼びません。 すべての引数は、自動的にローカライズされ、この描画の処理の間だけ利用可能です。 「render」と同じ引数をとります。</p>

<pre># "index_local"テンプレートを存在するときだけ描画
$self->render_maybe('index_local') or $self->render('index');</pre>

<h2><a class='u'
name="render_to_string"
>render_to_string</a></h2>

<pre>my $output = $c->render_to_string('foo/index', format => 'pdf');</pre>

<p>コンテンツを描画しようとし、結果を<a href="/Mojo::ByteStream.html">Mojo::ByteStream</a>でラップされたオブジェクトを返却します。 できなければ、<code>undef</code>を返します。 すべての引数は自動的にローカライズされ、この描画処理の間でだけ 利用可能です。<code>render</code>と同じ引数をとります。</p>

<pre># インラインテンプレートを描画
my $two = $c->render_to_string(inline => '<%= 1 + 1 %>');</pre>

<h2><a class='u'
name="rendered"
>rendered</a></h2>

<pre>$c = $c->rendered;
$c = $c->rendered(302);</pre>

<p>レスポンスを終了させ、<code>after_dispatch</code>フックを発行します。 デフォルトは<code>200</code>レスポンスコードです。</p>

<pre># カスタムレスポンス
$c->res->headers->content_type('text/plain');
$c->res->body('Hello World!');
$c->rendered(200);</pre>

<h2><a class='u'
name="req"
>req</a></h2>

<pre>my $req = $c->req;</pre>

<p><code>tx</code>から<a href="/Mojo::Message::Request.html">Mojo::Message::Request</a>オブジェクトを取得します。</p>

<pre># 長いバージョン
my $req = $c->tx->req;

# リクエストの情報を抽出
my $id     = $c->req->request_id;
my $method = $c->req->method;
my $url    = $c->req->url->to_abs;
my $info   = $c->req->url->to_abs->userinfo;
my $host   = $c->req->url->to_abs->host;
my $agent  = $c->req->headers->user_agent;
my $custom = $c->req->headers->header('Custom-Header');
my $bytes  = $c->req->body;
my $str    = $c->req->text;
my $hash   = $c->req->params->to_hash;
my $all    = $c->req->uploads;
my $value  = $c->req->json;
my $foo    = $c->req->json('/23/foo');
my $dom    = $c->req->dom;
my $bar    = $c->req->dom('div.bar')->first->text;</pre>

<h2><a class='u'
name="res"
>res</a></h2>

<pre>my $res = $c->res;</pre>

<p><code>tx</code>から<a href="/Mojo::Message::Response.html">Mojo::Message::Response</a>オブジェクトを取得します。</p>

<pre># 長いバージョン
my $res = $c->tx->res;

# カスタムレスポンスヘッダを設定することによってファイルのダウンロードを強制する
$c->res->headers->content_disposition('attachment; filename=foo.png;');

# カスタムのレスポンスヘッダを使う
$c->res->headers->header('Custom-Header' => 'whatever');

# レスポンスが必ずキャッシュされるようにする
$c->res->headers->cache_control('public, max-age=300');
$c->res->headers->append(Vary => 'Accept-Encoding');</pre>

<h2><a class='u'
name="send"
>send</a></h2>

<pre>$c = $c->send({binary => $bytes});
$c = $c->send({text   => $bytes});
$c = $c->send({json   => {test => [1, 2, 3]}});
$c = $c->send([$fin, $rsv1, $rsv2, $rsv3, $op, $payload]);
$c = $c->send($chars);
$c = $c->send($chars => sub {...});</pre>

<p>WebSocketを通してノンブロッキングで、メッセージあるいはフレームを送信します。 オプションの排出コールバックは、データがすべて書き込まれた場合に 一度だけ実行されます。 このメソッドは、<code>101</code>レスポンスステータスで、WebSocketハンドシェイクリクエストに自動的に応答し、 WebSocket接続を確立します。</p>

<pre> # テキストメッセージを送信
 $c->send('I ♥ Mojolicious!');

 # JSONオブジェクトをテキストメッセージとして送信
 $c->send({json => {test => 'I ♥ Mojolicious!'}});

 # JSONオブジェクトをバイナリメッセージとして送信
 use Mojo::JSON 'encode_json';
 $c->send({binary => encode_json({test => 'I ♥ Mojolicious!'})});

 # PINフレームを送信
 use Mojo::WebSocket 'WS_PING';
 $c->send([1, 0, 0, 0, 9, 'Hello World!']);

 # 継続する前に以前のメッセージが書き込まれたことを確実にする
 $c->send('First message!' => sub {
   my $c = shift;
   $c->send('Second message!');
 });

ほどんどの時間がアイドル状態のWebソケットにおいては、
<a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>のC<inactivity_timeout>を使って、
インアクティビティタイムアウトを増やしたいと思うかもしれません。
通常はデフォルトで15秒です。

 # 接続のために300秒にインアクティビティタイムアウトを増やす
 $c->inactivity_timeout(300);</pre>

<h2><a class='u'
name="session"
>session</a></h2>

<pre>my $session = $c->session;
my $foo     = $c->session('foo');
$c          = $c->session({foo => 'bar'});
$c          = $c->session(foo => 'bar');</pre>

<p>持続的なデータストレージ。 暗号化クッキーの中に、JSON形式でシリアライズされ保存されます。 すべてのセッションデータは<a href="/Mojo::JSON.html">Mojo::JSON</a>によってシリアライズされ、 <code>HMAC-SHA1</code>による書名つきクッキーをつけて<code>Base64</code>でエンコードされて 保存されます。 クッキーは一般的に<code>4096</code>バイト(4KB)のデータに制限されることに注意してください。</p>

<pre># セッションを扱う
$c->session->{foo} = 'bar';
my $foo = $c->session->{foo};
delete $c->session->{foo};

# 今からの秒で指定する有効日付 (リクエストの間で存続する)
$c->session(expiration => 604800);

# 絶対的なエポック病で指定する有効日付 (ひとつのリクエストだけで有効)
$c->session(expires => time + 604800);

# 過去の有効日付を指定して、セッションを完全に削除するst
$c->session(expires => 1);</pre>

<h2><a class='u'
name="signed_cookie"
>signed_cookie</a></h2>

<pre>my $value = $c->signed_cookie('foo');
$c        = $c->signed_cookie(foo => 'bar');
$c        = $c->signed_cookie(foo => 'bar', {path => '/'});</pre>

<p>暗号化されたリクエストのクッキーにアクセスし、 新しい暗号化されたレスポンスのクッキーを作成します。 同じ名前共有される複数の値があり、 最後のひとつ以外の値にアクセスしたい場合は、 <code>every_signed_cookie</code>を使用できます。 <code>HMAC-SHA1</code>による署名による照合が失敗したクッキーは自動的に破棄されます。</p>

<h2><a class='u'
name="stash"
>stash</a></h2>

<pre>my $stash = $c->stash;
my $foo   = $c->stash('foo');
$c        = $c->stash({foo => 'bar'});
$c        = $c->stash(foo => 'bar');</pre>

<p>持続的ではないデータの保存と入れ替え。 アプリケーションのデフォルトの値は<a href="/Mojolicious.html">Mojolicious</a>の<code>defaults</code>で設定可能です。 多くのstashの値は特別な意味を持ち予約されています。 完全なリストは現在は、<code>action</code>, <code>app</code>, <code>cb</code>, <code>controller</code>, <code>data</code>, <code>extends</code>, <code>format</code>, <code>handler</code>, <code>json</code>, <code>layout</code>, <code>namespace</code>, <code>partial</code>, <code>path</code>, <code>status</code>, <code>template</code>, <code>text</code>, <code>variant</code>です。 内部的に利用される予約語については<code>mojo.*</code>プレフィックスがすべてのスタッシュの値につきます。</p>

<pre># 値を削除
my $foo = delete $c->stash->{foo};

# 複数の値を一度に代入
$c->stash(foo => 'test', bar => 23);</pre>

<h2><a class='u'
name="url_for"
>url_for</a></h2>

<pre>my $url = $c->url_for;
my $url = $c->url_for(name => 'sebastian');
my $url = $c->url_for({name => 'sebastian'});
my $url = $c->url_for('test', name => 'sebastian');
my $url = $c->url_for('test', {name => 'sebastian'});
my $url = $c->url_for('/index.html');
my $url = $c->url_for('//example.com/index.html');
my $url = $c->url_for('http://example.com/index.html');
my $url = $c->url_for('mailto:sri@example.com');
my $url = $c->url_for('#whatever');</pre>

<p>ルートやパスやURLのためにベース(URL)を持ったポータブルな<a href="/Mojo::URL.html">Mojo::URL</a>オブジェクトを生成します。</p>

<pre># 現在のルーティングでURLを再構築する
$c->url_for;

# 現在のルーティングでURLを再構築するが「name」プレースホルダーの値で置換する
$c->url_for(name => 'sebastian');

# 現在のルーティングの絶対URL
$c->url_for->to_abs;

# 二つのプレースホルダーの値でルーティング「test」のURLを構築する
$c->url_for('test', name => 'sebastian', foo => 'bar');

# "http://127.0.0.1:3000/index.html"(アプリケーションがMorboで開始されていた場合)
$c->url_for('/index.html')->to_abs;

# "https://127.0.0.1:443/index.html"(アプリケーションがMorboで開始されていた場合)
$c->url_for('/index.html')->to_abs->scheme('https')->port(443);

# "/index.html?foo=bar" (アプリケーションが「/」の下でデプロイされていた場合)
$c->url_for('/index.html')->query(foo => 'bar');

# "/myapp/index.html?foo=bar" (アプリケーションが「/myapp」の下でデプロイされていた場合)
$c->url_for('/index.html')->query(foo => 'bar');</pre>

<p>現在のリクエストからクエリパラメーターを受け継ぐために、 <a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>url_with</code>を使うこともできます。</p>

<pre># "/list?q=mojo&page=2" (現在のリクエストが"/list?q=mojo&page=1"の場合)
$c->url_with->query({page => 2});</pre>

<h2><a class='u'
name="write"
>write</a></h2>

<pre>$c = $c->write;
$c = $c->write('');
$c = $c->write($bytes);
$c = $c->write($bytes => sub {...});</pre>

<p>対応する<code>Content-Length</code>のチャンクサイズにマッチする動的なコンテンツをノンブロッキングで書き込みます。 オプションの排出コールバックは、すべてのデータが書き込まれた後に一度だけ実行されます。</p>

<pre># 接続をキープアライブに保つ(Content-Lengthヘッダーをつける)
$c->res->headers->content_length(6);
$c->write('Hel', sub {
  my $c = shift;
  $c->write('lo!');
});

# 終了したときに接続を閉じる(Content-Lengthヘッダーをつけない)
$c->write('Hel', sub {
  my $c = shift;
  $c->write('lo!', sub {
    my $c = shift;
    $c->finish;
  });
});</pre>

<p>「finish」メソッドを呼ぶか、空のチャンクデータを書き込むことで、いつでもストリームを終了できます。</p>

<pre>HTTP/1.1 200 OK
Connection: keep-alive
Date: Sat, 13 Sep 2014 16:48:29 GMT
Content-Length: 6
Server: Mojolicious (Perl)

Hello!

HTTP/1.1 200 OK
Connection: close
Date: Sat, 13 Sep 2014 16:48:29 GMT
Server: Mojolicious (Perl)

Hello!</pre>

<p>Comet (ロングポーリングにおいては)、 インアクティビティタイムアウトの値を <a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>の<code>inactivity_timeout</code> を使って、増やすこともできます。 デフォルトは<code>15</code>秒です。</p>

<pre># 現在のコネクションのタイムアウトを300秒に増やす
$c->inactivity_timeout(300);</pre>

<h2><a class='u'
name="write_chunk"
>write_chunk</a></h2>

<pre>$c = $c->write_chunk;
$c = $c->write_chunk('');
$c = $c->write_chunk($bytes);
$c = $c->write_chunk($bytes => sub {...});</pre>

<p><code>chunked</code>トランスファーエンコードで、動的なコンテンツをノンブロッキングで書き込みます。 オプションの排出コールバックは、すべてのデータが書き込まれた後に一度だけ実行されます。</p>

<pre># 継続するまえに前のチャンクが書き込まれることを確実にする
$c->write_chunk('H' => sub {
  my $c = shift;
  $c->write_chunk('ell' => sub {
    my $c = shift;
    $c->finish('o!');
  });
});</pre>

<p><code>finish</code>を呼ぶか、空のデータチャンクを書き込むことで、いつでもストリームの終わらせることができます。</p>

<pre>HTTP/1.1 200 OK
Date: Sat, 13 Sep 2014 16:48:29 GMT
Transfer-Encoding: chunked
Server: Mojolicious (Perl)

1
H
3
ell
2
o!
0</pre>

<h2><a class='u'
name="_"
>ヘルパー</a></h2>

<p>上記の属性とメソッドに加えて、<a href="/Mojolicious::Controller.html">Mojolicious::Controller</a>のインスタンスで、ヘルパーを呼ぶことができます。 これは<a href="/Mojolicious::Plugin::DefaultHelpers.html">Mojolicious::Plugin::DefaultHelpers</a>と<a href="/Mojolicious::Plugin::TagHelpers.html">Mojolicious::Plugin::TagHelpers</a>の すべてのヘルパーを含んでいます。</p>

<pre># ヘルパーを呼ぶ
$c->layout('green');
$c->title('Welcome!');

# 長いバージョン
$c->helpers->layout('green');</pre>

<h1><a class='u'
name="_"
>参考</a></h1>

<p><a href="https://metacpan.org/pod/Mojolicious" class="podlinkpod"
>Mojolicious</a>, <a href="https://metacpan.org/pod/Mojolicious%3A%3AGuides" class="podlinkpod"
>Mojolicious::Guides</a>, <a href="http://mojolicio.us" class="podlinkurl"
>http://mojolicio.us</a>.</p>

<p>(Mojolicious 8.12を反映。2019年6月11日更新)</p>

<!-- end doc -->

</body></html>

  </div>
  <div class="bottom">
    <!-- bottom -->

  </div>
</div>

        </div>
        <div class="side">
          <!-- side -->
<div class="side-list">
  <div class="side-list-title">
    Side Bar
  </div>
  <ul>
    <li><a href="/list.html">Entries</a></li>
    <li>Bar</li>
    <li>Baz</li>
  </ul>
</div>

        </div>
      </div>
      <div class="footer">
        <!-- footer -->
<a href="https://github.com/yuki-kimoto/giblog">Giblog</a>

      </div>
    </div>
  </body>
</html>
