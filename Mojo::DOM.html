<!DOCTYPE html>
<html>
  <head>
    <!-- meta -->
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0">
<link rel="icon" type="image/x-icon" href="/images/giblog-logo.png">
<link rel="stylesheet" type="text/css" href="/css/common.css">

<title> - Mojoliciousドキュメント 日本語訳</title>
<meta name="description" content="Mojolicious API リファレンス">
  </head>
  <body>
    <div class="container">
      <div class="header">
        <!-- header -->
<div class="main">
  <h1>
    <a href="/">Mojoliciousドキュメント 日本語訳</a>
  </h1>
</div>

      </div>
      <div class="main">
        <div class="content">
          <div class="entry">
  <div class="top">
    <!-- top -->

  </div>
  <div class="middle">
    <html><head><title>名前</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.40,
  using Pod::Simple::PullParser v3.40,
  under Perl v5.028000 at Tue Apr  7 04:16:23 2020 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<p><a href="/Mojolicious API リファレンス.html">Mojolicious API リファレンス</a></p>

<h1><a href="/Mojo::DOM.html"></a><a class='u'
name="_"
>名前</a></h1>

<p>Mojo::DOM - CSS3 セレクタを持つ最小限の XML/HTML5 DOM パーサ</p>

<h1><a class='u'
name="_"
>使い方</a></h1>

<pre>use Mojo::DOM;

# 解析
my $dom = Mojo::DOM->new('<div><p id="a">Test</p><p id="b">123</p></div>');

# 見つける
say $dom->at('#b')->text;
say $dom->find('p')->map('text')->join("\n");
say $dom->find('[id]')->map(attr => 'id')->join("\n");

# イテレート
$dom->find('p[id]')->reverse->each(sub { say $_->{id} });

# ループ
for my $e ($dom->find('p[id]')->each) {
  say $e->{id}, ':', $e->text;
}

# 修正
$dom->find('div p')->last->append('<p id="c">456</p>');
$dom->at('#c')->prepend($dom->new_tag('p', id => 'd', '789'));
$dom->find(':not(p)')->map('strip');

# 描画
say "$dom";</pre>

<h1><a class='u'
name="_"
>説明</a></h1>

<p><a href="/Mojo::DOM.html">Mojo::DOM</a> は CSS3 セレクタのサポートを持つ最小限かつとても緩やかな XML/HTML5 DOM パーサです。 これは壊れた XML でさえ解釈しようとするので、妥当性検証には使用するべきでは ありません。</p>

<h1><a class='u'
name="_"
>ノードと要素</a></h1>

<p>HTML/XMLの断片を解析しようとしたとき、結果はノードのツリーに変換されます。</p>

<pre><!DOCTYPE html>
<html>
  <head><title>Hello</title></head>
  <body>World!</body>
</html></pre>

<p>現在は、8種類のノード <code>cdata</code>, <code>comment</code>, <code>doctype</code>, <code>pi</code>, <code>raw</code>, <code>root</code>, <code>tag</code> and <code>text</code>があります。 要素は、<code>tag</code>のノードです。</p>

<pre>root
|- doctype (html)
+- tag (html)
   |- tag (head)
   |  +- tag (title)
   |     +- raw (Hello)
   +- tag (body)
      +- text (World!)</pre>

<p>すべてのノードタイプは、<a href="/Mojo::DOM.html">Mojo::DOM</a>オブジェクトとして表現されますが、 いくつかのメソッド、たとえば"attr"と"namespace"は、要素だけに適用されます。</p>

<h1><a class='u'
name="_"
>ケースセンシティビティ</a></h1>

<p><a href="/Mojo::DOM.html">Mojo::DOM</a>のデフォルトはHTMLの動作です。すべてのタグと属性は小文字化され、セレクタも同様に小文字を必要とします。</p>

<pre>my $dom = Mojo::DOM->new('<P ID="greeting">Hi!</P>');
say $dom->at('p[id]')->text;</pre>

<p>もしXMLの処理命令が発見されれば、パーサーは自動的にXMLモードに切り替わり、大文字小文字の区別がなされます。</p>

<pre>my $dom = Mojo::DOM->new('<?xml version="1.0"?><P ID="greeting">Hi!</P>');
say $dom->at('P[ID]')->text;</pre>

<p>XMLの検知は<code>xml</code>メソッドで無効にすることも可能です。</p>

<pre># HTMLセマンティクスの強制
my $dom = Mojo::DOM->new->xml(0)->parse('<P ID="greeting">Hi!</P>');
say $dom->at('p[id]')->text;

# XMLセマンティクスの強制
my $dom = Mojo::DOM->new->xml(1)->parse('<P ID="greeting">Hi!</P>');
say $dom->at('P[ID]')->text;</pre>

<h1><a class='u'
name="_"
>メソッド</a></h1>

<p><a href="/Mojo::DOM.html">Mojo::DOM</a> は以下のメソッドを実装しています。</p>

<h2><a class='u'
name="all_text"
>all_text</a></h2>

<pre>my $text = $dom->all_text;</pre>

<p>この要素のすべての下部のノードからすべてのテキスト内容を抽出します。 デフォルトでスマートな空白の除去が有効になっています。</p>

<pre># "foo\nbarbaz\n"
$dom->parse("<div>foo\n<p>bar</p>baz\n</div>")->at('div')->all_text;</pre>

<h2><a class='u'
name="ancestors"
>ancestors</a></h2>

<pre>my $collection = $dom->ancestors;
my $collection = $dom->ancestors('div ~ p');</pre>

<p>CSSセレクタにマッチするこのノードのすべての祖先を探索し、 <a href="/Mojo::DOM.html">Mojo::DOM</a>オブジェクトとしてこれらの要素を含んでいる<a href="/Mojo::Collection.html">Mojo::Collection</a>オブジェクト を返却します。 <a href="/Mojo::DOM::CSS.html">Mojo::DOM::CSS</a>の<code>SELECTORS</code>のすべてのセレクタをサポートしています。</p>

<pre># 祖先の要素のタグ名を一覧する
say $dom->ancestors->map('tag')->join("\n");</pre>

<h2><a class='u'
name="append"
>append</a></h2>

<pre>$dom = $dom->append('<p>I ♥ Mojolicious!</p>');
$dom = $dom->append(Mojo::DOM->new);</pre>

<p>HTML/XMLの断片をこのノードに追加します。</p>

<pre># "<div><h1>Test</h1><h2>123</h2></div>"
$dom->parse('<div><h1>Test</h1></div>')
  ->at('h1')->append('<h2>123</h2>')->root;

# "<p>Test 123</p>"
$dom->parse('<p>Test</p>')->at('p')
  ->child_nodes->first->append(' 123')->root;</pre>

<h2><a class='u'
name="append_content"
>append_content</a></h2>

<pre>$dom = $dom->append_content('<p>I ♥ Mojolicious!</p>');
$dom = $dom->append_content(Mojo::DOM->new);</pre>

<p>HTML/XMLフラグメント(<code>root</code>や<code>tag</code>ノード)、または生のコンテンツを このノードのコンテンツに追加します。</p>

<pre># "<div><h1>Test123</h1></div>"
$dom->parse('<div><h1>Test</h1></div>')
  ->at('h1')->append_content('123')->root;

# "<!-- Test 123 --><br>"
$dom->parse('<!-- Test --><br>')
  ->child_nodes->first->append_content('123 ')->root;

# "<p>Test<i>123</i></p>"
$dom->parse('<p>Test</p>')->at('p')->append_content('<i>123</i>')->root;</pre>

<h2><a class='u'
name="at"
>at</a></h2>

<pre>my $result = $dom->at('div ~ p');
my $result = $dom->at('svg|line', svg => 'http://www.w3.org/2000/svg');</pre>

<p>CSSセレクタにより、この要素の最初の子孫の要素を見つけ、 <a href="/Mojo::DOM.html">Mojo::DOM</a>オブジェクトとして 返却します。何も見つからなければ未定義値が返却されます。 <a href="/Mojo::DOM::CSS.html">Mojo::DOM::CSS</a>のセレクタの項目に記述されているセレクタがサポートされます。</p>

<pre># svg名前空間定義で最初の要素を見つける
my $namespace = $dom->at('[xmlns\:svg]')->{'xmlns:svg'};</pre>

<p>後ろに続くキーと値のペアは、xml名前空間のエイリアスを定義するために利用されます。</p>

<pre># "<rect />"
$dom->parse('<svg xmlns="http://www.w3.org/2000/svg"><rect /></svg>')
  ->at('svg|rect', svg => 'http://www.w3.org/2000/svg');</pre>

<h2><a class='u'
name="attr"
>attr</a></h2>

<pre>my $hash = $dom->attr;
my $foo  = $dom->attr('foo');
$dom     = $dom->attr({foo => 'bar'});
$dom     = $dom->attr(foo => 'bar');</pre>

<p>この要素の属性。</p>

<pre># 属性を削除する
delete $dom->attr->{id};

# 値のない属性
$dom->attr(selected => undef);

# id属性を一覧する
say $dom->find('*')->map(attr => 'id')->compact->join("\n");</pre>

<h2><a class='u'
name="child_nodes"
>child_nodes</a></h2>

<pre>my $collection = $dom->child_nodes;</pre>

<p>この要素のすべての子ノードを<a href="/Mojo::DOM.html">Mojo::DOM</a>として含む<a href="/Mojo::Collection.html">Mojo::Collection</a>オブジェクトを返却します。</p>

<pre># "<p><b>123</b></p>"
$dom->parse('<p>Test<b>123</b></p>')->at('p')->child_nodes->first->remove;

# "<!-- Test -->"
$dom->parse('<!-- Test --><b>123</b>')->child_nodes->first;</pre>

<h2><a class='u'
name="children"
>children</a></h2>

<pre>my $collection = $dom->children;
my $collection = $dom->children('div ~ p');</pre>

<p><code>find</code>と似ていて、この要素の子供を含む<a href="/Mojo::Collection.html">Mojo::Collection</a>オブジェクトを返却します。 <a href="/Mojo::DOM.html">Mojo::DOM</a>オブジェクトの集まりです。 <a href="/Mojo::DOM::CSS.html">Mojo::DOM::CSS</a>のセレクタの項目に記述されているセレクタがサポートされます。</p>

<pre># ランダムな子要素のタグ名を表示する
say $dom->children->shuffle->first->tag;</pre>

<h2><a class='u'
name="content"
>content</a></h2>

<pre>my $str = $dom->content;
$dom    = $dom->content('<p>I ♥ Mojolicious!</p>');
$dom    = $dom->content(Mojo::DOM->new);</pre>

<p>このエレメントのコンテンツを返却、あるいはHTML/XMLの断片か生のコンテンツに置換します。</p>

<pre># "<b>Test</b>"
$dom->parse('<div><b>Test</b></div>')->at('div')->content;

# "<div><h1>123</h1></div>"
$dom->parse('<div><h1>Test</h1></div>')->at('h1')->content('123')->root;

# "<p><i>123</i></p>"
$dom->parse('<p>Test</p>')->at('p')->content('<i>123</i>')->root;

# "<div><h1></h1></div>"
$dom->parse('<div><h1>Test</h1></div>')->at('h1')->content('')->root;

# " Test "
$dom->parse('<!-- Test --><br>')->child_nodes->first->content;

# "<div><!-- 123 -->456</div>"
$dom->parse('<div><!-- Test -->456</div>')
  ->at('div')->child_nodes->first->content(' 123 ')->root;</pre>

<h2><a class='u'
name="descendant_nodes"
>descendant_nodes</a></h2>

<pre>my $collection = $dom->descendant_nodes;</pre>

<p><a href="/Mojo::DOM.html">Mojo::DOM</a>オブジェクトとして、この要素の子孫ノードを含んでいる<a href="/Mojo::Collection.html">Mojo::Collection</a>オブジェクトを返却します。</p>

<pre># "<p><b>123</b></p>"
$dom->parse('<p><!-- Test --><b>123<!-- 456 --></b></p>')
  ->descendant_nodes->grep(sub { $_->type eq 'comment' })
  ->map('remove')->first;

# "<p><b>test</b>test</p>"
$dom->parse('<p><b>123</b>456</p>')
  ->at('p')->descendant_nodes->grep(sub { $_->type eq 'text' })
  ->map(content => 'test')->first->root;</pre>

<h2><a class='u'
name="find"
>find</a></h2>

<pre>my $collection = $dom->find('div ~ p');
my $collection = $dom->find('svg|line', svg => 'http://www.w3.org/2000/svg');</pre>

<p>CSS3セレクタを使って要素を検索し、<a href="/Mojo::Collection.html">Mojo::Collection</a>オブジェクトを返却します。 <a href="/Mojo::DOM.html">Mojo::DOM</a>オブジェクトの集まりです。 <a href="/Mojo::DOM::CSS.html">Mojo::DOM::CSS</a>のすべてのセレクタがサポートされています。 <a href="/Mojo::DOM::CSS.html">Mojo::DOM::CSS</a>のセレクタの項目に記述されているセレクタがサポートされます。</p>

<pre># 特定の要素を検索し、情報を抽出します。
my $id = $dom->find('div')->[23]{id};

# 複数の要素から情報を抽出します。
my @headers = $dom->find('h1, h2, h3')->text->each;
my @headers = $dom->find('h1, h2, h3')->map('text')->each;

# すべての異なるタグをカウントします
my $hash = $dom->find('*')->reduce(sub { $a->{$b->tag}++; $a }, {});

# ドットを含むクラスを使って、要素を探す
my @divs = $dom->find('div.foo\.bar')->each;</pre>

<p>後ろに続くキーと値のペアは、xml名前空間のエイリアスを宣言するために利用されます。</p>

<pre># "<rect />"
$dom->parse('<svg xmlns="http://www.w3.org/2000/svg"><rect /></svg>')
  ->find('svg|rect', svg => 'http://www.w3.org/2000/svg')->first;</pre>

<h2><a class='u'
name="following"
>following</a></h2>

<pre>my $collection = $dom->following;
my $collection = $dom->following('div ~ p');</pre>

<p>CSSセレクタにマッチする、このノードの後のすべての兄弟要素を検索し、 これらの要素を<a href="/Mojo::DOM.html">Mojo::DOM</a>オブジェクトとして含む<a href="/Mojo::Collection.html">Mojo::Collection</a> オブジェクトを返却します。 <a href="/Mojo::DOM::CSS.html">Mojo::DOM::CSS</a>の<code>SELECTORS</code>の目次のすべてのセレクタがサポートされています。</p>

<pre># このノードの後の兄弟要素のタグを一覧する
say $dom->following->map('tag')->join("\n");</pre>

<h2><a class='u'
name="following_nodes"
>following_nodes</a></h2>

<pre>my $collection = $dom->following_nodes;</pre>

<p>このノードの後のすべての兄弟ノードを<a href="/Mojo::DOM.html">Mojo::DOM</a>として含む<a href="/Mojo::Collection.html">Mojo::Collection</a> オブジェクトを返却します。</p>

<pre># "C"
$dom->parse('<p>A</p><!-- B -->C')->at('p')->following_nodes->last->content;</pre>

<h2><a class='u'
name="match"
>match</a></h2>

<pre>my $bool = $dom->matches('div ~ p');
my $bool = $dom->matches('svg|line', svg => 'http://www.w3.org/2000/svg');</pre>

<p>この要素へのCSSセレクタにマッチする、<a href="/Mojo::DOM.html">Mojo::DOM</a>オブジェクトを返却します。 <a href="/Mojo::DOM::CSS.html">Mojo::DOM::CSS</a>のセレクタの項目に記述されているセレクタがサポートされます。</p>

<pre># 真
$dom->parse('<p class="a">A</p>')->at('p')->matches('.a');
$dom->parse('<p class="a">A</p>')->at('p')->matches('p[class]');

# 偽
$dom->parse('<p class="a">A</p>')->at('p')->matches('.b');
$dom->parse('<p class="a">A</p>')->at('p')->matches('p[id]');</pre>

<p>後ろに続くキーと値のペアは、xml名前空間のエイリアスを宣言するために利用されます。</p>

<pre># 真
$dom->parse('<svg xmlns="http://www.w3.org/2000/svg"><rect /></svg>')
  ->matches('svg|rect', svg => 'http://www.w3.org/2000/svg');</pre>

<h2><a class='u'
name="namespace"
>namespace</a></h2>

<pre>my $namespace = $dom->namespace;</pre>

<p>この要素のネームスペースを検索します。見つからなければ、<code>undef</code>を返却します。</p>

<pre># 名前空間のプレフィックスを持つ要素のための名前空間を見つける
my $namespace = $dom->at('svg > svg\:circle')->namespace;

# 名前空間のプレフィックスを持つかもしれない要素のための名前空間を見つける
my $namespace = $dom->at('svg > circle')->namespace;</pre>

<h2><a class='u'
name="new"
>new</a></h2>

<pre>my $dom = Mojo::DOM->new;
my $dom = Mojo::DOM->new('<foo bar="baz">I ♥ Mojolicious!</foo>');</pre>

<p>新しい配列ベースの<a href="/Mojo::DOM.html">Mojo::DOM</a>オブジェクトを構築し、 必要であればHTML/XMLドキュメントを"parse"を使って解析します。</p>

<h2><a class='u'
name="new_tag"
>new_tag</a></h2>

<pre>my $tag = Mojo::DOM->new_tag('div');
my $tag = $dom->new_tag('div');
my $tag = $dom->new_tag('div', id => 'foo', hidden => undef);
my $tag = $dom->new_tag('div', 'safe content');
my $tag = $dom->new_tag('div', id => 'foo', 'safe content');
my $tag = $dom->new_tag('div', data => {mojo => 'rocks'}, 'safe content');
my $tag = $dom->new_tag('div', id => 'foo', sub { 'unsafe content' });</pre>

<p>属性とコンテンツあり、または、なしのHTML/XMLタグを指定して<a href="/Mojo::DOM.html">Mojo::DOM</a>オブジェクトを構築します。 <code>data</code>属性は、属性を生成するために、キーと値のペアのハッシュリファレンスを含むことができます。</p>

<pre># "<br>"
$dom->new_tag('br');

# "<div></div>"
$dom->new_tag('div');

# "<div id="foo" hidden></div>"
$dom->new_tag('div', id => 'foo', hidden => undef);

# "<div>test &amp; 123</div>"
$dom->new_tag('div', 'test & 123');

# "<div id="foo">test &amp; 123</div>"
$dom->new_tag('div', id => 'foo', 'test & 123');

# "<div data-foo="1" data-bar="test">test &amp; 123</div>""
$dom->new_tag('div', data => {foo => 1, Bar => 'test'}, 'test & 123');

# "<div id="foo">test & 123</div>"
$dom->new_tag('div', id => 'foo', sub { 'test & 123' });

# "<div>Hello<b>Mojo!</b></div>"
$dom->parse('<div>Hello</div>')->at('div')
  ->append_content($dom->new_tag('b', 'Mojo!'))->root;</pre>

<h2><a class='u'
name="next"
>next</a></h2>

<pre>my $sibling = $dom->next;</pre>

<p>要素の次の兄弟を返却します。これ<a href="/Mojo::DOM.html">Mojo::DOM</a>オブジェクトです。 兄弟要素がない場合は未定義値を返却します。</p>

<pre># "<h2>123</h2>"
$dom->parse('<div><h1>Test</h1><h2>123</h2></div>')->at('h1')->next;</pre>

<h2><a class='u'
name="next_node"
>next_node</a></h2>

<pre>my $sibling = $dom->next_node;</pre>

<p>次の兄弟ノードとして<a href="/Mojo::DOM.html">Mojo::DOM</a>オブジェクトを返却し、もし兄弟がいなければ、<code>undef</code>を返却します。</p>

<pre># "456"
$dom->parse('<p><b>123</b><!-- Test -->456</p>')
  ->at('b')->next_node->next_node;

# " Test "
$dom->parse('<p><b>123</b><!-- Test -->456</p>')
  ->at('b')->next_node->content;</pre>

<h2><a class='u'
name="parent"
>parent</a></h2>

<pre>my $parent = $dom->parent;</pre>

<p>このノードの親を<a href="/Mojo::DOM.html">Mojo::DOM</a>オブジェクトとして返却します。 親要素がない場合は未定義値を返却します。</p>

<pre># "<b><i>Test</i></b>"
$dom->parse('<p><b><i>Test</i></b></p>')->at('i')->parent;</pre>

<h2><a class='u'
name="parse"
>parse</a></h2>

<pre>$dom = $dom->parse('<foo bar="baz">I ♥ Mojolicious!</foo>');</pre>

<p><a href="/Mojo::DOM::HTML.html">Mojo::DOM::HTML</a>を使って、HTML/XMLの断片を解析します。</p>

<pre># XMLを解析
my $dom = Mojo::DOM->new->xml(1)->parse('<foo>I ♥ Mojolicious!</foo>');</pre>

<h2><a class='u'
name="preceding"
>preceding</a></h2>

<pre>my $collection = $dom->preceding;
my $collection = $dom->preceding('div > p');</pre>

<p>CSSセレクタにマッチする、このノードの前のすべての兄弟要素を検索し、 これらの要素を<a href="/Mojo::DOM.html">Mojo::DOM</a>オブジェクトとして含む<a href="/Mojo::Collection.html">Mojo::Collection</a> オブジェクトを返却します。 <a href="/Mojo::DOM::CSS.html">Mojo::DOM::CSS</a>の<code>SELECTORS</code>の目次のすべてのセレクタがサポートされています。</p>

<pre># このノードの前の兄弟要素のタグをリストする
say $dom->preceding->map('tag')->join("\n");</pre>

<h2><a class='u'
name="preceding_nodes"
>preceding_nodes</a></h2>

<pre>my $collection = $dom->preceding_nodes;</pre>

<p>このノードの前のすべての兄弟ノードを<a href="/Mojo::DOM.html">Mojo::DOM</a>として含む<a href="/Mojo::Collection.html">Mojo::Collection</a> オブジェクトを返却します。</p>

<pre># "A"
$dom->parse('A<!-- B --><p>C</p>')->at('p')->preceding_nodes->first->content;</pre>

<h2><a class='u'
name="prepend"
>prepend</a></h2>

<pre>$dom = $dom->prepend('<p>I ♥ Mojolicious!</p>');
$dom = $dom->prepend(Mojo::DOM->new);</pre>

<p>HTML/XMLの断片をこのノードの要素の前に追加します。<code>root</code>を除くすべてのノードタイプ。</p>

<pre># "<div><h1>Test</h1><h2>123</h2></div>"
$dom->parse('<div><h2>123</h2></div>')
  ->at('h2')->prepend('<h1>Test</h1>')->root;

# "<p>Test 123</p>"
$dom->parse('<p>123</p>')
  ->at('p')->child_nodes->first->prepend('Test ')->root;</pre>

<h2><a class='u'
name="prepend_content"
>prepend_content</a></h2>

<pre>$dom = $dom->prepend_content('<p>I ♥ Mojolicious!</p>');
$dom = $dom->prepend_content(Mojo::DOM->new);</pre>

<p>新しいHTML/XMLの断片(<code>root</code>と<code>tag</code>のノード)あるいは生のコンテンツを、このノードのコンテンツの前に追加します。</p>

<pre># "<div><h2>Test123</h2></div>"
$dom->parse('<div><h2>123</h2></div>')
  ->at('h2')->prepend_content('Test')->root;

# "<!-- Test 123 --><br>"
$dom->parse('<!-- 123 --><br>')
  ->child_nodes->first->prepend_content(' Test')->root;

# "<p><i>123</i>Test</p>"
$dom->parse('<p>Test</p>')->at('p')->prepend_content('<i>123</i>')->root;</pre>

<h2><a class='u'
name="previous"
>previous</a></h2>

<pre>my $sibling = $dom->previous;</pre>

<p>要素の前の兄弟を返却します。これは<a href="/Mojo::DOM.html">Mojo::DOM</a>オブジェクトです。 兄弟がいない場合は、未定義値を返却します。</p>

<pre># "<h1>Test</h1>"
$dom->parse('<div><h1>Test</h1><h2>123</h2></div>')->at('h2')->previous;</pre>

<h2><a class='u'
name="previous_node"
>previous_node</a></h2>

<pre>my $sibling = $dom->previous_node;</pre>

<p>前の兄弟ノードを<a href="/Mojo::DOM.html">Mojo::DOM</a>として返却し、もし兄弟がいなければ<code>undef</code>を返却します。</p>

<pre># "123"
$dom->parse('<p>123<!-- Test --><b>456</b></p>')
  ->at('b')->previous_node->previous_node;

# " Test "
$dom->parse('<p>123<!-- Test --><b>456</b></p>')
  ->at('b')->previous_node->content;</pre>

<h2><a class='u'
name="remove"
>remove</a></h2>

<pre>my $parent = $dom->remove;</pre>

<p>要素を削除して、"root"(<code>root</code>ノードのために)か"parent"を返却します。</p>

<pre> # "<div></div>"
 $dom->parse('<div><h1>Test</h1></div>')->at('h1')->remove;

 # "<p><b>456</b></p>"
 $dom->parse('<p>123<b>456</b></p>')
   ->at('p')->child_nodes->first->remove->root;</pre>

<h2><a class='u'
name="replace"
>replace</a></h2>

<pre>my $parent = $dom->replace('<div>I ♥ Mojolicious!</div>');
my $parent = $dom->replace(Mojo::DOM->new);</pre>

<p>要素をXML/HTMLフラグメントで置換し、"root"(<code>root</code>ノードのために)か"parent"を返却します。</p>

<pre> # "<div><h2>123</h2></div>"
 $dom->parse('<div><h1>Test</h1></div>')->at('h1')->replace('<h2>123</h2>');

 # "<p><b>B</b></p>"
 $dom->parse('<p>A</p>')->at('p')->contents->[0]->replace('<b>B</b>')->root;</pre>

<h2><a class='u'
name="root"
>root</a></h2>

<pre>my $root = $dom->root;</pre>

<p>ルートノードを返却します。これは<a href="/Mojo::DOM.html">Mojo::DOM</a>オブジェクトです。</p>

<h2><a class='u'
name="selector"
>selector</a></h2>

<pre>my $selector = $dom->selector;</pre>

<p>この要素のためのユニークなCSSセレクタを取得します。</p>

<pre># "ul:nth-child(1) > li:nth-child(2)"
$dom->parse('<ul><li>Test</li><li>123</li></ul>')->find('li')->last->selector;

# "p:nth-child(1) > b:nth-child(1) > i:nth-child(1)"
$dom->parse('<p><b><i>Test</i></b></p>')->at('i')->selector;</pre>

<h2><a class='u'
name="strip"
>strip</a></h2>

<pre> my $parent = $dom->strip;</pre>

<p>このエレメントを削除しますが、そのコンテンツを保存し、親(parent)を返却します。</p>

<pre># "<div>Test</div>"
$dom->parse('<div><h1>Test</h1></div>')->at('h1')->strip;</pre>

<h2><a class='u'
name="tag"
>tag</a></h2>

<pre> my $tag = $dom->tag;
 $dom    = $dom->tag('div');</pre>

<p>この要素のタグ名。</p>

<pre># 子供の要素のタグ名の一覧
say $dom->children->map('tag')->join("\n");</pre>

<h2><a class='u'
name="tap"
>tap</a></h2>

<pre>$dom = $dom->tap(sub {...});</pre>

<p><a href="/Mojo::Base.html">Mojo::Base</a>の<code>tab</code>の別名。</p>

<h2><a class='u'
name="text"
>text</a></h2>

<pre>my $trimmed   = $dom->text;</pre>

<p>テキストコンテンツのみ(子要素を含まない)を抽出します。</p>

<pre># "bar"
$dom->parse("<div>foo<p>bar</p>baz</div>")->at('p')->text;

# "foo\nbaz\n"
$dom->parse("<div>foo\n<p>bar</p>baz\n</div>")->at('div')->text;</pre>

<h2><a class='u'
name="to_string"
>to_string</a></h2>

<pre>my $str = $dom->to_string;</pre>

<p>このノードとコンテンツをHTML/XMLに描画します。</p>

<pre># "<b>Test</b>"
$dom->parse('<div><b>Test</b></div>')->at('div b')->to_string;</pre>

<h2><a class='u'
name="tree"
>tree</a></h2>

<pre>my $tree = $dom->tree;
$dom     = $dom->tree(['root']);</pre>

<p>ドキュメントオブジェクトモデル。 この構造は、とても動的なものなので、とても慎重に扱うべきです。</p>

<h2><a class='u'
name="type"
>type</a></h2>

<pre>my $type = $dom->type;</pre>

<p>このノードのタイプ、通常は<code>cdata</code>, <code>comment</code>, <code>doctype</code>, <code>pi</code>, <code>raw</code>, <code>root</code>, <code>tag</code> or <code>text</code>。</p>

<pre># "cdata"
$dom->parse('<![CDATA[Test]]>')->child_nodes->first->type;

# "comment"
$dom->parse('<!-- Test -->')->child_nodes->first->type;

# "doctype"
$dom->parse('<!DOCTYPE html>')->child_nodes->first->type;

# "pi"
$dom->parse('<?xml version="1.0"?>')->child_nodes->first->type;

# "raw"
$dom->parse('<title>Test</title>')->at('title')->child_nodes->first->type;

# "root"
$dom->parse('<p>Test</p>')->type;

# "tag"
$dom->parse('<p>Test</p>')->at('p')->type;

# "text"
$dom->parse('<p>Test</p>')->at('p')->child_nodes->first->type;</pre>

<h2><a class='u'
name="val"
>val</a></h2>

<pre>my $value = $dom->val;</pre>

<p><code>button</code>, <code>input</code>, <code>option</code>, <code>select</code>,<code>textarea</code>などの要素から値を抽出します。 この要素が値を持たない場合は、未定義値を返します。 <code>multiple</code>属性を持つ<code>select</code>の場合は、<code>selected</code>が指定された<code>option</code>を探し、すべての値を配列のリファレンスで返します。 見つからなければ、未定義値を返します。</p>

<pre># "a"
$dom->parse('<input name=test value=a>')->at('input')->val;

# "b"
$dom->parse('<textarea>b</textarea>')->at('textarea')->val;

# "c"
$dom->parse('<option value="c">Test</option>')->at('option')->val;

# "d"
$dom->parse('<select><option selected>d</option></select>')
  ->at('select')->val;

# "e"
$dom->parse('<select multiple><option selected>e</option></select>')
  ->at('select')->val->[0];

# "on"
$dom->parse('<input name=test type=checkbox>')->at('input')->val;</pre>

<h2><a class='u'
name="with_roles"
>with_roles</a></h2>

<pre>my $new_class = Mojo::DOM->with_roles('Mojo::DOM::Role::One');
my $new_class = Mojo::DOM->with_roles('+One', '+Two');
$dom          = $dom->with_roles('+One', '+Two');</pre>

<p><a href="/Mojo::Base.html">Mojo::Base</a>の「with_roles」のエイリアス。</p>

<h2><a class='u'
name="wrap"
>wrap</a></h2>

<pre>$dom = $dom->wrap('<div></div>');
$dom = $dom->wrap(Mojo::DOM->new);</pre>

<p>HTML/XMLの断片をこのノード(<code>root</code>以外のすべてのノード)の周囲にラップします。もっとも内側の要素の最後の子として、それを配置します。</p>

<pre># "<p>123<b>Test</b></p>"
$dom->parse('<b>Test</b>')->at('b')->wrap('<p>123</p>')->root;

# "<div><p><b>Test</b></p>123</div>"
$dom->parse('<b>Test</b>')->at('b')->wrap('<div><p></p>123</div>')->root;

# "<p><b>Test</b></p><p>123</p>"
$dom->parse('<b>Test</b>')->at('b')->wrap('<p></p><p>123</p>')->root;

# "<p><b>Test</b></p>"
$dom->parse('<p>Test</p>')->at('p')->child_nodes->first->wrap('<b>')->root;</pre>

<h2><a class='u'
name="wrap_content"
>wrap_content</a></h2>

<pre>$dom = $dom->wrap_content('<div></div>');</pre>

<p>HTML/XMLの断片をこのノードのコンテンツ(<code>root</code>と<code>tag</code>ノード)の周囲にラップします。もっとも内側の要素の最後の子供として、それを配置します。</p>

<pre># "<p><b>123Test</b></p>"
$dom->parse('<p>Test<p>')->at('p')->wrap_content('<b>123</b>')->root;

# "<p><b>Test</b></p><p>123</p>"
$dom->parse('<b>Test</b>')->wrap_content('<p></p><p>123</p>');</pre>

<h2><a class='u'
name="xml"
>xml</a></h2>

<pre>my $bool = $dom->xml;
$dom     = $dom->xml($bool);</pre>

<p>解析において、HTMLセマンティクスを無効にし、 ケースセンシティブを有効にします。 デフォルトでは、構築の過程で 自動的に、検知されます。</p>

<h1><a class='u'
name="_"
>演算子</a></h1>

<p><a href="/Mojo::DOM.html">Mojo::DOM</a>は次の演算子をオーバーロードしています。</p>

<h2><a class='u'
name="array"
>array</a></h2>

<pre>my @nodes = @$dom;</pre>

<p><code>child_nodes</code>の別名。</p>

<pre># "<!-- Test -->"
$dom->parse('<!-- Test --><b>123</b>')->[0];</pre>

<h2><a class='u'
name="_"
>ブール</a></h2>

<pre>my $bool = !!$dom;</pre>

<p>いつでも真です。</p>

<h2><a class='u'
name="hash"
>hash</a></h2>

<pre>my %attrs = %$dom;</pre>

<p><code>attr</code>の別名。</p>

<pre># "test"
$dom->parse('<div id="test">Test</div>')->at('div')->{id};</pre>

<h1><a class='u'
name="_"
>参考</a></h1>

<p><a href="/Mojolicious.html">Mojolicious</a>, <a href="/Mojolicious::Guides.html">Mojolicious::Guides</a>, <a href="http://mojolicio.us" class="podlinkurl"
>http://mojolicio.us</a>.</p>

<p>(Mojolicious 8.12を反映。2019年5月4日)</p>

<!-- end doc -->

</body></html>

  </div>
  <div class="bottom">
    <!-- bottom -->

  </div>
</div>

        </div>
        <div class="side">
          <!-- side -->
<div class="side-list">
  <div class="side-list-title">
    Side Bar
  </div>
  <ul>
    <li><a href="/list.html">Entries</a></li>
    <li>Bar</li>
    <li>Baz</li>
  </ul>
</div>

        </div>
      </div>
      <div class="footer">
        <!-- footer -->
<a href="https://github.com/yuki-kimoto/giblog">Giblog</a>

      </div>
    </div>
  </body>
</html>
