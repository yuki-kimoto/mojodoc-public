<!DOCTYPE html>
<html>
  <head>
    <!-- meta -->
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0">
<link rel="icon" type="image/x-icon" href="/images/giblog-logo.png">
<link rel="stylesheet" type="text/css" href="/css/common.css">

<title> - Mojoliciousドキュメント 日本語訳</title>
<meta name="description" content="Mojolicious API リファレンス">
  </head>
  <body>
    <div class="container">
      <div class="header">
        <!-- header -->
<div class="main">
  <h1>
    <a href="/">Mojoliciousドキュメント 日本語訳</a>
  </h1>
</div>

      </div>
      <div class="main">
        <div class="content">
          <div class="entry">
  <div class="top">
    <!-- top -->

  </div>
  <div class="middle">
    <html><head><title>名前</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.40,
  using Pod::Simple::PullParser v3.40,
  under Perl v5.028000 at Tue Apr  7 04:16:23 2020 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<p><a href="/Mojolicious API リファレンス.html">Mojolicious API リファレンス</a></p>

<h1><a href="/Mojo::IOLoop.html"></a><a class='u'
name="_"
>名前</a></h1>

<p>Mojo::IOLoop - 最小限のイベントループ</p>

<h1><a class='u'
name="_"
>使い方</a></h1>

<pre>use Mojo::IOLoop;

# ポート3000でリッスン
Mojo::IOLoop->server({port => 3000} => sub {
  my ($loop, $stream) = @_;

  $stream->on(read => sub {
    my ($stream, $bytes) = @_;

    # 入力の処理
    say $bytes;

    # データを取得して、書き込む時
    $stream->write('HTTP/1.1 200 OK');
  });
});

# ポート3000に接続
my $id = Mojo::IOLoop->client({port => 3000} => sub {
  my ($loop, $err, $stream) = @_;

  $stream->on(read => sub {
    my ($stream, $bytes) = @_;

    # 入力の処理
    say "Input: $bytes";
  });

  # リクエストを書き込み
  $stream->write("GET / HTTP/1.1\x0d\x0a\x0d\x0a");
});

# タイマーの追加
Mojo::IOLoop->timer(5 => sub {
  my $loop = shift;
  $loop->remove($id);
});

# 必要であればループを開始
Mojo::IOLoop->start unless Mojo::IOLoop->is_running;</pre>

<h1><a class='u'
name="_"
>説明</a></h1>

<p><a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>は<a href="/Mojo::Reactor.html">Mojo::Reactor</a>をベースとした、最小限のイベントループです。 堅固でスケーラブルな非同期TPCクライアントとサーバーを構築するために 必要とされる完全な最小限の機能を備えています。</p>

<p>オペレーティングシステムに依存して、デフォルトのプロセスあたりとシステムワイドのファイルディスクリプタの制限が しばしばとても低く、よいスケーラビリティのために調整することが必要になります。 <code>LIBEV_FLAGS</code>環境変数は、もっともよい<a href="https://metacpan.org/pod/EV" class="podlinkpod"
>EV</a>バックエンドが選択されるようにすべきです。 通常のデフォルトはあまりスケーラブルではない<code>select</code>です。</p>

<pre>LIBEV_FLAGS=1   # select
LIBEV_FLAGS=2   # poll
LIBEV_FLAGS=4   # epoll (Linux)
LIBEV_FLAGS=8   # kqueue (*BSD, OS X)</pre>

<p>イベントループは<a href="https://metacpan.org/pod/Time%3A%3AHiRes" class="podlinkpod"
>Time::HiRes</a>を通して、モノトニック時刻が利用可能であれば、 時間ジャンプに対して回復力があるでしょう。</p>

<p>テストサーバーをできるだけ簡単に記述するためにTLS証明書とキーも組み込まれています。 利便性のために、<code>PIPE</code>シグナルが<a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>を読み込んだときに<code>IGNORE</code> に設定されることに注意してください。</p>

<p>よりよいスケーラビリティ(epoll, kqueue)とTLSサポートと同様にIPv6の提供のためには、 オプショナルなモジュールの<a href="https://metacpan.org/pod/EV" class="podlinkpod"
>EV</a> (4.0+)、<a href="https://metacpan.org/pod/Net%3A%3ADNS%3A%3ANative" class="podlinkpod"
>Net::DNS::Native</a> (0.15+) 、<a href="https://metacpan.org/pod/IO%3A%3ASocket%3A%3ASocks" class="podlinkpod"
>IO::Socket::Socks</a> (0.64+)と<a href="https://metacpan.org/pod/IO%3A%3ASocket%3A%3ASSL" class="podlinkpod"
>IO::Socket::SSL</a> (1.94+) が、インストールされていれば、自動的に利用されます。</p>

<p>個々の機能は<code>MOJO_NO_NDN</code>、<code>MOJO_NO_IPV6</code>、<code>MOJO_NO_TLS</code>環境変数で無効にすることもできます。</p>

<p><a href="/Mojolicious::Guides::Cookbook.html">Mojolicious::Guides::Cookbook</a>の<code>REAL-TIME WEB</code>の項目も見てください。</p>

<h1><a class='u'
name="_"
>イベント</a></h1>

<p><a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>は<a href="/Mojo::EventEmitter.html">Mojo::EventEmitter</a>からすべてのイベント継承し、 次の新しいものを発行します。</p>

<h2><a class='u'
name="finish"
>finish</a></h2>

<pre>$loop->on(finish => sub {
  my $loop = shift;
  ...
});</pre>

<p>イベントループが、緩やかにシャットダウンを要求し、 すべての存在する接続が閉じられるのを待っているときに発行されます。</p>

<h2><a class='u'
name="reset"
>reset</a></h2>

<pre>$loop->on(reset => sub {
  my $loop = shift;
  ...
});</pre>

<p>イベントループがリセットされたときに発行されます。これは、通常は、プロセスが共有できないリソースをクリーンアップするために、フォークされたときです。</p>

<h1><a class='u'
name="_"
>属性</a></h1>

<p><a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>は次の属性を実装しています。</p>

<h2><a class='u'
name="max_accepts"
>max_accepts</a></h2>

<pre>my $max = $loop->max_accepts;
$loop   = $loop->max_accepts(1000);</pre>

<p>存在している接続を中断することなしに、緩やかにシャットダウンされる前に、 このループが受け入れることのできる接続の最大数。デフォルトは<0>です。 この値を<code>0</code>にするとこのループは新しいコネクションを無限に受け入れます。 複数のサーバープロセスの間での ロードバランシングのロードを改善するために、 この値の半分はランダムに引き算されることに注意してください。</p>

<h2><a class='u'
name="max_connections"
>max_connections</a></h2>

<pre>my $max = $loop->max_connections;
$loop   = $loop->max_connections(100);</pre>

<p>新しくやってくる接続を受け入れることをやめる前に、 このループが処理することの可能な並列接続の最大数。 デフォルトは<code>1000</code>です。 この値を<code>0</code>にするとこのループはすべての新しい接続の受け入れを 停止し、存在する接続を中断することなしに、緩やかにシャットダウンを行うこと ができます。</p>

<h2><a class='u'
name="reactor"
>reactor</a></h2>

<pre>my $reactor = $loop->reactor;
$loop       = $loop->reactor(Mojo::Reactor->new);</pre>

<p>低レベルのイベント装置。通常は<a href="/Mojo::Reactor::Poll.html">Mojo::Reactor::Poll</a>あるいは<a href="/Mojo::Reactor::EV.html">Mojo::Reactor::EV</a>オブジェクト。これらは、デフォルトで<a href="/Mojo::Reactor.html">Mojo::Reactor</a>の<code>error</code>イベントを購読します。</p>

<pre># I/Oイベントのためにハンドルを監視
$loop->reactor->io($handle => sub {
  my ($reactor, $writable) = @_;
  say $writable ? 'Handle is writable' : 'Handle is readable';
});

# ハンドルが書き込み可能になったときのみ、監視するように変更
$loop->reactor->watch($handle, 0, 1);

# ハンドルを再び削除
$loop->reactor->remove($handle);</pre>

<h1><a class='u'
name="_"
>メソッド</a></h1>

<p><a href="/Mojo::IOLoop.html">Mojo::IOLoop</a>は<a href="/Mojo::Base.html">Mojo::Base</a>からすべてのメソッドを継承しており、 次の新しいメソッドを実装しています。</p>

<h2><a class='u'
name="acceptor"
>acceptor</a></h2>

<pre>my $server = Mojo::IOLoop->acceptor($id);
my $server = $loop->acceptor($id);
my $id     = $loop->acceptor(Mojo::IOLoop::Server->new);</pre>

<p>IDを指定して<a href="/Mojo::IOLoop::Server.html">Mojo::IOLoop::Server</a>オブジェクトを取得する、 あるいは、オブジェクトをアクセプターに変換する。</p>

<h2><a class='u'
name="client"
>client</a></h2>

<pre>my $id =
  Mojo::IOLoop->client(address => '127.0.0.1', port => 3000, sub {...});
my $id = $loop->client(address => '127.0.0.1', port => 3000, sub {...});
my $id = $loop->client({address => '127.0.0.1', port => 3000}, sub {...});</pre>

<p><code>client_class</code>でTCPコネクションをオープンします。 普通は<a href="/Mojo::IOLoop::Client.html">Mojo::IOLoop::Client</a>になります。 <a href="/Mojo::IOLoop::Client.html">Mojo::IOLoop::Client</a>の<code>connect</code>メソッドと同じ引数を受け取ります。</p>

<pre># ポート3000番で127.0.0.1に接続する
Mojo::IOLoop->client({port => 3000} => sub {
  my ($loop, $err, $stream) = @_;
  ...
});</pre>

<h2><a class='u'
name="delay"
>delay</a></h2>

<pre>my $delay = Mojo::IOLoop->delay;
my $delay = $loop->delay;
my $delay = $loop->delay(sub {...});
my $delay = $loop->delay(sub {...}, sub {...});</pre>

<p>イベントの流れを処理し、コントロールするための<a href="/Mojo::IOLoop::Delay.html">Mojo::IOLoop::Delay</a>オブジェクトを取得します。 ひとつのコールバックは、終わったイベントへのサブスクライバーとして扱われ、 複数のコールバックは、このステップのチェーンです。</p>

<pre># プロミスによる連続渡しスタイルのAPIでラッピング
my $ua = Mojo::UserAgent->new;
sub get {
  my $promise = Mojo::IOLoop->delay;
  $ua->get(@_ => sub {
    my ($ua, $tx) = @_;
    my $err = $tx->error;
    if   (!$err || $err->{code}) { $promise->resolve($tx) }
    else                         { $promise->reject($err->{message}) }
  });
  return $promise;
}
my $mojo = get('https://mojolicious.org');
my $cpan = get('https://metacpan.org');
Mojo::Promise->race($mojo, $cpan)->then(sub { say shift->req->url })->wait;

# 複数のノンブロックオペレーションを同期
my $delay = Mojo::IOLoop->delay(sub { say 'BOOM!' });
for my $i (1 .. 10) {
  my $end = $delay->begin;
  Mojo::IOLoop->timer($i => sub {
    say 10 - $i;
    $end->();
  });
}
$delay->wait;
 
# 複数のイベントを直列化
Mojo::IOLoop->delay(
 
  # 最初のステップ (単純なタイマー)
  sub {
    my $delay = shift;
    Mojo::IOLoop->timer(2 => $delay->begin);
    say 'Second step in 2 seconds.';
  },
 
  # 二回目のステップ (並列タイマー)
  sub {
    my $delay = shift;
    Mojo::IOLoop->timer(1 => $delay->begin);
    Mojo::IOLoop->timer(3 => $delay->begin);
    say 'Third step in 3 seconds.';
  },
 
  # 三回目のステップ (終わり)
  sub { say 'And done after 5 seconds total.' }
)->wait;
 
# すべてのステップで、例外を処理
Mojo::IOLoop->delay(
  sub {
    my $delay = shift;
    die 'Intentional error!';
  },
  sub {
    my ($delay, @args) = @_;
    say 'Never actually reached.';
  }
)->catch(sub {
  my ($delay, $err) = @_;
  say "Something went wrong: $err";
})->wait;</pre>

<h2><a class='u'
name="is_running"
>is_running</a></h2>

<pre>my $bool = Mojo::IOLoop->is_running;
my $bool = $loop->is_running;</pre>

<p>ループが実行されているかどうかをチェックします。</p>

<h2><a class='u'
name="next_tick"
>next_tick</a></h2>

<pre>my $undef = Mojo::IOLoop->next_tick(sub {...});
my $undef = $loop->next_tick(sub {...});</pre>

<p>できるだけすぐにコールバックを呼び出します。 しかし、リターンする前ではありません。 いつも<code>undef</code>を返します。</p>

<pre># 次のリアクターのチックに処理を実行
Mojo::IOLoop->next_tick(sub {
  my $loop = shift;
  ...
});</pre>

<h2><a class='u'
name="one_tick"
>one_tick</a></h2>

<pre>Mojo::IOLoop->one_tick;
$loop->one_tick;</pre>

<p>ひとつのイベントが起こるまで、あるいはもやはイベントが監視されなくなるまで、リアクターを実行します。 このメソッドはリアクターに戻るので、注意して利用する必要があります。</p>

<pre># 0.5秒以上はブロックしない。
my $id = Mojo::IOLoop->timer(0.5 => sub {});
Mojo::IOLoop->one_tick;
Mojo::IOLoop->remove($id);</pre>

<h2><a class='u'
name="recurring"
>recurring</a></h2>

<pre>my $id = Mojo::IOLoop->recurring(3 => sub {...});
my $id = $loop->recurring(0 => sub {...});
my $id = $loop->recurring(0.25 => sub {...});</pre>

<p>すべての装置の1目盛ごとに実行されるコールバック。 これはたとえば複数の装置を順番に実行することが可能になります。</p>

<pre># 5秒ごとに処理を実行する
Mojo::IOLoop->recurring(5 => sub {
  my $loop = shift;
  ...
});</pre>

<h2><a class='u'
name="remove"
>remove</a></h2>

<pre>Mojo::IOLoop->remove($id);
$loop->remove($id);</pre>

<p>IDを使って、切断します。 書き込みバッファにすべてのデータの書き込みを終えることによって、 緩やかにコネクションが切断されます。</p>

<h2><a class='u'
name="reset"
>reset</a></h2>

<pre>Mojo::IOLoop->reset;
$loop->reset;</pre>

<p>すべてを取り除き、イベントループを停止します。</p>

<h2><a class='u'
name="server"
>server</a></h2>

<pre>my $id = Mojo::IOLoop->server(port => 3000, sub {...});
my $id = $loop->server(port => 3000, sub {...});
my $id = $loop->server({port => 3000}, sub {...});</pre>

<p><code>server_class</code>でTCPコネクションを受け入れます。 通常は<a href="/Mojo::IOLoop::Server.html">Mojo::IOLoop::Server</a>になります。 <a href="/Mojo::IOLoop::Server.html">Mojo::IOLoop::Server</a>の<code>listen</code>メソッドと同じ引数を受け取ります。</p>

<pre># ランダムポートでリッスン
# Listen on random port
my $id = Mojo::IOLoop->server({address => '127.0.0.1'} => sub {
  my ($loop, $stream, $id) = @_;
  ...
});
my $port = Mojo::IOLoop->acceptor($id)->port;</pre>

<h2><a class='u'
name="singleton"
>singleton</a></h2>

<pre>my $loop = Mojo::IOLoop->singleton;</pre>

<p>グローバルなループオブジェクト。処理の内側のあらゆる場所から、 ひとつの共有されるループインスタンスにアクセスするために利用されます。</p>

<pre># 多くのメソッドはショットカットを行うことを許可します。
Mojo::IOLoop->timer(2 => sub { Mojo::IOLoop->stop });
Mojo::IOLoop->start;

# アクティブなタイマーの再起動
my $id = Mojo::IOLoop->timer(3 => sub { say 'Timeout!' });
Mojo::IOLoop->singleton->reactor->again($id);

# アクティブタイマーをリスタート
my $id = Mojo::IOLoop->timer(3 => sub { say 'Timeout!' });
Mojo::IOLoop->singleton->reactor->again($id);

# ファイルディスクリプタをハンドルに変換し、読み込み可能になるかを監視する
my $handle = IO::Handle->new_from_fd($fd, 'r');
Mojo::IOLoop->singleton->reactor->io($handle => sub {
  my ($reactor, $writable) = @_;
  say $writable ? 'Handle is writable' : 'Handle is readable';
})->watch($handle, 1, 0);</pre>

<h2><a class='u'
name="start"
>start</a></h2>

<pre>Mojo::IOLoop->start;
$loop->start;</pre>

<p>ループをスタートします。これは<code>stop</code>が呼び出されるまでブロックされます。 いくつかのリアクターは、監視されるイベントがなくなった場合に、 自動的に停止されることに注意してください。</p>

<pre># すでに開始していない場合だけ開始する
Mojo::IOLoop->start unless Mojo::IOLoop->is_running;</pre>

<h2><a class='u'
name="stop"
>stop</a></h2>

<pre>Mojo::IOLoop->stop;
$loop->stop;</pre>

<p>ループを即座に停止します。 これはすべての存在する接続を中断することはなく、 ループは<code>start</code>が再び実行されれば、再開始されます。</p>

<h2><a class='u'
name="stop_gracefully"
>stop_gracefully</a></h2>

<pre>Mojo::IOLoop->stop_gracefully;
$loop->stop_gracefully;</pre>

<p>新しい接続の受け入れを停止し、 イベントループを停止する前に、 すべての存在する接続が閉じられるのを待ちます。</p>

<h2><a class='u'
name="stream"
>stream</a></h2>

<pre>my $stream = Mojo::IOLoop->stream($id);
my $stream = $loop->stream($id);
my $id     = $loop->stream(Mojo::IOLoop::Stream->new);</pre>

<p>IDを指定して<a href="/Mojo::IOLoop::Stream.html">Mojo::IOLoop::Stream</a>オブジェクトを取得するか、 オブジェクトをコネクションに変換します。</p>

<pre># 接続のためのインアクティビティタイムアウトを300秒に増やす
Mojo::IOLoop->stream($id)->timeout(300);</pre>

<h2><a class='u'
name="subprocess"
>subprocess</a></h2>

<pre>my $subprocess = Mojo::IOLoop->subprocess(sub {...}, sub {...});
my $subprocess = $loop->subprocess;
my $subprocess = $loop->subprocess(sub {...}, sub {...});</pre>

<p>計算が高価なオペレーションを実行するために、イベントループのブロックなしで、<a href="/Mojo::IOLoop::Subprocess.html">Mojo::IOLoop::Subprocess</a>オブジェクトを構築します。 コールバックは<a href="/Mojo::IOLoop::Subprocess.html">Mojo::IOLoop::Subprocess</a>の"run"メソッドに渡されます。</p>

<pre># 5秒ブロックするイベントループをブロックするオペレーション
Mojo::IOLoop->subprocess(
  sub {
    my $subprocess = shift;
    sleep 5;
    return '♥', 'Mojolicious';
  },
  sub {
    my ($subprocess, $err, @results) = @_;
    say "Subprocess error: $err" and return if $err;
    say "I $results[0] $results[1]!";
  }
);</pre>

<h2><a class='u'
name="timer"
>timer</a></h2>

<pre>my $id = Mojo::IOLoop->timer(3 => sub {...});
my $id = $loop->timer(0 => sub {...});
my $id = $loop->timer(0.25 => sub {...});</pre>

<p>新しいタイマーを生成します。指定した秒数が経過後にコールバックは実行されます。</p>

<pre># 5秒のうちに処理を実行する
Mojo::IOLoop->timer(5 => sub {
  my $loop = shift;
  ...
});</pre>

<h1><a class='u'
name="_"
>デバッグ</a></h1>

<p>より詳細な情報を<code>STDERR</code>に出力するために、<code>MOJO_IOLOOP_DEBUG</code>環境変数を設定できます。</p>

<pre>MOJO_IOLOOP_DEBUG=1</pre>

<h1><a class='u'
name="_"
>参考</a></h1>

<p><a href="/Mojolicious.html">Mojolicious</a>, <a href="https://metacpan.org/pod/Mojolicious%3A%3AGuides" class="podlinkpod"
>Mojolicious::Guides</a>, <a href="http://mojolicio.us" class="podlinkurl"
>http://mojolicio.us</a>.</p>

<p>(Mojolicious 8.12を反映。2019年5月22日更新)</p>

<!-- end doc -->

</body></html>

  </div>
  <div class="bottom">
    <!-- bottom -->

  </div>
</div>

        </div>
        <div class="side">
          <!-- side -->
<div class="side-list">
  <div class="side-list-title">
    Side Bar
  </div>
  <ul>
    <li><a href="/list.html">Entries</a></li>
    <li>Bar</li>
    <li>Baz</li>
  </ul>
</div>

        </div>
      </div>
      <div class="footer">
        <!-- footer -->
<a href="https://github.com/yuki-kimoto/giblog">Giblog</a>

      </div>
    </div>
  </body>
</html>
